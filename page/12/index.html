<!doctype html><html lang=ko dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Jaejin's blog</title>
<meta name=keywords content="Hugo,theme,even"><meta name=description content="Jaejin Jang's blog"><meta name=author content="Jaejin Jang"><link rel=canonical href=https://jaejin0me.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jaejin0me.github.io/index.xml><link rel=alternate type=application/json href=https://jaejin0me.github.io/index.json><link rel=alternate hreflang=ko href=https://jaejin0me.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8691946909799297" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T")}</script><meta property="og:title" content="Jaejin's blog"><meta property="og:description" content="Jaejin Jang's blog"><meta property="og:type" content="website"><meta property="og:url" content="https://jaejin0me.github.io/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Jaejin's blog"><meta name=twitter:description content="Jaejin Jang's blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Jaejin's blog","url":"https://jaejin0me.github.io/","description":"Jaejin Jang's blog","thumbnailUrl":"https://jaejin0me.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io/ accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span class=active>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>책뿌수기 - SQL 레벨업 3</h2></header><div class=entry-content><p>3. SQL의 조건 분기 ch 8. UNION을 사용한 쓸데없이 긴 표현 UNION을 사용한 조건 분기는 좋지 않다. UNION은 내부적으로 여러개의 SELECT 구문을 실행하는 실행계획으로 해석된다 (= 테이블에 접근하는 횟수(I/O)가 늘어난다) 1) UNION을 사용한 조건 분기와 관련된 간단한 예제 UNION을 사용한 조건 분기 1 2 3 4 5 6 7 SELECT item_name, year, price_tax_ex AS price FROM Items WHERE year &lt;= 2001 UNION ALL SELECT item_name, year, price_tax_in AS price FROM Items WHERE year >= 2002 단점 : 1. 길다, 2. 테이블에 2회 접근한다. 2) WHERE 구에서 조건 분기를 하는 사람을 초보자 1 2 3 4 SELECT item_name, year CASE WHEN year &lt;= 2001 TEHN price_tax_ex WHEN year >= 2002 THEN price_tax_in END AS price FROM Items 3) SELECT 구를 사용한 조건 분기의 실행 계획 테이블 1회 접근으로 끝난다 구문 => 식, UNION => CASE ch 9. SELECT 구를 사용한 조건 분기의 실행 계획 1) 집계 대상으로 조건 분기 UNION을 사용한 방법 1 2 3 4 5 6 7 8 9 SELECT prefecture, SUM(pop_men) AS pop_men, SUM(pop_wom) AS pop_wom FROM(SELECT prefecture, pop AS pop_men null AS pop_wom) FROM Population WHERE sex = '1' # 남성 UNION SELECT prefecture, null AS pop_men, pop AS pop_wom FROM Population WHERE sex = '2') TMP # 여성 GROUP BY prefecture 풀스캔이 2회 수행된다.
...</p></div><footer class=entry-footer><span title='2019-01-20 22:20:56 +0900 +0900'>1월 20, 2019</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 책뿌수기 - SQL 레벨업 3" href=https://jaejin0me.github.io/post/posts104/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>책뿌수기 - SQL 레벨업-2</h2></header><div class=entry-content><p>인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다
1. SQL 기초 ch 6. SELECT 구문 1) SELECT 구와 FROM 구 SELECT 1 처럼 상수를 선택하는 경우 FROM이 필요없다. )2) WHERE 구 WHERE 구의 조건이 많을 경우 IN 으로 대체 SELECT 구문은 테이블을 반환하는 읽기 전용 함수 이다. 3) GROUP BY 구 일부 DBMS에서는 지원하지 않음 4) HAVING GROUP BY에 조건을 걸때 WHERE가 레코드에 조건을 거는 것이라면, HAVING은 집합에 조건을 거는 것 5) ORDER BY 6) 뷰와 서브쿼리 자주 사용하는 SELECT 구문을 DB에 저장 = 뷰(view) 뷰는 내부에 데이터러 보유하지 않음(SELECT 구문을 저장할 뿐) 서브쿼리의 실행과 동일하다 WHERE 조건에 서브쿼리를 거면 조건이 바뀌어도 문제없음(조건을 하나하나 하드코딩하는 번거로움을 없앨수있다) ch 7. 조건 분기, 집합 연산, 윈도우 함수, 갱신 1) SQL과 조건 분기 SQL의 조건 분기는 CASE식을 통해 한다. SQL의 조건 분기는 특정한 값을 리턴하는 것이 특징이다. CASE는 식이기 때문에 활용성이 높은 것이 강점이다. 2) SQL의 집합 연산 UNION : 합집합(기본적으로 중복을 제거) INTERSECT : 교집합 EXCEPT : 차집합 3) 윈도우 함수 집약 기능이 없는 GROUP BY 구 PARTITION BY SELECT 구에만 사용됨 윈도우 전용함수로 RANK, ROW_NUMBER가 있다. 4) 트랜잭션과 갱신 INSERT, UPDATE, DELETE</p></div><footer class=entry-footer><span title='2019-01-20 22:20:56 +0900 +0900'>1월 20, 2019</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 책뿌수기 - SQL 레벨업-2" href=https://jaejin0me.github.io/post/posts103/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>책뿌수기 - 현대 네트워크 기초 이론 1-2</h2></header><div class=entry-content><p>공부목적으로 정리합니다. 내용이 많아서 남은 부분은 다음 포스팅에.. * 1.8 네트워크 융합 전화와 정보 기술의 통합을 의미 애플리케이션 융합 기업의 최종 사용자 관점이다. 음성 통화, 음성 메일, 이메일, 인스터스 메신저와 같은 통신 애플리케이션을 작업 그룹 공동 작업, 고객 관계 관리(CRM : Customer Relationship Manager), 백오피스 (금융 기관의 후선 지원 입무) 기능 등의 비즈니스 애플리케이션과 통합한다. 융합된 애플리케이션은 체계적으로 통합한 음성, 데이터, 동영상에서 부가가치를 만드는 다채로운 기능을 제공한다. ex) 멀티미디어 메신저 기업 서비스 정보 네트워크를 다루는 관리자의 관점이다. 네트워크 관리자는 융합 애플리케이션을 위한 개인 인즉 정보 정책과 인증서비스를 제공한다. 모바일 사용자의 원격 프린트와 네트워크 저장 장치 서비스를 위해 사용자 위치 파악 애플리케이션 서비스를 위한 공동 환경 설정, QoS 인프라 스트럭처 기업의 통신 선로, LAN, WAN, 인터넷 회선 등으로 구성된다 사설/공용 클라우드로부터 대용량 데이터 스토리지와 웹 서비스를 호스팅 하는 데이터 센터까지의 연결도 포함하는 추세이다 핵심은 데이터 트래픽을 보내도록 설계된 네트워크와 음석 트래픽용 네트워크 간의 융합이다 간단히 기업의 음성, 동영상, 이미지 트래픽을 단일 네트워크 인프라 스트럭처로 보내는 것이다 융합의 기반은 IP 패킷 전송 기술이다 이점으로는 네트워크 관리의 단순화, 효율성의 증가, 애플리케이션의 유연성 증가(동영상, 데이터, 음성을 활용한 새로운 애플리케이션 발견 가능) 등이 있다 비용 절감 효율성 변화하기 쉬움 단일 장애점을 같는 문제가 있다. 이를 보완하기 위해 각 구성 요소와 백업 시스템을 다중화한다. 1.9 통합 커뮤니케이션(UC Unified Communication) 네트워크 통합에 연관된 개념 UC는 비즈니스 프로세스 최적화를 위한 실시간 커뮤니케이션 서비스의 통합에 초점을 둔다 마찬가지로 IP기술이 기초가 된다 핵심 다양한 장비와 미디어에 통합된 UI/UX를 제공 실시간 커뮤니케이션 서비스와 비실시간 서비스 및 비즈니스 프로세스 애플리케이션을 통합한다. 장점 개인 생산성 향상 작업 그룹성과 개선 기업 프로세스 개선 ...</p></div><footer class=entry-footer><span title='2018-12-31 00:50:56 +0900 +0900'>12월 31, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 책뿌수기 - 현대 네트워크 기초 이론 1-2" href=https://jaejin0me.github.io/post/posts132/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>책뿌수기 - SQL 레벨업-1</h2></header><div class=entry-content><p>인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다
1. DBMS 아키텍처 ch 1.DBMS 아키텍처 개요 1) 쿼리 평가 엔진 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지 결정 = 실행 계획(Explain plan) Access Method : 실행 계획에 기반을 둬서 데이터에 접근하는 방법 핵심 모듈이며 성능과도 깊은 관련이 있다 2) 버퍼 매니저 특별한 용도로 버퍼라는 메모리 영역을 확보해둔다 디스크 용량 매니저와 함께 작동한다 3) 디스크 용량 매니저 데이터를 어디에/어떻게 읽고 쓸지 관리 4) 트랜잭션 매니저와 락 매니저 동시 접근에 대한 안전성 제공 5) 리커버리 매니저 절대 잃어버리면 안되는 데이터를 장애로 잃었을시에 복구해주는 기능 ch 2. DBMS와 버퍼 1) 공짜 밥은 존재할까? 기억장치에 따른 트레이드오프, 무조건 좋은건 없다 2) DBMS가 기억장치의 관계 DBMS는 데이터 저장을 목적으로 하는 미드뤠어 이며, 사용하는 대표적인 기억장치는 다음과 같다 (1) 하드디스크(HDD) DBMS가 데이터를 저장하는 대부분 (2) 메모리 성능 향상을 위해 올려둠, I/O를 줄이기 위해 (3) 버퍼를 활용한 속도 향상 성능 향상을 목적으로 데이터를 저장하는 메모리를 버퍼, 캐시 버퍼 매니저 : 버퍼에 데이터를 어떻게, 어느 정도 기간 동안 올릴지 결정 3) 메모리 위에 있는 두 개의 버퍼 DBMS가 데이터를 유지하기 위해 사용하는 메모리는 크게. 1. 데이터 캐시, 2. 로그 버퍼 MySQL DBMS의 버퍼 메모리와 제어 매개변수 명칭 버퍼 풀 매개변수 innodb_buffuer_pool_size 초기값 128MB 설정값확인 SHOW VARIABLES LIKE ‘innodb_buffer_pool_size’ 명칭 로그 버퍼 매개변수 innodb_log_buffer_size 초기값 8MB 설정값확인 SHOW VARIABLES LIKE ‘innodb_log_buffer_size’ (1) 데이터 캐시 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 영역 SELECT 하는 데이터가 캐시 영역에 있다면 빨라짐 (2) 로그 버퍼 갱신 처리(INSERT, DELETE, UPDATE, MERGE)와 관련 갱신 관련 SQL이 오면 로그버퍼에 변경 정보를 보내고 이후에 디스크 변경을 수행(비동기 처리) 4) 메모리 성질이 초래하는 트레이프오프 (1) 휘발성 장애 발생시 데이터가 날라가버려 부정합이 발생한다. 커밋 시점에 갱신정보를 로그 파일(HDD에 존재)에씀으로 정합성 유지 반대로 커밋시에는 디스크에 동기 저근이 일어나기 때문에 지연이 발생할 가능성이 높아진다 5) 시스템 특성에 따른 트레이드오프 (1) 데이터 캐시와 로그 버퍼의 크기 기본적으로 데이터 캐시에 비해 로그 버퍼의 초기값이 굉장히 작다. 그 이유는 주된 작업이 검색이라고 가정하기 때문이다. (2) 검색과 갱신 중에서 중요한 것 6) 추가적인 메모리 영역 ‘워킹 메모리’ (1) 언제 사용될까? 2개의 버퍼 이외에도, 일반적인 메모리 영역을 하나더 가지고 있다 정렬 또는 해시 관련 처리에 사용되는 작업용 영역이다. 정렬은 ORDER BY, 집합 연산, 원도우 함수 해시는 테이블 결합시 MySQL 에서는 정렬 버퍼, sort_buffuer_size = 257kb 이 영역이 성능적으로 중요한 이뉴는, 이 영역의 양이 부족하며 저장소를 사용하기 때문이다(Swap) (2) 부족하면 무슨일이 일어 날까? ch 3. DBMS와 실행 계획 1) 권한 이양의 죄악 절차가 기초가 되는 언어는 (C, 자바, 루비)는 절차를 책임지고 기술하지만, RDB는 대상(what)을 기술하기 때문에 그 외 작업은 DBMS에 맡겼다. 2) 데이터에 접근하는 방법은 어떻게 결정할까? ...</p></div><footer class=entry-footer><span title='2018-12-30 22:20:56 +0900 +0900'>12월 30, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 책뿌수기 - SQL 레벨업-1" href=https://jaejin0me.github.io/post/posts102/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>책뿌수기 - 현대 네트워크 기초 이론 1-1</h2></header><div class=entry-content><p>공부목적으로 정리합니다. 내용이 많아서 남은 부분은 다음 포스팅에.. * Ch1. 현대 네트워킹의 요소 1.1 네트워크 생태계 궁극적으로 사용자는 애플리케이션과 콘텐츠에 접근하기 위해 네트워크 장비를 사용한다.
...</p></div><footer class=entry-footer><span title='2018-12-26 00:05:56 +0900 +0900'>12월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 책뿌수기 - 현대 네트워크 기초 이론 1-1" href=https://jaejin0me.github.io/post/posts131/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>도커란???</h2></header><div class=entry-content><p>초보를 위한 도커 안내서 - 도커란 무엇인가? 를 보고 간추린 내용 입니다.
도커 : 컨테이너 기반의 오픈소스 가상화 플랫폼 컨테이너 : 격리된 공간에서 프로세스가 동작하는 기술(프로세스 가상화) 기존의 가상화 방식 : OS 가상화 비교적 사용법이 간단하지만 무겁고 느리다 개선하기 위해 KVM(Kernel-based Virtual Machine)과 반가상화(Paravirtualization) 방식의 Xen이 등장한다. 이 방식은 게스트 OS가 필요하긴 하지만 전체 OS를 가상화 하는
방식이 아니였기 때문에 호스트형 가상화 방식에 비해 성능이 향상 되었다. OpenStack, AWS, Rackspace 같은 클라우드 서비스에서 가상 컴퓨팅기술의 기반이 되었다. ...</p></div><footer class=entry-footer><span title='2018-12-09 00:15:15 +0900 +0900'>12월 9, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 도커란???" href=https://jaejin0me.github.io/post/posts110/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>책뿌수기 - 기초가 든든한 데이터 베이스 11</h2></header><div class=entry-content><p>인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다
Ch 11. ER모델 Section 1. ER모델의 개념 개념적 데이터 모델의 대표적인 것 개체 집합, 속성 집합, 개체 집합 간의 관계 집합을 표현한 것 1.1 집합과 원소 집합(set) : 조건에 의해 대상이 분명한 것들의 모임 원소(element) : 집합의 구성 요소 1.2 ER모델 개체(entity)와 그들 간의 관계(relation-ship)을 이용해 현실세계를 개념적 구조로 표현하는 방법 개체간의 관계를 ERD(Entity-Relationship Diagram)으로 타난 낸다. 개체(직사각형), 속성(타원), 관계(마름모) 3개의 도형으로 표현된다. Section 2. ER모델의 구성 요소 2.1 개체 물리적으로 혹은 추상적/개념적으로 존재하는 실체 개체는 독립적으로 존재하며 서로 구별되는 특성을 가지고 있다. 다른 개체와 구별되는 이름을 가지며, 특성을 타나내는 속성을 하나 이상 가지고 있다. 개체 인스턴스(entity instance), 개체 어커런스(occurrence)란 실체화된 개체를 말한다. 용어 의미 관계 모델 개체 타입 동일한 속성들을 가진 개체 인스턴스들의 틀 릴레이션의 내포 개체 집합 동일한 속성들을 가진 개체 인스턴스들의 모음 릴레이션의 외면 개체 인스턴스 개체 타입을 구성하는 속성들이 실제 값을 가진 것 데이터 개체 발생시점에 따른 분류
...</p></div><footer class=entry-footer><span title='2018-12-06 00:20:56 +0900 +0900'>12월 6, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 책뿌수기 - 기초가 든든한 데이터 베이스 11" href=https://jaejin0me.github.io/post/posts101/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>책뿌수기 - 기초가 든든한 데이터 베이스 14</h2></header><div class=entry-content><p>인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다
Ch 14. 트랜잭션 Section 1. 트랜잭션의 개념 트랜잭션(transaction) : 데이터베이스 내에서 하나의 논리적 기능을 수행하기 위해 행해지는 한꺼번에 사용 되는 하나 이상의 쿼리를 모아
쪼갤 수 없는 작업의 논리적인 단위(logical unit of work) Section 2. 트랜잭션의 ACID 특성 Atomicity(원자성) Consistency(일관성) Isolation(고립성) Durability(지속성) 2.1 원자성 수행을 시작하면 한꺼번에 완전하게 전체가 수행이 완료되거나 아니면 어더한 연산도 수행되지 않는 All or Nothing 방식이다. 2.2 일관성 트랜잭션 시작 전후에 일관성 있는 DB상태를 유지 한다. 2.3 고립성 트랜잭션 작업 수행중에 다른 트랜잭션에 영향을 주어서도 안되고, 받아서도 안된다. 2.4 지속성 트랜잭션 작업이 성공적으로 수행되어 DB에 반영되었으면, 그 결과가 영구적으로 DB에 저장되어야 한다.
...</p></div><footer class=entry-footer><span title='2018-12-05 01:11:56 +0900 +0900'>12월 5, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 책뿌수기 - 기초가 든든한 데이터 베이스 14" href=https://jaejin0me.github.io/post/posts100/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>책뿌수기 - 기초가 든든한 데이터 베이스 12</h2></header><div class=entry-content><p>Ch 12. 정규화 Section 1. 이상 현상 anomaly : 불필요한 NULL이 삽입되거나, 연쇄 삭제, 데이터 일관성이 깨지는 현상 1.1 삽입 현상(insertion anomaly) 데이터 삽입 시 특정 열에 해당하는 값이 없어서 필요하지 않은 NULL을 강제로 입력해야 하는 현상 예) 신규 회원이 가입 되어 회원 정보를 넣지만 주문 정보가 없어 주문 정보를 NULL로 채워야 하는 상황 1.2 삭제 이상(delete anomaly) 데이터 삭제 시 유용한 다른 데이터까지 함께 삭제되는 현상 예) 주문을 취소했는데 회원 정보까지 사라짐 1.3 수정 이상(update anomaly) 중복 데이터중에서 일부만 수정되어 데이터의 불일치 문제가 불생하는 현상(inconsistency) Section 2. 정규화 normalization 이란 anomaly를 테이블 설계를 수정해 정상적으로 만드는 과정 관계형 데이터베이스에 저장될 구조의 중복을 최소화 하는 과정 이렇게 표현된 테이블이 어떤 특정의 제약 조건ㅇㄹ 만족하면 그 제약조건으로 정의된 정규형에 속하게 된다. 2.1 제 1 정규형 하나의 셀에는 하나의 값만 저장할 수 있다. 이 과정에서 기본키가 변경 될 수 있음 2.2 제 2 정규형 기본키 열과 기본 키가 아닌 열 간의 종속 곤계가 있을 경우 이를 별도의 테이블로 분리하는 과정 부분 종속을 없애는 과정 제 1 정규형이고, 키에 속하지 않는 속성 모두가 기본키에 완전 함수 종속이면, 제 2 정규형이다. 2.3 제 3 정규형 기본 키가 아닌 열끼리 종속 관계가 있을 경우 이를 분리하는 과정 제 2 정규형이고, 키에 속하지 않는 모든 속성들이 기본키에 이행적함수 종송이 아닐 때 제 3정규형에 속한다. 2.4 정규형 요약 DB 이론으로 제시된 정규형 필요시 참고 2.5 비정규화 정규화 이후에 성능 때문에 고려해 보는 것 분리된 테이블을 성능 향상(Join을 피하기 위해)을 위해 다시 합쳐야 하는 경우</p></div><footer class=entry-footer><span title='2018-12-04 01:26:56 +0900 +0900'>12월 4, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 책뿌수기 - 기초가 든든한 데이터 베이스 12" href=https://jaejin0me.github.io/post/posts99/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>책뿌수기 - 기초가 든든한 데이터 베이스 8</h2></header><div class=entry-content><p>Ch 8. 데이터 검색 Section 1. 기본적인 SELECT 명령문 SELECT [DISTINCT] 열_이름 ~
FROM 테이블_이름
[WHERE 조건
[중첩질의]]
[GROUP BY 열_이름[ ]]
[HAVING 조건]
[ORDER BY 열_이름 ~ [ASC|DESC]]; HAVING 절은 GROUP BY 절의 결과로 나내는 그룹을 제한하는 역할을 한다 Section 2. WHERE 절을 이용한 조건 검색 NOT 연산자는 속도가 느리므로 가급적 다른 연산자 사용을 권장 사이값 검색 : BETWEEN A AND B IN, NOT IN LIKE 연산자 : 문자 패턴 매칭 % : 0개 이상의 문자열 대체 [] : 지정된 범위의 한개 문자 대체 [^] : 지정된 범위에 없는 한 개 문자 대체 _ : 임의의 한개 문자 대체 NULL을 찾는 것은, IS NULL이나 IS NOT NULL 연산자를 사용한다. Section 3. ORDER BY절을 이용한 정렬 기본값은 ASC로 오름차순이다. NULL은 오름차순 일 경우 가장 마지막에 표시되는 값이다. SELECT 절에 나온 열의 위치를 이용해 정렬할 수도 있다. EX) ORDER BY 2 Section 4. 서브쿼리 하나의 SQL 명령문 처리 결과를 다른 SQL 명령문에 전달을 필요로 할 때 사용 예) 회원 테이블에서 송혜교와 등급이 동일한 회원들의 회원명, 등급, 주소를 검색하라 우선 서브쿼리를 이용해 송혜교의 등급을 검색한다 이후에 메인쿼리에서 전달받은 등급(송혜교 등급)과 동일한 회원의 정보를 검색한다 서브쿼리에는 ORDER BY 절을 사용할 수 없다 4.1 단일 행 서브쿼리 하나의 행만 메인쿼리에 반환하는 것 4.2 다중 행 서브쿼리 IN, NOT IN, EXISTS 연산자로 해결 Section 5. 집단함수를 이용한 요약 정보의 검색 검색된 행에서 요약된 내용을 필요로 할 때 5.1 집단함수 COUNT(), SUM(), AVG(), MAX(), MIN() SELECT나 HAVING 절에서 사용할 수 있다 5.2 그룹화, GROUP BY 5.3 그룹검색 조건, HAVING Section 6. 여러 개 테이블에서의 데이터 검색 6.1 조인(Join) 하나의 SQL 명령문으로 여러 테이블에 저장된 데이터를 한 번에 검색 테이블을 연결하기 위해서는 공통의 값, 외래키가 있어야 한다. N개의 테이블을 조인하기 위해서는 적어도 N-1 개의 조인 조건절이 필요하다. 열이름 앞에 테이블 이름을 지정하면, 구문분석시간이 줄어들어 SQL 처리 성능이 향상된다.</p></div><footer class=entry-footer><span title='2018-12-04 00:48:56 +0900 +0900'>12월 4, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 책뿌수기 - 기초가 든든한 데이터 베이스 8" href=https://jaejin0me.github.io/post/posts98/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://jaejin0me.github.io/page/11/>«&nbsp;이전 페이지&nbsp;
</a><a class=next href=https://jaejin0me.github.io/page/13/>다음 페이지&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>