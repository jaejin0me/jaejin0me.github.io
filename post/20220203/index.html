<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>몰입! 자바스크립트 - 23장 스코프 | Jaejin's blog</title>
<meta name=keywords content="javascript"><meta name=description content="이력 2022.02.03 포스팅 ​모든 내용을 상세히 담으려 하지 않았습니다. 제가 모르는 부분이나, &ldquo;이런 것도 있었어?&rdquo; 하는 부분, 중요하다고 생각"><meta name=author content="Jaejin Jang"><link rel=canonical href=https://jaejin0me.github.io/post/20220203/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://jaejin0me.github.io/post/20220203/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script><script>var doNotTrack=!1,dnt;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T")}</script><meta property="og:title" content="몰입! 자바스크립트 - 23장 스코프"><meta property="og:description" content="이력 2022.02.03 포스팅 ​모든 내용을 상세히 담으려 하지 않았습니다. 제가 모르는 부분이나, &ldquo;이런 것도 있었어?&rdquo; 하는 부분, 중요하다고 생각"><meta property="og:type" content="article"><meta property="og:url" content="https://jaejin0me.github.io/post/20220203/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-02-03T17:20:52+09:00"><meta property="article:modified_time" content="2022-02-03T17:20:52+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="몰입! 자바스크립트 - 23장 스코프"><meta name=twitter:description content="이력 2022.02.03 포스팅 ​모든 내용을 상세히 담으려 하지 않았습니다. 제가 모르는 부분이나, &ldquo;이런 것도 있었어?&rdquo; 하는 부분, 중요하다고 생각"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jaejin0me.github.io/post/"},{"@type":"ListItem","position":2,"name":"몰입! 자바스크립트 - 23장 스코프","item":"https://jaejin0me.github.io/post/20220203/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"몰입! 자바스크립트 - 23장 스코프","name":"몰입! 자바스크립트 - 23장 스코프","description":"이력 2022.02.03 포스팅 ​모든 내용을 상세히 담으려 하지 않았습니다. 제가 모르는 부분이나, \u0026ldquo;이런 것도 있었어?\u0026rdquo; 하는 부분, 중요하다고 생각","keywords":["javascript"],"articleBody":"이력\n2022.02.03 포스팅 ​모든 내용을 상세히 담으려 하지 않았습니다.\n제가 모르는 부분이나, “이런 것도 있었어?” 하는 부분, 중요하다고 생각되는 부분,\n다시 한번 되새기고 싶은 부분만 기록했습니다.\n읽어주셔서 감사합니다.\n오랜만에 올리네요 ㅎㅎ 느리지만 끝까지 올릴껍니다. 약속을 지키기 위해! 23.1 스코프 개요 js에서는 범위 개념을 스코프라고 한다. 스코프 구조는 계층적으로 형성된다. 함수가 호출되면 프로퍼티를 검색하는데, 없으면 상위 스코프에서 검색한다. 이런 함수 호출 시나리오를 만족하기 위해서는 스코프는 필수적으로 구조적이여야 한다는 것을 역으로 검증할 수 있다. 스코프는 함수를 실행할 때 설정되지 않고 function 키워드를 만나 Function 오브젝트를 생성할 때 설정된다. 내부 프로퍼티 [[Scope]]에 스코프의 참조값을 설정하고, [[Code]]에는 함수 코드를 설정한다. [[code]]에 함수코드만 설정되는 것이지 해석되는 것은 아니다. 해석은 호출된 이후의 과정이다. 23.2 글로벌 오브젝트 글로벌 오브젝트는 js의 시작점이다. 전체를 통해 하나만 존재한다. 그래서 오브젝트를 지정하고 않고 함수를 호출하면 지정하지 않아도 유일한 글로벌 오브젝트에서 검색하게 된다. 브라우저는 html 파일의 처음부터 읽어나가며 엘리먼트(head, body 태그 등)를 해석하여 실행환경을 만든다. 이것을 렌더링이라고 한다. script 태그를 만나면 js 실행환경을 만든다. js 엔진 렌더링이다. script 태그를 만날 때 마다 렌더링하지 않고 첫번째 script를 만날때만 렌더링 하므로 html 파일의 여러 script 태그에서도 하나만 존재하게 된다. 컴파일 과정에서는 글로벌 오브젝트를 사용할 수 있으므로 컴파일전에 생성한다. 23.3 글로벌 스코프 글로벌 스코프에서 못찾으면 더 나갈 스코프가 없으므로 undefined가 반환된다. 23.4 글로벌 변수 val, let, const 키워드 없이 변수를 작성하여 글로벌 변수가 된다. 23.5 글로벌 함수 23.6 지역 변수 지역변수를 선언하는 목적은 검색의 범위를 좁혀 변수를 빠르게 찾기위합니다(이에 더해 저는 데이터 분리의 목적도 있다고 생각합니다). 23.7 지역 함수 23.8 함수, 변수, 스코프의 처리 과정 23.9 바인딩 “스코프에서 변수를 찾는다\"는 개념적인 설명보다 구체적인 방법을 알아보자. 바인딩은 구조적으로 오브젝트와 이름이 결속된 상태로 만드는 것이다. 1 2 3 4 5 6 7 Obj Object: { name1: value1, name2: value2, . . . } 스코프가 상하구조로 연결된 개념을 스코프 체인이라고 한다. ES5 부터는 스코프 체인을 사용하지 않고, 훨씬 더 나은 개념을 사용해 js의 아키텍처와 메커니즘이 개선되었다. 바인딩 시점을 기준으로 정적 바인딩과 동적 바인딩으로 나눈다. 23.10 정적 바인딩 Function 오브젝트 생성시점에 현재 실행중인 오브젝트의 참조값을 [[Scope]]에 설정한다. 최상위 스코프는 크롬 개발자 도구에서 보면 window이다. 23.11 동적 바인딩 with문과 eval함수가 동적 바인딩을 한다. with 문을 실행할 때마다 바인딩한다. with문 파라미터의 오브젝트로 실행환경을 만들고, 해당 오브젝트의 프로퍼티를 실행환경에 설정한다. with문 블록의 코드가 해당실행환경에서 실행되므로 with 문의 파라미터를 오브젝트 지정없이 사용할 수 있게 된다. with Block이 with 파라미터로 만든 오브젝트이다. ","wordCount":"1249","inLanguage":"ko","datePublished":"2022-02-03T17:20:52+09:00","dateModified":"2022-02-03T17:20:52+09:00","author":{"@type":"Person","name":"Jaejin Jang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jaejin0me.github.io/post/20220203/"},"publisher":{"@type":"Organization","name":"Jaejin's blog","logo":{"@type":"ImageObject","url":"https://jaejin0me.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io/ accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">몰입! 자바스크립트 - 23장 스코프</h1><div class=post-meta><span title='2022-02-03 17:20:52 +0900 +0900'>2월 3, 2022</span>&nbsp;·&nbsp;Jaejin Jang</div></header><div class=post-content><p>이력</p><ul><li>2022.02.03 포스팅</li></ul><p><em>​모든 내용을 상세히 담으려 하지 않았습니다.<br>제가 모르는 부분이나, &ldquo;이런 것도 있었어?&rdquo; 하는 부분, 중요하다고 생각되는 부분,<br>다시 한번 되새기고 싶은 부분만 기록했습니다.<br>읽어주셔서 감사합니다.</em></p><ul><li>오랜만에 올리네요 ㅎㅎ 느리지만 끝까지 올릴껍니다. 약속을 지키기 위해!</li></ul><h2 id=231-스코프-개요>23.1 스코프 개요<a hidden class=anchor aria-hidden=true href=#231-스코프-개요>#</a></h2><ul><li>js에서는 범위 개념을 스코프라고 한다.</li><li>스코프 구조는 계층적으로 형성된다. 함수가 호출되면 프로퍼티를 검색하는데, 없으면 상위 스코프에서 검색한다. 이런 함수 호출 시나리오를 만족하기 위해서는 스코프는 필수적으로 구조적이여야 한다는 것을 역으로 검증할 수 있다.</li><li>스코프는 함수를 실행할 때 설정되지 않고 function 키워드를 만나 Function 오브젝트를 생성할 때 설정된다. 내부 프로퍼티 [[Scope]]에 스코프의 참조값을 설정하고, [[Code]]에는 함수 코드를 설정한다. [[code]]에 함수코드만 설정되는 것이지 해석되는 것은 아니다. 해석은 호출된 이후의 과정이다.</li></ul><h2 id=232-글로벌-오브젝트>23.2 글로벌 오브젝트<a hidden class=anchor aria-hidden=true href=#232-글로벌-오브젝트>#</a></h2><ul><li>글로벌 오브젝트는 js의 시작점이다.</li><li>전체를 통해 하나만 존재한다. 그래서 오브젝트를 지정하고 않고 함수를 호출하면 지정하지 않아도 유일한 글로벌 오브젝트에서 검색하게 된다.</li><li>브라우저는 html 파일의 처음부터 읽어나가며 엘리먼트(head, body 태그 등)를 해석하여 실행환경을 만든다. 이것을 렌더링이라고 한다.</li><li>script 태그를 만나면 js 실행환경을 만든다. js 엔진 렌더링이다. script 태그를 만날 때 마다 렌더링하지 않고 첫번째 script를 만날때만 렌더링 하므로 html 파일의 여러 script 태그에서도 하나만 존재하게 된다.</li><li>컴파일 과정에서는 글로벌 오브젝트를 사용할 수 있으므로 컴파일전에 생성한다.</li></ul><h2 id=233-글로벌-스코프>23.3 글로벌 스코프<a hidden class=anchor aria-hidden=true href=#233-글로벌-스코프>#</a></h2><ul><li>글로벌 스코프에서 못찾으면 더 나갈 스코프가 없으므로 undefined가 반환된다.</li></ul><h2 id=234-글로벌-변수>23.4 글로벌 변수<a hidden class=anchor aria-hidden=true href=#234-글로벌-변수>#</a></h2><ul><li>val, let, const 키워드 없이 변수를 작성하여 글로벌 변수가 된다.</li></ul><h2 id=235-글로벌-함수>23.5 글로벌 함수<a hidden class=anchor aria-hidden=true href=#235-글로벌-함수>#</a></h2><h2 id=236-지역-변수>23.6 지역 변수<a hidden class=anchor aria-hidden=true href=#236-지역-변수>#</a></h2><ul><li>지역변수를 선언하는 목적은 검색의 범위를 좁혀 변수를 빠르게 찾기위합니다(이에 더해 저는 데이터 분리의 목적도 있다고 생각합니다).</li></ul><h2 id=237-지역-함수>23.7 지역 함수<a hidden class=anchor aria-hidden=true href=#237-지역-함수>#</a></h2><h2 id=238-함수-변수-스코프의-처리-과정>23.8 함수, 변수, 스코프의 처리 과정<a hidden class=anchor aria-hidden=true href=#238-함수-변수-스코프의-처리-과정>#</a></h2><h2 id=239-바인딩>23.9 바인딩<a hidden class=anchor aria-hidden=true href=#239-바인딩>#</a></h2><ul><li>&ldquo;스코프에서 변수를 찾는다"는 개념적인 설명보다 구체적인 방법을 알아보자. 바인딩은 구조적으로 오브젝트와 이름이 결속된 상태로 만드는 것이다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Obj Object: {
</span></span><span class=line><span class=cl>  name1: value1,
</span></span><span class=line><span class=cl>  name2: value2,
</span></span><span class=line><span class=cl>  .
</span></span><span class=line><span class=cl>  .
</span></span><span class=line><span class=cl>  .
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ul><li>스코프가 상하구조로 연결된 개념을 스코프 체인이라고 한다. ES5 부터는 스코프 체인을 사용하지 않고, 훨씬 더 나은 개념을 사용해 js의 아키텍처와 메커니즘이 개선되었다.</li><li>바인딩 시점을 기준으로 정적 바인딩과 동적 바인딩으로 나눈다.</li></ul><h2 id=2310-정적-바인딩>23.10 정적 바인딩<a hidden class=anchor aria-hidden=true href=#2310-정적-바인딩>#</a></h2><ul><li>Function 오브젝트 생성시점에 현재 실행중인 오브젝트의 참조값을 [[Scope]]에 설정한다.</li><li>최상위 스코프는 크롬 개발자 도구에서 보면 window이다.
<img loading=lazy src=/20220203_1.png alt=fig.1 title=fig.1></li></ul><h2 id=2311-동적-바인딩>23.11 동적 바인딩<a hidden class=anchor aria-hidden=true href=#2311-동적-바인딩>#</a></h2><ul><li>with문과 eval함수가 동적 바인딩을 한다. with 문을 실행할 때마다 바인딩한다.</li><li>with문 파라미터의 오브젝트로 실행환경을 만들고, 해당 오브젝트의 프로퍼티를 실행환경에 설정한다. with문 블록의 코드가 해당실행환경에서 실행되므로 with 문의 파라미터를 오브젝트 지정없이 사용할 수 있게 된다.</li><li>with Block이 with 파라미터로 만든 오브젝트이다.
<img loading=lazy src=/20220203_2.png alt=fig.2 title=fig.2></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://jaejin0me.github.io/tags/javascript/>Javascript</a></li></ul></footer><script src=https://utteranc.es/client.js repo=jaejin0me/blog_comment issue-term=title label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>