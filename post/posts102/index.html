<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>책뿌수기 - SQL 레벨업-1 | Jaejin's blog</title>
<meta name=keywords content="sql 튜닝"><meta name=description content="인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다 1. DBMS 아키텍처 ch 1.DBMS 아키텍처 개요 1) 쿼리 평가 엔진 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지"><meta name=author content="Jaejin Jang"><link rel=canonical href=https://jaejin0me.github.io/post/posts102/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://jaejin0me.github.io/post/posts102/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T")}</script><meta property="og:title" content="책뿌수기 - SQL 레벨업-1"><meta property="og:description" content="인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다 1. DBMS 아키텍처 ch 1.DBMS 아키텍처 개요 1) 쿼리 평가 엔진 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지"><meta property="og:type" content="article"><meta property="og:url" content="https://jaejin0me.github.io/post/posts102/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-12-30T22:20:56+09:00"><meta property="article:modified_time" content="2018-12-30T22:20:56+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="책뿌수기 - SQL 레벨업-1"><meta name=twitter:description content="인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다 1. DBMS 아키텍처 ch 1.DBMS 아키텍처 개요 1) 쿼리 평가 엔진 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jaejin0me.github.io/post/"},{"@type":"ListItem","position":2,"name":"책뿌수기 - SQL 레벨업-1","item":"https://jaejin0me.github.io/post/posts102/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"책뿌수기 - SQL 레벨업-1","name":"책뿌수기 - SQL 레벨업-1","description":"인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다 1. DBMS 아키텍처 ch 1.DBMS 아키텍처 개요 1) 쿼리 평가 엔진 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지","keywords":["sql 튜닝"],"articleBody":"인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다\n1. DBMS 아키텍처 ch 1.DBMS 아키텍처 개요 1) 쿼리 평가 엔진 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지 결정 = 실행 계획(Explain plan) Access Method : 실행 계획에 기반을 둬서 데이터에 접근하는 방법 핵심 모듈이며 성능과도 깊은 관련이 있다 2) 버퍼 매니저 특별한 용도로 버퍼라는 메모리 영역을 확보해둔다 디스크 용량 매니저와 함께 작동한다 3) 디스크 용량 매니저 데이터를 어디에/어떻게 읽고 쓸지 관리 4) 트랜잭션 매니저와 락 매니저 동시 접근에 대한 안전성 제공 5) 리커버리 매니저 절대 잃어버리면 안되는 데이터를 장애로 잃었을시에 복구해주는 기능 ch 2. DBMS와 버퍼 1) 공짜 밥은 존재할까? 기억장치에 따른 트레이드오프, 무조건 좋은건 없다 2) DBMS가 기억장치의 관계 DBMS는 데이터 저장을 목적으로 하는 미드뤠어 이며, 사용하는 대표적인 기억장치는 다음과 같다 (1) 하드디스크(HDD) DBMS가 데이터를 저장하는 대부분 (2) 메모리 성능 향상을 위해 올려둠, I/O를 줄이기 위해 (3) 버퍼를 활용한 속도 향상 성능 향상을 목적으로 데이터를 저장하는 메모리를 버퍼, 캐시 버퍼 매니저 : 버퍼에 데이터를 어떻게, 어느 정도 기간 동안 올릴지 결정 3) 메모리 위에 있는 두 개의 버퍼 DBMS가 데이터를 유지하기 위해 사용하는 메모리는 크게. 1. 데이터 캐시, 2. 로그 버퍼 MySQL DBMS의 버퍼 메모리와 제어 매개변수 명칭 버퍼 풀 매개변수 innodb_buffuer_pool_size 초기값 128MB 설정값확인 SHOW VARIABLES LIKE ‘innodb_buffer_pool_size’ 명칭 로그 버퍼 매개변수 innodb_log_buffer_size 초기값 8MB 설정값확인 SHOW VARIABLES LIKE ‘innodb_log_buffer_size’ (1) 데이터 캐시 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 영역 SELECT 하는 데이터가 캐시 영역에 있다면 빨라짐 (2) 로그 버퍼 갱신 처리(INSERT, DELETE, UPDATE, MERGE)와 관련 갱신 관련 SQL이 오면 로그버퍼에 변경 정보를 보내고 이후에 디스크 변경을 수행(비동기 처리) 4) 메모리 성질이 초래하는 트레이프오프 (1) 휘발성 장애 발생시 데이터가 날라가버려 부정합이 발생한다. 커밋 시점에 갱신정보를 로그 파일(HDD에 존재)에씀으로 정합성 유지 반대로 커밋시에는 디스크에 동기 저근이 일어나기 때문에 지연이 발생할 가능성이 높아진다 5) 시스템 특성에 따른 트레이드오프 (1) 데이터 캐시와 로그 버퍼의 크기 기본적으로 데이터 캐시에 비해 로그 버퍼의 초기값이 굉장히 작다. 그 이유는 주된 작업이 검색이라고 가정하기 때문이다. (2) 검색과 갱신 중에서 중요한 것 6) 추가적인 메모리 영역 ‘워킹 메모리’ (1) 언제 사용될까? 2개의 버퍼 이외에도, 일반적인 메모리 영역을 하나더 가지고 있다 정렬 또는 해시 관련 처리에 사용되는 작업용 영역이다. 정렬은 ORDER BY, 집합 연산, 원도우 함수 해시는 테이블 결합시 MySQL 에서는 정렬 버퍼, sort_buffuer_size = 257kb 이 영역이 성능적으로 중요한 이뉴는, 이 영역의 양이 부족하며 저장소를 사용하기 때문이다(Swap) (2) 부족하면 무슨일이 일어 날까? ch 3. DBMS와 실행 계획 1) 권한 이양의 죄악 절차가 기초가 되는 언어는 (C, 자바, 루비)는 절차를 책임지고 기술하지만, RDB는 대상(what)을 기술하기 때문에 그 외 작업은 DBMS에 맡겼다. 2) 데이터에 접근하는 방법은 어떻게 결정할까? (1) 파서(parser) : 구문 분석 (2) 옵티마이저 인덱스 유무, 데이터 분산 or 편향 정도, DBMS 내부 매개변수를 고려해 여러 실행 계획을 작성하고, 비용을 연산한후 가장 비용이 낮은 실행계획을 선택한다 (3) 카탈로그 나머지 내부 정보를 모아 놓은 테이블로 옵티마이저에 중요한 정보를 제공한다 (4) 플랜 평가 최적의 실행 계획 선택 3) 옵티 마이저와 통계 정보 명령하는 대로 다처리해주는 만능이 아니다 통계 정보를 잘 관리해 줘야 한다 각 테이블의 레코드 수 각 테이블의 필드 수오 필드의 크기 필드의 카디널리티 필드 값의 히스토그램 인덱스 정보 4) 최적의 실행 계획이 작성되게 하려면 통계 정보를 잘 관리해줘야 한다. 갱신 필요 ch 4. 실행 계획이 SQL 구문의 성능을 결정 1) 실행 계획 확인 방법, EXPLAIN 참고로, 실행 계획의 실행 비용과 실행 시간은 추정값이기 때문에 맹신 해서는 안된다. 2) 테이블 풀 스캔의 실행 계획 1 * SELECT * FROM Shops; 실행 계획의 공통 3가지(중요한 factor) 조직 대상 객체 객체에 대한 조작의 종류 조작 대상이 되는 레코드 수 (1) 조직 대상 객체 테이블, 인덱스, 시퀀스 처럼 SQL 구문으로 조작할 수 있는 객체 (2) 객체에 대한 조작의 종류 시퀀셜 스캔 ~ 풀 스캔 (3) 조작 대상이 되는 레코드 수 3) 인덱스 스캔의 실행 계획 WHERE 조건 추가 4) 간단한 테이블 결합의 실행 계획(결합이 SQL의 주된 지연) 1 * SELECT shop_name FROM shops S INNER JOIN Reservations R On S.shop_id = R.shop_id; 결합에 3가지 알고리즘 사용 Nested Loop : 한쪽 테이블을 읽으며, 다른 쪽 테이블을 읽어 조건에 맞는 레코드있는 지 확인 Sort Merge : 결합 키로 레코드를 정렬(워킹 메모리 사용) Hash : 결합 키 값을 해시값으로 매핑. 워킹 메모리 필요. 결합시 테이블 접근 순서가 중요하다. 먼저 접근하는 테이블을 driving table 이라고 한다. ch 5. 실행 계획의 중요성 힌트를 사용해 실행 계획 강제화 가능 ","wordCount":"1855","inLanguage":"ko","datePublished":"2018-12-30T22:20:56+09:00","dateModified":"2018-12-30T22:20:56+09:00","author":{"@type":"Person","name":"Jaejin Jang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jaejin0me.github.io/post/posts102/"},"publisher":{"@type":"Organization","name":"Jaejin's blog","logo":{"@type":"ImageObject","url":"https://jaejin0me.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io/ accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">책뿌수기 - SQL 레벨업-1</h1><div class=post-meta><span title='2018-12-30 22:20:56 +0900 +0900'>12월 30, 2018</span>&nbsp;·&nbsp;Jaejin Jang</div></header><div class=post-content><p><em>인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다</em></p><h1 id=1-dbms-아키텍처>1. DBMS 아키텍처<a hidden class=anchor aria-hidden=true href=#1-dbms-아키텍처>#</a></h1><h2 id=ch-1dbms-아키텍처-개요>ch 1.DBMS 아키텍처 개요<a hidden class=anchor aria-hidden=true href=#ch-1dbms-아키텍처-개요>#</a></h2><p><img loading=lazy src=/posts102_1.jpg alt=Fig title="dbms 아키텍처"></p><h3 id=1-쿼리-평가-엔진>1) 쿼리 평가 엔진<a hidden class=anchor aria-hidden=true href=#1-쿼리-평가-엔진>#</a></h3><ul><li>SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지 결정 = 실행 계획(Explain plan)</li><li>Access Method : 실행 계획에 기반을 둬서 데이터에 접근하는 방법</li><li>핵심 모듈이며 성능과도 깊은 관련이 있다</li></ul><h3 id=2-버퍼-매니저>2) 버퍼 매니저<a hidden class=anchor aria-hidden=true href=#2-버퍼-매니저>#</a></h3><ul><li>특별한 용도로 버퍼라는 메모리 영역을 확보해둔다</li><li>디스크 용량 매니저와 함께 작동한다</li></ul><h3 id=3-디스크-용량-매니저>3) 디스크 용량 매니저<a hidden class=anchor aria-hidden=true href=#3-디스크-용량-매니저>#</a></h3><ul><li>데이터를 어디에/어떻게 읽고 쓸지 관리</li></ul><h3 id=4-트랜잭션-매니저와-락-매니저>4) 트랜잭션 매니저와 락 매니저<a hidden class=anchor aria-hidden=true href=#4-트랜잭션-매니저와-락-매니저>#</a></h3><ul><li>동시 접근에 대한 안전성 제공</li></ul><h3 id=5-리커버리-매니저>5) 리커버리 매니저<a hidden class=anchor aria-hidden=true href=#5-리커버리-매니저>#</a></h3><ul><li>절대 잃어버리면 안되는 데이터를 장애로 잃었을시에 복구해주는 기능</li></ul><h2 id=ch-2-dbms와-버퍼>ch 2. DBMS와 버퍼<a hidden class=anchor aria-hidden=true href=#ch-2-dbms와-버퍼>#</a></h2><h3 id=1-공짜-밥은-존재할까>1) 공짜 밥은 존재할까?<a hidden class=anchor aria-hidden=true href=#1-공짜-밥은-존재할까>#</a></h3><ul><li>기억장치에 따른 트레이드오프, 무조건 좋은건 없다</li></ul><h3 id=2-dbms가-기억장치의-관계>2) DBMS가 기억장치의 관계<a hidden class=anchor aria-hidden=true href=#2-dbms가-기억장치의-관계>#</a></h3><ul><li>DBMS는 데이터 저장을 목적으로 하는 미드뤠어 이며, 사용하는 대표적인 기억장치는 다음과 같다</li></ul><h4 id=1-하드디스크hdd>(1) 하드디스크(HDD)<a hidden class=anchor aria-hidden=true href=#1-하드디스크hdd>#</a></h4><ul><li>DBMS가 데이터를 저장하는 대부분</li></ul><h4 id=2-메모리>(2) 메모리<a hidden class=anchor aria-hidden=true href=#2-메모리>#</a></h4><ul><li>성능 향상을 위해 올려둠, I/O를 줄이기 위해</li></ul><h4 id=3-버퍼를-활용한-속도-향상>(3) 버퍼를 활용한 속도 향상<a hidden class=anchor aria-hidden=true href=#3-버퍼를-활용한-속도-향상>#</a></h4><ul><li>성능 향상을 목적으로 데이터를 저장하는 메모리를 버퍼, 캐시</li><li>버퍼 매니저 : 버퍼에 데이터를 어떻게, 어느 정도 기간 동안 올릴지 결정</li></ul><h3 id=3-메모리-위에-있는-두-개의-버퍼>3) 메모리 위에 있는 두 개의 버퍼<a hidden class=anchor aria-hidden=true href=#3-메모리-위에-있는-두-개의-버퍼>#</a></h3><ul><li>DBMS가 데이터를 유지하기 위해 사용하는 메모리는 크게. 1. 데이터 캐시, 2. 로그 버퍼</li><li>MySQL DBMS의 버퍼 메모리와 제어 매개변수</li></ul><table><thead><tr><th style=text-align:left>명칭</th><th style=text-align:left>버퍼 풀</th></tr></thead><tbody><tr><td style=text-align:left>매개변수</td><td style=text-align:left>innodb_buffuer_pool_size</td></tr><tr><td style=text-align:left>초기값</td><td style=text-align:left>128MB</td></tr><tr><td style=text-align:left>설정값확인</td><td style=text-align:left>SHOW VARIABLES LIKE &lsquo;innodb_buffer_pool_size&rsquo;</td></tr></tbody></table><table><thead><tr><th style=text-align:left>명칭</th><th style=text-align:left>로그 버퍼</th></tr></thead><tbody><tr><td style=text-align:left>매개변수</td><td style=text-align:left>innodb_log_buffer_size</td></tr><tr><td style=text-align:left>초기값</td><td style=text-align:left>8MB</td></tr><tr><td style=text-align:left>설정값확인</td><td style=text-align:left>SHOW VARIABLES LIKE &lsquo;innodb_log_buffer_size&rsquo;</td></tr></tbody></table><h4 id=1-데이터-캐시>(1) 데이터 캐시<a hidden class=anchor aria-hidden=true href=#1-데이터-캐시>#</a></h4><ul><li>디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 영역</li><li>SELECT 하는 데이터가 캐시 영역에 있다면 빨라짐</li></ul><h4 id=2-로그-버퍼>(2) 로그 버퍼<a hidden class=anchor aria-hidden=true href=#2-로그-버퍼>#</a></h4><ul><li>갱신 처리(INSERT, DELETE, UPDATE, MERGE)와 관련</li><li>갱신 관련 SQL이 오면 로그버퍼에 변경 정보를 보내고 이후에 디스크 변경을 수행(비동기 처리)</li></ul><h3 id=4-메모리-성질이-초래하는-트레이프오프>4) 메모리 성질이 초래하는 트레이프오프<a hidden class=anchor aria-hidden=true href=#4-메모리-성질이-초래하는-트레이프오프>#</a></h3><h4 id=1-휘발성>(1) 휘발성<a hidden class=anchor aria-hidden=true href=#1-휘발성>#</a></h4><ul><li>장애 발생시 데이터가 날라가버려 부정합이 발생한다.</li><li>커밋 시점에 갱신정보를 로그 파일(HDD에 존재)에씀으로 정합성 유지</li><li>반대로 커밋시에는 디스크에 동기 저근이 일어나기 때문에 지연이 발생할 가능성이 높아진다</li></ul><h3 id=5-시스템-특성에-따른-트레이드오프>5) 시스템 특성에 따른 트레이드오프<a hidden class=anchor aria-hidden=true href=#5-시스템-특성에-따른-트레이드오프>#</a></h3><h4 id=1-데이터-캐시와-로그-버퍼의-크기>(1) 데이터 캐시와 로그 버퍼의 크기<a hidden class=anchor aria-hidden=true href=#1-데이터-캐시와-로그-버퍼의-크기>#</a></h4><ul><li>기본적으로 데이터 캐시에 비해 로그 버퍼의 초기값이 굉장히 작다. 그 이유는 주된 작업이 검색이라고 가정하기 때문이다.</li></ul><h4 id=2-검색과-갱신-중에서-중요한-것>(2) 검색과 갱신 중에서 중요한 것<a hidden class=anchor aria-hidden=true href=#2-검색과-갱신-중에서-중요한-것>#</a></h4><h3 id=6-추가적인-메모리-영역-워킹-메모리>6) 추가적인 메모리 영역 &lsquo;워킹 메모리&rsquo;<a hidden class=anchor aria-hidden=true href=#6-추가적인-메모리-영역-워킹-메모리>#</a></h3><h4 id=1-언제-사용될까>(1) 언제 사용될까?<a hidden class=anchor aria-hidden=true href=#1-언제-사용될까>#</a></h4><ul><li>2개의 버퍼 이외에도, 일반적인 메모리 영역을 하나더 가지고 있다</li><li>정렬 또는 해시 관련 처리에 사용되는 작업용 영역이다.</li><li>정렬은 ORDER BY, 집합 연산, 원도우 함수</li><li>해시는 테이블 결합시</li><li>MySQL 에서는 정렬 버퍼, sort_buffuer_size = 257kb</li><li>이 영역이 성능적으로 중요한 이뉴는, 이 영역의 양이 부족하며 저장소를 사용하기 때문이다(Swap)</li></ul><h4 id=2-부족하면-무슨일이-일어-날까>(2) 부족하면 무슨일이 일어 날까?<a hidden class=anchor aria-hidden=true href=#2-부족하면-무슨일이-일어-날까>#</a></h4><h2 id=ch-3-dbms와-실행-계획>ch 3. DBMS와 실행 계획<a hidden class=anchor aria-hidden=true href=#ch-3-dbms와-실행-계획>#</a></h2><h3 id=1-권한-이양의-죄악>1) 권한 이양의 죄악<a hidden class=anchor aria-hidden=true href=#1-권한-이양의-죄악>#</a></h3><ul><li>절차가 기초가 되는 언어는 (C, 자바, 루비)는 절차를 책임지고 기술하지만, RDB는 대상(what)을 기술하기 때문에 그 외 작업은 DBMS에 맡겼다.</li></ul><h3 id=2-데이터에-접근하는-방법은-어떻게-결정할까>2) 데이터에 접근하는 방법은 어떻게 결정할까?<a hidden class=anchor aria-hidden=true href=#2-데이터에-접근하는-방법은-어떻게-결정할까>#</a></h3><p><img loading=lazy src=/posts102_2.jpg alt=Fig title="쿼리 처리 흐름"></p><h4 id=1-파서parser--구문-분석>(1) 파서(parser) : 구문 분석<a hidden class=anchor aria-hidden=true href=#1-파서parser--구문-분석>#</a></h4><h4 id=2-옵티마이저>(2) 옵티마이저<a hidden class=anchor aria-hidden=true href=#2-옵티마이저>#</a></h4><ul><li>인덱스 유무, 데이터 분산 or 편향 정도, DBMS 내부 매개변수를 고려해 여러 실행 계획을 작성하고, 비용을 연산한후 가장 비용이 낮은 실행계획을 선택한다</li></ul><h4 id=3-카탈로그-나머지>(3) 카탈로그 나머지<a hidden class=anchor aria-hidden=true href=#3-카탈로그-나머지>#</a></h4><ul><li>내부 정보를 모아 놓은 테이블로 옵티마이저에 중요한 정보를 제공한다</li></ul><h4 id=4-플랜-평가>(4) 플랜 평가<a hidden class=anchor aria-hidden=true href=#4-플랜-평가>#</a></h4><ul><li>최적의 실행 계획 선택</li></ul><h3 id=3-옵티-마이저와-통계-정보>3) 옵티 마이저와 통계 정보<a hidden class=anchor aria-hidden=true href=#3-옵티-마이저와-통계-정보>#</a></h3><ul><li>명령하는 대로 다처리해주는 만능이 아니다</li><li>통계 정보를 잘 관리해 줘야 한다</li><li>각 테이블의 레코드 수</li><li>각 테이블의 필드 수오 필드의 크기</li><li>필드의 카디널리티</li><li>필드 값의 히스토그램</li><li>인덱스 정보</li></ul><h3 id=4-최적의-실행-계획이-작성되게-하려면>4) 최적의 실행 계획이 작성되게 하려면<a hidden class=anchor aria-hidden=true href=#4-최적의-실행-계획이-작성되게-하려면>#</a></h3><ul><li>통계 정보를 잘 관리해줘야 한다. 갱신 필요</li></ul><h2 id=ch-4-실행-계획이-sql-구문의-성능을-결정>ch 4. 실행 계획이 SQL 구문의 성능을 결정<a hidden class=anchor aria-hidden=true href=#ch-4-실행-계획이-sql-구문의-성능을-결정>#</a></h2><h3 id=1-실행-계획-확인-방법-explain>1) 실행 계획 확인 방법, EXPLAIN<a hidden class=anchor aria-hidden=true href=#1-실행-계획-확인-방법-explain>#</a></h3><ul><li>참고로, 실행 계획의 실행 비용과 실행 시간은 추정값이기 때문에 맹신 해서는 안된다.</li></ul><h3 id=2-테이블-풀-스캔의-실행-계획>2) 테이블 풀 스캔의 실행 계획<a hidden class=anchor aria-hidden=true href=#2-테이블-풀-스캔의-실행-계획>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>* SELECT * FROM Shops;
</span></span></code></pre></td></tr></table></div></div><ul><li>실행 계획의 공통 3가지(중요한 factor)</li><li>조직 대상 객체</li><li>객체에 대한 조작의 종류</li><li>조작 대상이 되는 레코드 수</li></ul><h4 id=1-조직-대상-객체>(1) 조직 대상 객체<a hidden class=anchor aria-hidden=true href=#1-조직-대상-객체>#</a></h4><ul><li>테이블, 인덱스, 시퀀스 처럼 SQL 구문으로 조작할 수 있는 객체</li></ul><h4 id=2-객체에-대한-조작의-종류>(2) 객체에 대한 조작의 종류<a hidden class=anchor aria-hidden=true href=#2-객체에-대한-조작의-종류>#</a></h4><ul><li>시퀀셜 스캔 ~ 풀 스캔</li></ul><h4 id=3-조작-대상이-되는-레코드-수>(3) 조작 대상이 되는 레코드 수<a hidden class=anchor aria-hidden=true href=#3-조작-대상이-되는-레코드-수>#</a></h4><h3 id=3-인덱스-스캔의-실행-계획>3) 인덱스 스캔의 실행 계획<a hidden class=anchor aria-hidden=true href=#3-인덱스-스캔의-실행-계획>#</a></h3><ul><li>WHERE 조건 추가</li></ul><p><img loading=lazy src=/posts102_3.jpg alt=Fig title="풀 스캔 vs 인덱스 스캔"></p><h3 id=4-간단한-테이블-결합의-실행-계획결합이-sql의-주된-지연>4) 간단한 테이블 결합의 실행 계획(결합이 SQL의 주된 지연)<a hidden class=anchor aria-hidden=true href=#4-간단한-테이블-결합의-실행-계획결합이-sql의-주된-지연>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>* SELECT shop_name FROM shops S INNER JOIN Reservations R On S.shop_id = R.shop_id;
</span></span></code></pre></td></tr></table></div></div><ul><li>결합에 3가지 알고리즘 사용</li><li><ol><li>Nested Loop : 한쪽 테이블을 읽으며, 다른 쪽 테이블을 읽어 조건에 맞는 레코드있는 지 확인</li></ol></li><li><ol start=2><li>Sort Merge : 결합 키로 레코드를 정렬(워킹 메모리 사용)</li></ol></li><li><ol start=3><li>Hash : 결합 키 값을 해시값으로 매핑. 워킹 메모리 필요.</li></ol></li><li>결합시 테이블 접근 순서가 중요하다. 먼저 접근하는 테이블을 driving table 이라고 한다.</li></ul><h2 id=ch-5-실행-계획의-중요성>ch 5. 실행 계획의 중요성<a hidden class=anchor aria-hidden=true href=#ch-5-실행-계획의-중요성>#</a></h2><ul><li>힌트를 사용해 실행 계획 강제화 가능</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://jaejin0me.github.io/tags/sql-%ED%8A%9C%EB%8B%9D/>Sql 튜닝</a></li></ul></footer><script src=https://utteranc.es/client.js repo=jaejin0me/blog_comment issue-term=title label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>