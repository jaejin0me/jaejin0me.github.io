<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>책뿌수기 - SQL 레벨업 5 | Jaejin's blog</title>
<meta name=keywords content="sql 튜닝"><meta name=description content="인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다 5. 반복된(절차 지향형의 속박) ch 14. 반복문 의존증 RDB는 관계 전체를 조작의 대상으로 삼기 때문에 설계상에서"><meta name=author content="Jaejin Jang"><link rel=canonical href=https://jaejin0me.github.io/post/posts106/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://jaejin0me.github.io/post/posts106/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T",{anonymize_ip:!0})}</script><meta property="og:title" content="책뿌수기 - SQL 레벨업 5"><meta property="og:description" content="인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다 5. 반복된(절차 지향형의 속박) ch 14. 반복문 의존증 RDB는 관계 전체를 조작의 대상으로 삼기 때문에 설계상에서"><meta property="og:type" content="article"><meta property="og:url" content="https://jaejin0me.github.io/post/posts106/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-01-30T22:20:56+09:00"><meta property="article:modified_time" content="2019-01-30T22:20:56+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="책뿌수기 - SQL 레벨업 5"><meta name=twitter:description content="인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다 5. 반복된(절차 지향형의 속박) ch 14. 반복문 의존증 RDB는 관계 전체를 조작의 대상으로 삼기 때문에 설계상에서"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jaejin0me.github.io/post/"},{"@type":"ListItem","position":2,"name":"책뿌수기 - SQL 레벨업 5","item":"https://jaejin0me.github.io/post/posts106/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"책뿌수기 - SQL 레벨업 5","name":"책뿌수기 - SQL 레벨업 5","description":"인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다 5. 반복된(절차 지향형의 속박) ch 14. 반복문 의존증 RDB는 관계 전체를 조작의 대상으로 삼기 때문에 설계상에서","keywords":["sql 튜닝"],"articleBody":"인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다\n5. 반복된(절차 지향형의 속박) ch 14. 반복문 의존증 RDB는 관계 전체를 조작의 대상으로 삼기 때문에 설계상에서 반복을 제외했다 ch 15. 반복계의 공포 record at a time 사고 방식 반복계의 장점은 생각하기 쉽고 단순하다는 것 1) 반복계의 단점 성능 (1) SQL 실행의 오버헤드 전처리 a. sql 구문을 네트워크로 전송 b. DB 연결 c. sql 구문 파스 d. sql 구문의 실행 계획 생성 또는 평가 후처리 e. 결과 집합을 네트워크로 전송 a, e는 동일한 본체에 있거나 분리되어 있어도 고만고만함 b는 요즘에 커넥션 풀이라는 기술로 오버헤드를 감소시킴 c와 d가 주된 오버헤드이다. 그중에서도 c가 성가시다 c는 db가 sql을 받을때 마다 실행하므로 반복계에서는 오버헤드의 비중이 커진다 (2) 병렬 분산이 힘들다 반본계는 하나씩만 처리하기 때문에 병렬처리가 힘들다 저장소의 분산 효율이 낮다(하나씩 처리하다보니 한번에 처리하는 데이터가 얼마안됨) (3) 데이터 베이스의 진화로 인한 혜택을 받을 수 없다 대규모의 데이터를 효율적으로 다루기 위해 진화하고 있으나, 반복계를 사요하면 그 혜택을 받을 수 없다 포장계 sql이 반복계에 비해 복잡하므로 튜닝을 잘해야 하는 단점도 있는 반면 제대로만 튜닝하면 현격한 성능차이가 발생한다 반복계는 단순해 튜닝포인트도 적다 2) 반복계를 빠르게 만드는 방법은 없다 (1) 반복계를 포장계로 다시 작성 애플리케이션의 수정을 의미 (2) 각각의 sql을 빠르게 수정 너무 단순해 튜닝한 건덕지가 없음 (3) 다중화 처리 리소스 여유가 있고, 처리를 나눌 수 있는 키가 있고, 순서가 중요하지 않다면 다중화 가능 3) 반복계의 장점 sql이 단순하다 (1) 실행 계획의 안정성 실행계획이 바뀌어 느려지는 경우가 없다 (2) 예상 처리 시간의 정밀도 (3) 트랜잭션 제어가 편리 ch 16. sql에서는 반복을 어떻게 표현할까? 1) 포인트는 CASE식과 윈도우 함수 1 2 3 4 5 6 7 8 9 10 11 12 INSERT INTO Sales2 SELECT company, year, sale, CASE SIGN(sale - max(sale) OVER(PARTITION BY company ORDER BY year ROWS BETWEEN 1 PRECENDING AND\t1 PRECENDING) WHEN 0 THEN '=' WHEN 1 THEN '+' WHEN -1 THEN '-' ELSE NULL END AS Var FROM Sales; 1 ROWS BETWEEN 1 PRECENDING AND 1 PRECENDING 현재 레코드에서 1개 이전부터 1개 이전까지의 레코드 범위 지정\n상관 서브쿼리 : 서브쿼리 내부에서 외부 쿼리와의 결합 조건을 사용하고 해당 결합키로 잘라진 부분을 조작하는 기술\n2) 최대 반복수가 정해진 경우(경우별로 분기 가능) 우편 변호와 가장 인접한 지역찾기 문제 (1) 윈도우 함수를 사용한 스캔 횟수 감소 인전 순위의 최소값을 서브쿼리에서 찾기 때문에 테이블 스캔이 2회 발생 인덱스 온리 스캔 : SELECT 모두에 인덱스가 있을 때 사용 3) 반복 횟수가 정해지지 않은 경우(경우별로 분기불가) (1) 인접 리스트 모델과 재귀쿼리 이사 이력을 관리할때 포인터 체인을 사용 절차적으로 생각할때 가장 오래전에 살았던 주소를 찾는 방법은 재귀 공통 테이블식(recursion common table expression)이다. 계층 구조 찾는 법과 비슷하다 굉장히 유연하고, 꽤 효울적이지만 최근기능이라 지원안할 수도 있다. (2) 중첩 집합 모델 sql 에서 계층 구조를 나타내는 방법은 크게 3가지\n인접리스트 모델 중첩 집합 모델 경로 열거 모델 : 갱신이 거의 발생하지 않을 때 효율적 새로운 데이터가 생길때 마다 원 안에 추가하는 방법\nch 17. 바이어스(절차지향적)의 공죄 RDB에서 고성능을 실현하고자 한다면 절차 지향적인 바이어스에서 자유로워저라! ","wordCount":"1237","inLanguage":"ko","datePublished":"2019-01-30T22:20:56+09:00","dateModified":"2019-01-30T22:20:56+09:00","author":{"@type":"Person","name":"Jaejin Jang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jaejin0me.github.io/post/posts106/"},"publisher":{"@type":"Organization","name":"Jaejin's blog","logo":{"@type":"ImageObject","url":"https://jaejin0me.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io/ accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>책뿌수기 - SQL 레벨업 5</h1><div class=post-meta>&lt;span title='2019-01-30 22:20:56 +0900 +0900'>1월 30, 2019&lt;/span>&amp;nbsp;·&amp;nbsp;Jaejin Jang</div></header><div class=post-content><p><em>인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다</em></p><h1 id=5-반복된절차-지향형의-속박>5. 반복된(절차 지향형의 속박)<a hidden class=anchor aria-hidden=true href=#5-반복된절차-지향형의-속박>#</a></h1><h2 id=ch-14-반복문-의존증>ch 14. 반복문 의존증<a hidden class=anchor aria-hidden=true href=#ch-14-반복문-의존증>#</a></h2><ul><li>RDB는 관계 전체를 조작의 대상으로 삼기 때문에 설계상에서 반복을 제외했다</li></ul><h2 id=ch-15-반복계의-공포>ch 15. 반복계의 공포<a hidden class=anchor aria-hidden=true href=#ch-15-반복계의-공포>#</a></h2><ul><li>record at a time 사고 방식</li><li>반복계의 장점은 생각하기 쉽고 단순하다는 것</li></ul><h3 id=1-반복계의-단점>1) 반복계의 단점<a hidden class=anchor aria-hidden=true href=#1-반복계의-단점>#</a></h3><ul><li>성능</li></ul><h4 id=1-sql-실행의-오버헤드>(1) SQL 실행의 오버헤드<a hidden class=anchor aria-hidden=true href=#1-sql-실행의-오버헤드>#</a></h4><ul><li>전처리<ul><li>a. sql 구문을 네트워크로 전송</li><li>b. DB 연결</li><li>c. sql 구문 파스</li><li>d. sql 구문의 실행 계획 생성 또는 평가</li></ul></li><li>후처리<ul><li>e. 결과 집합을 네트워크로 전송</li></ul></li><li>a, e는 동일한 본체에 있거나 분리되어 있어도 고만고만함</li><li>b는 요즘에 커넥션 풀이라는 기술로 오버헤드를 감소시킴</li><li>c와 d가 주된 오버헤드이다. 그중에서도 c가 성가시다</li><li>c는 db가 sql을 받을때 마다 실행하므로 반복계에서는 오버헤드의 비중이 커진다</li></ul><h4 id=2-병렬-분산이-힘들다>(2) 병렬 분산이 힘들다<a hidden class=anchor aria-hidden=true href=#2-병렬-분산이-힘들다>#</a></h4><ul><li>반본계는 하나씩만 처리하기 때문에 병렬처리가 힘들다</li><li>저장소의 분산 효율이 낮다(하나씩 처리하다보니 한번에 처리하는 데이터가 얼마안됨)</li></ul><h4 id=3-데이터-베이스의-진화로-인한-혜택을-받을-수-없다>(3) 데이터 베이스의 진화로 인한 혜택을 받을 수 없다<a hidden class=anchor aria-hidden=true href=#3-데이터-베이스의-진화로-인한-혜택을-받을-수-없다>#</a></h4><ul><li>대규모의 데이터를 효율적으로 다루기 위해 진화하고 있으나, 반복계를 사요하면 그 혜택을 받을 수 없다</li><li>포장계 sql이 반복계에 비해 복잡하므로 튜닝을 잘해야 하는 단점도 있는 반면 제대로만 튜닝하면 현격한 성능차이가 발생한다</li><li>반복계는 단순해 튜닝포인트도 적다</li></ul><h3 id=2-반복계를-빠르게-만드는-방법은-없다>2) 반복계를 빠르게 만드는 방법은 없다<a hidden class=anchor aria-hidden=true href=#2-반복계를-빠르게-만드는-방법은-없다>#</a></h3><h4 id=1-반복계를-포장계로-다시-작성>(1) 반복계를 포장계로 다시 작성<a hidden class=anchor aria-hidden=true href=#1-반복계를-포장계로-다시-작성>#</a></h4><ul><li>애플리케이션의 수정을 의미</li></ul><h4 id=2-각각의-sql을-빠르게-수정>(2) 각각의 sql을 빠르게 수정<a hidden class=anchor aria-hidden=true href=#2-각각의-sql을-빠르게-수정>#</a></h4><ul><li>너무 단순해 튜닝한 건덕지가 없음</li></ul><h4 id=3-다중화-처리>(3) 다중화 처리<a hidden class=anchor aria-hidden=true href=#3-다중화-처리>#</a></h4><ul><li>리소스 여유가 있고, 처리를 나눌 수 있는 키가 있고, 순서가 중요하지 않다면 다중화 가능</li></ul><h3 id=3-반복계의-장점>3) 반복계의 장점<a hidden class=anchor aria-hidden=true href=#3-반복계의-장점>#</a></h3><ul><li>sql이 단순하다</li></ul><h4 id=1-실행-계획의-안정성>(1) 실행 계획의 안정성<a hidden class=anchor aria-hidden=true href=#1-실행-계획의-안정성>#</a></h4><ul><li>실행계획이 바뀌어 느려지는 경우가 없다</li></ul><h4 id=2-예상-처리-시간의-정밀도>(2) 예상 처리 시간의 정밀도<a hidden class=anchor aria-hidden=true href=#2-예상-처리-시간의-정밀도>#</a></h4><h4 id=3-트랜잭션-제어가-편리>(3) 트랜잭션 제어가 편리<a hidden class=anchor aria-hidden=true href=#3-트랜잭션-제어가-편리>#</a></h4><h2 id=ch-16-sql에서는-반복을-어떻게-표현할까>ch 16. sql에서는 반복을 어떻게 표현할까?<a hidden class=anchor aria-hidden=true href=#ch-16-sql에서는-반복을-어떻게-표현할까>#</a></h2><h3 id=1-포인트는-case식과-윈도우-함수>1) 포인트는 CASE식과 윈도우 함수<a hidden class=anchor aria-hidden=true href=#1-포인트는-case식과-윈도우-함수>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>INSERT INTO Sales2
</span></span><span class=line><span class=cl>SELECT company, year, sale,
</span></span><span class=line><span class=cl>	CASE SIGN(sale - max(sale)
</span></span><span class=line><span class=cl>		OVER(PARTITION BY company
</span></span><span class=line><span class=cl>				ORDER BY year 
</span></span><span class=line><span class=cl>				ROWS BETWEEN 1 PRECENDING
</span></span><span class=line><span class=cl>						AND	1 PRECENDING)
</span></span><span class=line><span class=cl>	WHEN 0 THEN &#39;=&#39;
</span></span><span class=line><span class=cl>	WHEN 1 THEN &#39;+&#39;
</span></span><span class=line><span class=cl>	WHEN -1 THEN &#39;-&#39;
</span></span><span class=line><span class=cl>	ELSE NULL END AS Var
</span></span><span class=line><span class=cl>	FROM Sales;
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ROWS BETWEEN 1 PRECENDING AND 1 PRECENDING
</span></span></code></pre></td></tr></table></div></div><ul><li><p>현재 레코드에서 1개 이전부터 1개 이전까지의 레코드 범위 지정</p></li><li><p>상관 서브쿼리 : 서브쿼리 내부에서 외부 쿼리와의 결합 조건을 사용하고 해당 결합키로 잘라진 부분을 조작하는 기술</p></li></ul><h3 id=2-최대-반복수가-정해진-경우경우별로-분기-가능>2) 최대 반복수가 정해진 경우(경우별로 분기 가능)<a hidden class=anchor aria-hidden=true href=#2-최대-반복수가-정해진-경우경우별로-분기-가능>#</a></h3><ul><li>우편 변호와 가장 인접한 지역찾기 문제</li></ul><h4 id=1-윈도우-함수를-사용한-스캔-횟수-감소>(1) 윈도우 함수를 사용한 스캔 횟수 감소<a hidden class=anchor aria-hidden=true href=#1-윈도우-함수를-사용한-스캔-횟수-감소>#</a></h4><ul><li>인전 순위의 최소값을 서브쿼리에서 찾기 때문에 테이블 스캔이 2회 발생</li><li>인덱스 온리 스캔 : SELECT 모두에 인덱스가 있을 때 사용</li></ul><h3 id=3-반복-횟수가-정해지지-않은-경우경우별로-분기불가>3) 반복 횟수가 정해지지 않은 경우(경우별로 분기불가)<a hidden class=anchor aria-hidden=true href=#3-반복-횟수가-정해지지-않은-경우경우별로-분기불가>#</a></h3><h4 id=1-인접-리스트-모델과-재귀쿼리>(1) 인접 리스트 모델과 재귀쿼리<a hidden class=anchor aria-hidden=true href=#1-인접-리스트-모델과-재귀쿼리>#</a></h4><ul><li>이사 이력을 관리할때 포인터 체인을 사용</li><li>절차적으로 생각할때 가장 오래전에 살았던 주소를 찾는 방법은 재귀 공통 테이블식(recursion common table expression)이다. 계층 구조 찾는 법과 비슷하다</li><li>굉장히 유연하고, 꽤 효울적이지만 최근기능이라 지원안할 수도 있다.</li></ul><h4 id=2-중첩-집합-모델>(2) 중첩 집합 모델<a hidden class=anchor aria-hidden=true href=#2-중첩-집합-모델>#</a></h4><ul><li><p>sql 에서 계층 구조를 나타내는 방법은 크게 3가지</p><ul><li><ol><li>인접리스트 모델</li></ol></li><li><ol start=2><li>중첩 집합 모델</li></ol></li><li><ol start=3><li>경로 열거 모델 : 갱신이 거의 발생하지 않을 때 효율적</li></ol></li></ul></li><li><p>새로운 데이터가 생길때 마다 원 안에 추가하는 방법</p></li></ul><h2 id=ch-17-바이어스절차지향적의-공죄>ch 17. 바이어스(절차지향적)의 공죄<a hidden class=anchor aria-hidden=true href=#ch-17-바이어스절차지향적의-공죄>#</a></h2><ul><li>RDB에서 고성능을 실현하고자 한다면 절차 지향적인 바이어스에서 자유로워저라!</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://jaejin0me.github.io/tags/sql-%ED%8A%9C%EB%8B%9D/>Sql 튜닝</a></li></ul></footer><script src=https://utteranc.es/client.js repo=jaejin0me/blog_comment issue-term=title label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>