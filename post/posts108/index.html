<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>책뿌수기 - SQL 레벨업 7 | Jaejin's blog</title>
<meta name=keywords content="sql 튜닝"><meta name=description content="7. 서브쿼리(곤란한 부분은 분할해야만 할까?) ch 21. 서브쿼리가 일으키는 폐해 1) 서브쿼리의 문제점 성능적 문제는 서브쿼리가 실체적인 데이터를 저장하고 있지 않다"><meta name=author content="Jaejin Jang"><link rel=canonical href=https://jaejin0me.github.io/post/posts108/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://jaejin0me.github.io/post/posts108/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script><script>var doNotTrack=!1,dnt;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T")}</script><meta property="og:title" content="책뿌수기 - SQL 레벨업 7"><meta property="og:description" content="7. 서브쿼리(곤란한 부분은 분할해야만 할까?) ch 21. 서브쿼리가 일으키는 폐해 1) 서브쿼리의 문제점 성능적 문제는 서브쿼리가 실체적인 데이터를 저장하고 있지 않다"><meta property="og:type" content="article"><meta property="og:url" content="https://jaejin0me.github.io/post/posts108/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-01-31T22:20:56+09:00"><meta property="article:modified_time" content="2019-01-31T22:20:56+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="책뿌수기 - SQL 레벨업 7"><meta name=twitter:description content="7. 서브쿼리(곤란한 부분은 분할해야만 할까?) ch 21. 서브쿼리가 일으키는 폐해 1) 서브쿼리의 문제점 성능적 문제는 서브쿼리가 실체적인 데이터를 저장하고 있지 않다"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jaejin0me.github.io/post/"},{"@type":"ListItem","position":2,"name":"책뿌수기 - SQL 레벨업 7","item":"https://jaejin0me.github.io/post/posts108/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"책뿌수기 - SQL 레벨업 7","name":"책뿌수기 - SQL 레벨업 7","description":"7. 서브쿼리(곤란한 부분은 분할해야만 할까?) ch 21. 서브쿼리가 일으키는 폐해 1) 서브쿼리의 문제점 성능적 문제는 서브쿼리가 실체적인 데이터를 저장하고 있지 않다","keywords":["sql 튜닝"],"articleBody":"7. 서브쿼리(곤란한 부분은 분할해야만 할까?) ch 21. 서브쿼리가 일으키는 폐해 1) 서브쿼리의 문제점 성능적 문제는 서브쿼리가 실체적인 데이터를 저장하고 있지 않다는 것에 있다. (1) 연산 비용 추가 서브쿼리 = SELECT 이므로 실행할때마다 SELECT 하는 것 (2) 데이터 I/O 비용 발생 연살결과가 커 저장소를 쓰게 되는 경우 급격한 속도 저하 발생 (3) 최적화를 받을 수 없음 서브쿼리의 결과에는 메타 정보가 없어 최적화가 불가능 2) 서브쿼리 의존증 (1) 서브쿼리를 사용한 방법 코드가 복잡해 읽기 어렵다 성능 결과가 일시적인 영역에 확보되므로 오버헤드 발생 최적화 불가 결합을 필요로 하기 때문에 비용이 높고 실행계획 변동 리스크가 존재 recipts 테이블 두번 스캔 필요 (2) 상관 서브쿼리는 답이 될 수 없다 어쨋든 테이블에 2번 접근해야 한다 (3) 윈도우 함수로 결합 해결 목표는 테이블 접근 1회로 줄이기 ROW_NUMBER를 사용해 구매 이력 번호를 붙이고, 이력이 1인 레코드 추출 3) 장기적인 관점에서의 리스크 관리 결합을 사용한 쿼리의 불안정 요소(상관 서브쿼리도 유사) 결합 알고리즘의 변동 리스크 환경 요인에 의한 지연 리스크(인덱스, 메모리, 매개변수 등) (1) 알고리즘 변동리스크 상황에 따라 변하는 결합 알고리즘 (2) 환경 요인에 의한 지연 리스크 결합을 사용한다는 것 = 장기적인 관점에서의 리스크 증가 4) 서브쿼리 의존증 - 응용편 (1) 다시 서브쿼리 의존증 (5) 서브쿼리는 정말 나쁠까? 생각하기는 쉬우나 RDB와는 맞지 않다 ch 22. 서브쿼리 사용이 더 나은 경우 결합쿼리는 최대한 결합 대상 레코드수를 줄이는 것이 중요한데, 옵티마이저가 잘 판단하지 못하는 경우 직접 연산 순서를 명시하는 용도로 힌트 사용 1) 결합과 집약 순서 (1) 두 가지 방법 결합 -\u003e 집약 집약 -\u003e 결합 (2) 결합 대상의 레코드 수 2의 경우 레코드수가 줄기 때문에 더 나은 선택일 수 있다(사전에 결합 레코드수 압축) ","wordCount":"690","inLanguage":"ko","datePublished":"2019-01-31T22:20:56+09:00","dateModified":"2019-01-31T22:20:56+09:00","author":{"@type":"Person","name":"Jaejin Jang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jaejin0me.github.io/post/posts108/"},"publisher":{"@type":"Organization","name":"Jaejin's blog","logo":{"@type":"ImageObject","url":"https://jaejin0me.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io/ accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">책뿌수기 - SQL 레벨업 7</h1><div class=post-meta><span title='2019-01-31 22:20:56 +0900 +0900'>1월 31, 2019</span>&nbsp;·&nbsp;Jaejin Jang</div></header><div class=post-content><h1 id=7-서브쿼리곤란한-부분은-분할해야만-할까>7. 서브쿼리(곤란한 부분은 분할해야만 할까?)<a hidden class=anchor aria-hidden=true href=#7-서브쿼리곤란한-부분은-분할해야만-할까>#</a></h1><h2 id=ch-21-서브쿼리가-일으키는-폐해>ch 21. 서브쿼리가 일으키는 폐해<a hidden class=anchor aria-hidden=true href=#ch-21-서브쿼리가-일으키는-폐해>#</a></h2><h3 id=1-서브쿼리의-문제점>1) 서브쿼리의 문제점<a hidden class=anchor aria-hidden=true href=#1-서브쿼리의-문제점>#</a></h3><ul><li>성능적 문제는 서브쿼리가 실체적인 데이터를 저장하고 있지 않다는 것에 있다.</li></ul><h4 id=1-연산-비용-추가>(1) 연산 비용 추가<a hidden class=anchor aria-hidden=true href=#1-연산-비용-추가>#</a></h4><ul><li>서브쿼리 = SELECT 이므로 실행할때마다 SELECT 하는 것</li></ul><h4 id=2-데이터-io-비용-발생>(2) 데이터 I/O 비용 발생<a hidden class=anchor aria-hidden=true href=#2-데이터-io-비용-발생>#</a></h4><ul><li>연살결과가 커 저장소를 쓰게 되는 경우 급격한 속도 저하 발생</li></ul><h4 id=3-최적화를-받을-수-없음>(3) 최적화를 받을 수 없음<a hidden class=anchor aria-hidden=true href=#3-최적화를-받을-수-없음>#</a></h4><ul><li>서브쿼리의 결과에는 메타 정보가 없어 최적화가 불가능</li></ul><h3 id=2-서브쿼리-의존증>2) 서브쿼리 의존증<a hidden class=anchor aria-hidden=true href=#2-서브쿼리-의존증>#</a></h3><h4 id=1-서브쿼리를-사용한-방법>(1) 서브쿼리를 사용한 방법<a hidden class=anchor aria-hidden=true href=#1-서브쿼리를-사용한-방법>#</a></h4><ul><li>코드가 복잡해 읽기 어렵다</li><li>성능<ul><li>결과가 일시적인 영역에 확보되므로 오버헤드 발생</li><li>최적화 불가</li><li>결합을 필요로 하기 때문에 비용이 높고 실행계획 변동 리스크가 존재</li><li>recipts 테이블 두번 스캔 필요</li></ul></li></ul><h4 id=2-상관-서브쿼리는-답이-될-수-없다>(2) 상관 서브쿼리는 답이 될 수 없다<a hidden class=anchor aria-hidden=true href=#2-상관-서브쿼리는-답이-될-수-없다>#</a></h4><ul><li>어쨋든 테이블에 2번 접근해야 한다</li></ul><h4 id=3-윈도우-함수로-결합-해결>(3) 윈도우 함수로 결합 해결<a hidden class=anchor aria-hidden=true href=#3-윈도우-함수로-결합-해결>#</a></h4><ul><li>목표는 테이블 접근 1회로 줄이기</li><li>ROW_NUMBER를 사용해 구매 이력 번호를 붙이고, 이력이 1인 레코드 추출</li></ul><h3 id=3-장기적인-관점에서의-리스크-관리>3) 장기적인 관점에서의 리스크 관리<a hidden class=anchor aria-hidden=true href=#3-장기적인-관점에서의-리스크-관리>#</a></h3><ul><li>결합을 사용한 쿼리의 불안정 요소(상관 서브쿼리도 유사)<ul><li>결합 알고리즘의 변동 리스크</li><li>환경 요인에 의한 지연 리스크(인덱스, 메모리, 매개변수 등)</li></ul></li></ul><h4 id=1-알고리즘-변동리스크>(1) 알고리즘 변동리스크<a hidden class=anchor aria-hidden=true href=#1-알고리즘-변동리스크>#</a></h4><ul><li>상황에 따라 변하는 결합 알고리즘</li></ul><h4 id=2-환경-요인에-의한-지연-리스크>(2) 환경 요인에 의한 지연 리스크<a hidden class=anchor aria-hidden=true href=#2-환경-요인에-의한-지연-리스크>#</a></h4><ul><li>결합을 사용한다는 것 = 장기적인 관점에서의 리스크 증가</li></ul><h3 id=4-서브쿼리-의존증---응용편>4) 서브쿼리 의존증 - 응용편<a hidden class=anchor aria-hidden=true href=#4-서브쿼리-의존증---응용편>#</a></h3><h4 id=1-다시-서브쿼리-의존증>(1) 다시 서브쿼리 의존증<a hidden class=anchor aria-hidden=true href=#1-다시-서브쿼리-의존증>#</a></h4><h4 id=5-서브쿼리는-정말-나쁠까>(5) 서브쿼리는 정말 나쁠까?<a hidden class=anchor aria-hidden=true href=#5-서브쿼리는-정말-나쁠까>#</a></h4><ul><li>생각하기는 쉬우나 RDB와는 맞지 않다</li></ul><h2 id=ch-22-서브쿼리-사용이-더-나은-경우>ch 22. 서브쿼리 사용이 더 나은 경우<a hidden class=anchor aria-hidden=true href=#ch-22-서브쿼리-사용이-더-나은-경우>#</a></h2><ul><li>결합쿼리는 최대한 결합 대상 레코드수를 줄이는 것이 중요한데, 옵티마이저가 잘 판단하지 못하는 경우 직접 연산 순서를 명시하는 용도로 힌트 사용</li></ul><h3 id=1-결합과-집약-순서>1) 결합과 집약 순서<a hidden class=anchor aria-hidden=true href=#1-결합과-집약-순서>#</a></h3><h4 id=1-두-가지-방법>(1) 두 가지 방법<a hidden class=anchor aria-hidden=true href=#1-두-가지-방법>#</a></h4><ul><li><ol><li>결합 -> 집약</li></ol></li><li><ol start=2><li>집약 -> 결합</li></ol></li></ul><h4 id=2-결합-대상의-레코드-수>(2) 결합 대상의 레코드 수<a hidden class=anchor aria-hidden=true href=#2-결합-대상의-레코드-수>#</a></h4><ul><li>2의 경우 레코드수가 줄기 때문에 더 나은 선택일 수 있다(사전에 결합 레코드수 압축)</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://jaejin0me.github.io/tags/sql-%ED%8A%9C%EB%8B%9D/>Sql 튜닝</a></li></ul></footer><script src=https://utteranc.es/client.js repo=jaejin0me/blog_comment issue-term=title label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>