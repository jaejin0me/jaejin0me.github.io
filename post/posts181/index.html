<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>책뿌수기 - SQL 레벨업 8 | Jaejin's blog</title><meta name=keywords content="sql 튜닝"><meta name=description content="8장. SQL의 순서 - 깨어나는 절차 지향 sql은 관계 모델의 이론에 기초하고 있기 때문에 순번을 다루기 위한 기능이 없다. 하지만 레코드에 순번을 붙여 처리하는 경"><meta name=author content="Jaejin Jang"><link rel=canonical href=https://jaejin0me.github.io/post/posts181/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-111561979-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview"))</script><meta property="og:title" content="책뿌수기 - SQL 레벨업 8"><meta property="og:description" content="8장. SQL의 순서 - 깨어나는 절차 지향 sql은 관계 모델의 이론에 기초하고 있기 때문에 순번을 다루기 위한 기능이 없다. 하지만 레코드에 순번을 붙여 처리하는 경"><meta property="og:type" content="article"><meta property="og:url" content="https://jaejin0me.github.io/post/posts181/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-05-28T23:49:45+09:00"><meta property="article:modified_time" content="2019-05-28T23:49:45+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="책뿌수기 - SQL 레벨업 8"><meta name=twitter:description content="8장. SQL의 순서 - 깨어나는 절차 지향 sql은 관계 모델의 이론에 기초하고 있기 때문에 순번을 다루기 위한 기능이 없다. 하지만 레코드에 순번을 붙여 처리하는 경"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://jaejin0me.github.io/post/"},{"@type":"ListItem","position":3,"name":"책뿌수기 - SQL 레벨업 8","item":"https://jaejin0me.github.io/post/posts181/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"책뿌수기 - SQL 레벨업 8","name":"책뿌수기 - SQL 레벨업 8","description":"8장. SQL의 순서 - 깨어나는 절차 지향 sql은 관계 모델의 이론에 기초하고 있기 때문에 순번을 다루기 위한 기능이 없다. 하지만 레코드에 순번을 붙여 처리하는 경","keywords":["sql 튜닝"],"articleBody":"8장. SQL의 순서 - 깨어나는 절차 지향 sql은 관계 모델의 이론에 기초하고 있기 때문에 순번을 다루기 위한 기능이 없다. 하지만 레코드에 순번을 붙여 처리하는 경우가 많아 관련기능(시퀀스 객체, ID 필드, 윈도우 함수)을 추가하고 있다. 23강. 레코드에 순번 붙이기 1. 기본키가 한 개의 필드일 경우 1) 윈도우 함수로 사용 ROW_NUMBER 함수를 사용 1 2 3 SELECT student_id, ROW_NUMBER() OVER (ORDER BY student_id) AS Seq FROM Weights; 2) 상관 서브쿼리 사용 1 2 3 4 5 SELECT student_id, (SELECT COUNT(*) FROM Weight W2 WHERE W2.student_id \u003c= W1.student_id) AS Seq FROM Weights W1; 기능은 동일하지만 1) 방법의 성능이 좋다. 스캔 횟수 1):1회, 2):2회 2. 기본 키가 여러 개의 필드로 구성되는 경우 1) 윈도우 함수를 사용 1 2 3 SELECT class, student_id, ROW_NUMBER() OVER (ORBER BY class, stduent_id) AS Seq FROM Weight2; 2) 상관 서브쿼리를 사용 다중 필드 비교하기(문자, 숫자, 3개 비교도 가능) 1 2 3 4 5 6 SELECT class, student_id, (SELECT\tCOUNT(*) FROM Weight W2 WHERE (W2.class, W2.student_id) \u003c= (W1.class, W1.stduent_id) AS Seq FROM Weight W1; 3. 그룹마다 순번을 붙이는 경우 1) 윈도우 함수를 사용 class 필드에 PARTITION BY 적용 1 2 3 SELECT class, student_id, ROW_NUMBER() OVER(PARTITION BY class ORDER BY student_id) AS Seq FROM Weight2; 2) 상관서브쿼리를 사용 1 2 3 4 5 6 SELECT class, student_id, (SELECT COUNT(*) FROM COUNT(*) WHERE W2.class = W1.class AND W2.student_id \u003c= W1.student_id) AS Seq FROM Weight2 W1; 4. 순번과 갱신 1) 윈도우 함수를 사용 셀렉트 쿼리를 SET에 넣으면 됨 1 2 3 4 5 6 7 8 UPDATE Weights3 SET Seq = (SELECT Seq FROM (SELECT class, student_id, ROW_NUMBER() OVER (PARTITION BY class ORDER BY student_id) AS Seq FROM Weights3) SeqTbl WHERE Weights3.class = SeqTbls.class AND Weights3.student_id = SeqTbl.student_id) 2) 상관 서브쿼리를 사용 1 2 3 4 5 UPDATE Weight3 SET seq = (SELECT COUNT(*) FROM Weight3 W2 WHERE W2.class = Weights3.class AND W2.student_id \u003c= Weight3.student_id) 24강. 레코드에 순번 붙이기 응용 1. 중앙값 구하기 1) 집합 지향적 방법 1 2 3 4 5 6 7 8 SELECT AVG(weight) FROM (SELECT W1.weight FROM Weights W1, Weights W2 GROUP BY W1.weight HAVING\tSUM(CASE WHEN W2.weight \u003e= W1.weight THEN 1 ELSE 0 END) \u003e= COUNT(*)/2 AND SUM(CASE WHEN W2.weight \u003c= W1.weight THEN 1 ELSE 0 END) \u003e= COUNT(*)/2) TMP; 코드가 복잡하다 성능이 나쁘다. w1과 w2간에 결합이 발생 2) 절차 지향적 방법 1 - 세계의 중심을 향해 sql에서 자연수의 특징을 활용하면 ‘양쪽 끝부터 숫자 세기’를 할 수 있다 1 2 3 4 5 6 SELECT AVG(weight) AS median FROM (SELECT weight, ROW_NUMBER() OVER (ORDER BY weight ASC, student_id ASC) AS hi, ROW_NUMBER() OVER (ORDER BY weight DESC, student_id DESC) AS lo FROM Weights) TMP WEHRE hi IN(lo, lo+1, lo+2); RANK 또는 DENSE_RANK를 사용해서는 안된다. 순위가 겹치거나 빌 수 있다. 테이블 접근 1회로 감소, 대신 정렬이 2회로 늘었다. ROW_NUMBER에서 사용하는 정렬이 오름/내림차순 2개라서 그렇다. 3) 절차 지향적 방법 2 - 2빼기 1은 1 성능적으로 개선하기 1 2 3 4 5 6 SELECT AVG(weight) FROM (SELECT weight, 2 * ROW_NUMBER() OVER(ORDER BY weight) - COUNT(*) OVER() AS diff FROM Weights) TMP WHERE diff BETWEEN 0 AND 2; 정렬리 1회로 줄어든다. 이 방법이 SQL 표준으로 중앙값을 구하는 가장 빠른 방법이다. 2. 순번을 사용한 테이블 분할 비어있는 자리 출력하기 1) 집합 지향적 방법 - 집합의 경계선 1 2 3 4 5 6 7 SELECT (N1.num + 1) AS gap_start, '~', (MIN(N2.min - 1) AS gap_end FROM Number N1 INNER JOIN Numbers N2 ON N2.num \u003e N1.num GROUP BY N1.num HAVING (N1.num + 1) \u003c MIN(N2.num); 코드도 간단하며 집합 지향적인 방식이라 좋다. 다만, 자기 결합을 사용해야 한다(Nested Loop). 2) 절차 지향적 방법 - 다음 레코드와 비교 컨셉 : 현재 레코드와 다음 레코드를 비교해 차이가 1이 아니면 1 2 3 4 5 6 7 8 9 10 SELECT NUM+1 AS gap_start, '~', (num + diff - 1) As gap_end FROM (SELECT num, MAX(num) OVER(ORDER BY num ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING) - num FROM numbers) TMP (num, diff) WHERE diff \u003c\u003e 1 테이블 접근 1회, 정렬 1회로 안정적 성능 3. 테이블에 존재하는 시퀀스 찾기 친구 또는 가족 인원수에 맞게 자리를 예약하는 경우 활용됨 1) 집합 지향적 방법 - 다시, 집합의 경계선 1 2 3 4 5 6 7 8 9 SELECT MIN(NUM) AS low, '~', MAX(num) AS high FROM (SELECT N1.num, COUNT(N2.num) - N1.num FROM Numbers N1 INNER JOIN Numbers N2 ON N2.num \u003c= N1.num GROUP BY N1.num) N(num, gp) GROUP BY gp; 2) 집합 지향적 방법 - 다시, 다음 레코드 하나와 비교 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 SELECT low, high FROM(SELECT low, CASE WHEN high IS NULL THEN MIN(high) OVER (ORDER BY seq ROW BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) ELSE high END AS high FROM (SELECT CASE WHEN COALESCE(prev_diff, 0) \u003c\u003e 1 THEN num ELSE NULL END AS low, CASE WHEN COALESCE(next_diff, 0) \u003c\u003e 1 THEN num ELSE NULL END As high, seq FROM (SELECT num, MAX(num) OVER(ORDER BY num ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING) - num AS next_diff, num - MAX(num) OVER(ORDER BY num ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING) AS prev_diff, ROW_NUMBER() OVER (ORDER BY num) AS seq FROM Numbers) TMP1 ) TMP2 ) TMP3 WHERE low IS NOT NULL; 25강. 시퀀스 객체, IDENTIFY 필드, 채번 테이블 표준 SQL에는 순번을 다루는 기능으로 시퀀셜 객체나 IDENTIFY 필드가 존재한다. 하지만 사용하는 것을 권장하지는 않고, 사용한다면 시퀀스 객체를 권한다. 1. 시퀀스 객체 테이블 또는 뷰처럼 스키마 내부에 존재하는 객체 중 하나 1 2 3 4 5 6 CREATE SEQUENCE testseq START WITH 1 INCREMENT BY 1 MAXVALUE 10000 MINVALUE 1 CYCLE; INSERT 구문에서 흔히 사용된다. 1) 시퀀스 객체의 문제점 표준화가 늦어서, 구현에 따라 구문이 달라 이식성이 없고, 사용할 수 없는 구현도 있다 시스템에서 자동으로 생성되는 값이므로 실제 엔티티 속성이 아니다. 성능적인 문제를 일으킨다 2) 시퀀스 객체로 발생하는 성능 문제 순서성(순번의 대소 관계가 유지됨), 유일성, 연속성 사용자 A가 시퀀스 객체에서 NEXT VALUE를 검색할 때의 처리 시퀀스 기개체에 배타 락을 적용 NEXT VALUEfmf rjator CURRENT VALUE를 1만큼 증가 시퀀스 객체에 배타 락을 해제 3) 시퀀스 객체로 발생하는 성능 문제의 대처 (1) CACHE 읽어들일 변수를 메모리에 설정하는 것, 다만 시스템 장애시 정상동작을 담보할 수 없다. (1) NOORDER 순서성을 담보하지 않음으로써 오버 헤드를 줄인다. 4) 순번을 키로 사용할 때의 성능 문제 Hot spot 과 관련된 문제임 DBMS는 비슷한 데이털르 연속적으로 INSERT하면 물리적으로 같은 영역에 저장한다. 이 때 특정 물리적 블록에만 I/O 부하가 커지므로 성능 악화가 발생 = Hot spot, Hot block 시퀀스 객체를 사용해 INSERT를 반복하는 경우 발생하고, 대처가 불가능 5) 순번을 키로 사용할 때의 성능 문제에 대처 (1) Oracle의 열 키 인덱스 연속된 값을 도입하는 경우라도 DBMS 내부에서 변화를 주어 제대로 분산할 수 있는 구조를 사용하는 것, 다만 SELECT 성능이 나빠질 수 있다. (2) 인덱스에 복잡한 필드를 추가해서 데이터의 분산도를 높인다. 논리적으로 좋은 설계가 아님 2. IDENTIFY 필드 ‘자동 순번 필드’라고도 한다. 테이블의 필드로 정의하고, INSERT 발생할때마다 자동을 순번을 붙여주는 기능이다. 시퀀스 객체에 비해 단점이 많다. 시퀀스 객체는 여러 테이블에서 사용가능하지만, IDENTIFY 필드는 특정 테이블에 국한된다. CACHE, NOORDER를 지정할 수도 없다. 이점이 거의 없다. 3. 채번 테이블 순번을 부여하기 위해 어플리케이션에서 채번 테이블이라는 것을 만들어 사용했었다. 구시대 유물이며 문제가 안생기기를 바라는 것이 최선(튜닝할 방법도 없다) ","wordCount":"2259","inLanguage":"ko","datePublished":"2019-05-28T23:49:45+09:00","dateModified":"2019-05-28T23:49:45+09:00","author":{"@type":"Person","name":"Jaejin Jang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jaejin0me.github.io/post/posts181/"},"publisher":{"@type":"Organization","name":"Jaejin's blog","logo":{"@type":"ImageObject","url":"https://jaejin0me.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>책뿌수기 - SQL 레벨업 8</h1><div class=post-meta><span title='2019-05-28 23:49:45 +0900 +0900'>5월 28, 2019</span>&nbsp;·&nbsp;Jaejin Jang</div></header><div class=post-content><h1 id=8장-sql의-순서---깨어나는-절차-지향>8장. SQL의 순서 - 깨어나는 절차 지향<a hidden class=anchor aria-hidden=true href=#8장-sql의-순서---깨어나는-절차-지향>#</a></h1><ul><li>sql은 관계 모델의 이론에 기초하고 있기 때문에 순번을 다루기 위한 기능이 없다.</li><li>하지만 레코드에 순번을 붙여 처리하는 경우가 많아 관련기능(시퀀스 객체, ID 필드, 윈도우 함수)을 추가하고 있다.</li></ul><h2 id=23강-레코드에-순번-붙이기>23강. 레코드에 순번 붙이기<a hidden class=anchor aria-hidden=true href=#23강-레코드에-순번-붙이기>#</a></h2><h3 id=1-기본키가-한-개의-필드일-경우>1. 기본키가 한 개의 필드일 경우<a hidden class=anchor aria-hidden=true href=#1-기본키가-한-개의-필드일-경우>#</a></h3><h4 id=1-윈도우-함수로-사용>1) 윈도우 함수로 사용<a hidden class=anchor aria-hidden=true href=#1-윈도우-함수로-사용>#</a></h4><ul><li>ROW_NUMBER 함수를 사용</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>student_id</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>ROW_NUMBER</span><span class=p>()</span><span class=w> </span><span class=n>OVER</span><span class=w> </span><span class=p>(</span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>student_id</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>Seq</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>FROM</span><span class=w> </span><span class=n>Weights</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=2-상관-서브쿼리-사용>2) 상관 서브쿼리 사용<a hidden class=anchor aria-hidden=true href=#2-상관-서브쿼리-사용>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>student_id</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>FROM</span><span class=w> </span><span class=n>Weight</span><span class=w> </span><span class=n>W2</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>WHERE</span><span class=w> </span><span class=n>W2</span><span class=p>.</span><span class=n>student_id</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>W1</span><span class=p>.</span><span class=n>student_id</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>Seq</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>FROM</span><span class=w> </span><span class=n>Weights</span><span class=w> </span><span class=n>W1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>기능은 동일하지만 1) 방법의 성능이 좋다. 스캔 횟수 1):1회, 2):2회</li></ul><h3 id=2-기본-키가-여러-개의-필드로-구성되는-경우>2. 기본 키가 여러 개의 필드로 구성되는 경우<a hidden class=anchor aria-hidden=true href=#2-기본-키가-여러-개의-필드로-구성되는-경우>#</a></h3><h4 id=1-윈도우-함수를-사용>1) 윈도우 함수를 사용<a hidden class=anchor aria-hidden=true href=#1-윈도우-함수를-사용>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>class</span><span class=p>,</span><span class=w> </span><span class=n>student_id</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>ROW_NUMBER</span><span class=p>()</span><span class=w> </span><span class=n>OVER</span><span class=w> </span><span class=p>(</span><span class=n>ORBER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=k>class</span><span class=p>,</span><span class=w> </span><span class=n>stduent_id</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>Seq</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>FROM</span><span class=w> </span><span class=n>Weight2</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=2-상관-서브쿼리를-사용>2) 상관 서브쿼리를 사용<a hidden class=anchor aria-hidden=true href=#2-상관-서브쿼리를-사용>#</a></h4><ul><li>다중 필드 비교하기(문자, 숫자, 3개 비교도 가능)</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>class</span><span class=p>,</span><span class=w> </span><span class=n>student_id</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>(</span><span class=k>SELECT</span><span class=w>	</span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>FROM</span><span class=w> </span><span class=n>Weight</span><span class=w> </span><span class=n>W2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>WHERE</span><span class=w> </span><span class=p>(</span><span class=n>W2</span><span class=p>.</span><span class=k>class</span><span class=p>,</span><span class=w> </span><span class=n>W2</span><span class=p>.</span><span class=n>student_id</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=o>&lt;=</span><span class=w> </span><span class=p>(</span><span class=n>W1</span><span class=p>.</span><span class=k>class</span><span class=p>,</span><span class=w> </span><span class=n>W1</span><span class=p>.</span><span class=n>stduent_id</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>Seq</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>FROM</span><span class=w> </span><span class=n>Weight</span><span class=w> </span><span class=n>W1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=3-그룹마다-순번을-붙이는-경우>3. 그룹마다 순번을 붙이는 경우<a hidden class=anchor aria-hidden=true href=#3-그룹마다-순번을-붙이는-경우>#</a></h3><h4 id=1-윈도우-함수를-사용-1>1) 윈도우 함수를 사용<a hidden class=anchor aria-hidden=true href=#1-윈도우-함수를-사용-1>#</a></h4><ul><li>class 필드에 PARTITION BY 적용</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>class</span><span class=p>,</span><span class=w> </span><span class=n>student_id</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>ROW_NUMBER</span><span class=p>()</span><span class=w> </span><span class=n>OVER</span><span class=p>(</span><span class=n>PARTITION</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=k>class</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>student_id</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>Seq</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>FROM</span><span class=w> </span><span class=n>Weight2</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=2-상관서브쿼리를-사용>2) 상관서브쿼리를 사용<a hidden class=anchor aria-hidden=true href=#2-상관서브쿼리를-사용>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>class</span><span class=p>,</span><span class=w> </span><span class=n>student_id</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>FROM</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>WHERE</span><span class=w> </span><span class=n>W2</span><span class=p>.</span><span class=k>class</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>W1</span><span class=p>.</span><span class=k>class</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>AND</span><span class=w> </span><span class=n>W2</span><span class=p>.</span><span class=n>student_id</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>W1</span><span class=p>.</span><span class=n>student_id</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>Seq</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>FROM</span><span class=w> </span><span class=n>Weight2</span><span class=w> </span><span class=n>W1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=4-순번과-갱신>4. 순번과 갱신<a hidden class=anchor aria-hidden=true href=#4-순번과-갱신>#</a></h3><h4 id=1-윈도우-함수를-사용-2>1) 윈도우 함수를 사용<a hidden class=anchor aria-hidden=true href=#1-윈도우-함수를-사용-2>#</a></h4><ul><li>셀렉트 쿼리를 SET에 넣으면 됨</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>UPDATE</span><span class=w> </span><span class=n>Weights3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>SET</span><span class=w> </span><span class=n>Seq</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>Seq</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=k>class</span><span class=p>,</span><span class=w> </span><span class=n>student_id</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>					</span><span class=n>ROW_NUMBER</span><span class=p>()</span><span class=w> </span><span class=n>OVER</span><span class=w> </span><span class=p>(</span><span class=n>PARTITION</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=k>class</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>							</span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>student_id</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>Seq</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>FROM</span><span class=w> </span><span class=n>Weights3</span><span class=p>)</span><span class=w> </span><span class=n>SeqTbl</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>WHERE</span><span class=w> </span><span class=n>Weights3</span><span class=p>.</span><span class=k>class</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SeqTbls</span><span class=p>.</span><span class=k>class</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>AND</span><span class=w> </span><span class=n>Weights3</span><span class=p>.</span><span class=n>student_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SeqTbl</span><span class=p>.</span><span class=n>student_id</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=2-상관-서브쿼리를-사용-1>2) 상관 서브쿼리를 사용<a hidden class=anchor aria-hidden=true href=#2-상관-서브쿼리를-사용-1>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>UPDATE</span><span class=w> </span><span class=n>Weight3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>SET</span><span class=w> </span><span class=n>seq</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>FROM</span><span class=w> </span><span class=n>Weight3</span><span class=w> </span><span class=n>W2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>WHERE</span><span class=w> </span><span class=n>W2</span><span class=p>.</span><span class=k>class</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Weights3</span><span class=p>.</span><span class=k>class</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>AND</span><span class=w> </span><span class=n>W2</span><span class=p>.</span><span class=n>student_id</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>Weight3</span><span class=p>.</span><span class=n>student_id</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=24강-레코드에-순번-붙이기-응용>24강. 레코드에 순번 붙이기 응용<a hidden class=anchor aria-hidden=true href=#24강-레코드에-순번-붙이기-응용>#</a></h2><h3 id=1-중앙값-구하기>1. 중앙값 구하기<a hidden class=anchor aria-hidden=true href=#1-중앙값-구하기>#</a></h3><h4 id=1-집합-지향적-방법>1) 집합 지향적 방법<a hidden class=anchor aria-hidden=true href=#1-집합-지향적-방법>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>AVG</span><span class=p>(</span><span class=n>weight</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>W1</span><span class=p>.</span><span class=n>weight</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>FROM</span><span class=w> </span><span class=n>Weights</span><span class=w> </span><span class=n>W1</span><span class=p>,</span><span class=w> </span><span class=n>Weights</span><span class=w> </span><span class=n>W2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>W1</span><span class=p>.</span><span class=n>weight</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>HAVING</span><span class=w>	</span><span class=k>SUM</span><span class=p>(</span><span class=k>CASE</span><span class=w> </span><span class=k>WHEN</span><span class=w> </span><span class=n>W2</span><span class=p>.</span><span class=n>weight</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>W1</span><span class=p>.</span><span class=n>weight</span><span class=w> </span><span class=k>THEN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=mi>1</span><span class=w> </span><span class=k>ELSE</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=k>END</span><span class=p>)</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>AND</span><span class=w> </span><span class=k>SUM</span><span class=p>(</span><span class=k>CASE</span><span class=w> </span><span class=k>WHEN</span><span class=w> </span><span class=n>W2</span><span class=p>.</span><span class=n>weight</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>W1</span><span class=p>.</span><span class=n>weight</span><span class=w> </span><span class=k>THEN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=mi>1</span><span class=w> </span><span class=k>ELSE</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=k>END</span><span class=p>)</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span><span class=p>)</span><span class=w> </span><span class=n>TMP</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>코드가 복잡하다</li><li>성능이 나쁘다. w1과 w2간에 결합이 발생</li></ul><h4 id=2-절차-지향적-방법-1---세계의-중심을-향해>2) 절차 지향적 방법 1 - 세계의 중심을 향해<a hidden class=anchor aria-hidden=true href=#2-절차-지향적-방법-1---세계의-중심을-향해>#</a></h4><ul><li>sql에서 자연수의 특징을 활용하면 &lsquo;양쪽 끝부터 숫자 세기&rsquo;를 할 수 있다</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>AVG</span><span class=p>(</span><span class=n>weight</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>median</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>weight</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>ROW_NUMBER</span><span class=p>()</span><span class=w> </span><span class=n>OVER</span><span class=w> </span><span class=p>(</span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>weight</span><span class=w> </span><span class=k>ASC</span><span class=p>,</span><span class=w> </span><span class=n>student_id</span><span class=w> </span><span class=k>ASC</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>hi</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>ROW_NUMBER</span><span class=p>()</span><span class=w> </span><span class=n>OVER</span><span class=w> </span><span class=p>(</span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>weight</span><span class=w> </span><span class=k>DESC</span><span class=p>,</span><span class=w> </span><span class=n>student_id</span><span class=w> </span><span class=k>DESC</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>lo</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>FROM</span><span class=w> </span><span class=n>Weights</span><span class=p>)</span><span class=w> </span><span class=n>TMP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>WEHRE</span><span class=w> </span><span class=n>hi</span><span class=w> </span><span class=k>IN</span><span class=p>(</span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=o>+</span><span class=mi>2</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>RANK 또는 DENSE_RANK를 사용해서는 안된다. 순위가 겹치거나 빌 수 있다.</li><li>테이블 접근 1회로 감소, 대신 정렬이 2회로 늘었다. ROW_NUMBER에서 사용하는 정렬이 오름/내림차순 2개라서 그렇다.</li></ul><h4 id=3-절차-지향적-방법-2---2빼기-1은-1>3) 절차 지향적 방법 2 - 2빼기 1은 1<a hidden class=anchor aria-hidden=true href=#3-절차-지향적-방법-2---2빼기-1은-1>#</a></h4><ul><li>성능적으로 개선하기</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>AVG</span><span class=p>(</span><span class=n>weight</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>weight</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=mi>2</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>ROW_NUMBER</span><span class=p>()</span><span class=w> </span><span class=n>OVER</span><span class=p>(</span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>weight</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=o>-</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=n>OVER</span><span class=p>()</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>diff</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>FROM</span><span class=w> </span><span class=n>Weights</span><span class=p>)</span><span class=w> </span><span class=n>TMP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>WHERE</span><span class=w> </span><span class=n>diff</span><span class=w> </span><span class=k>BETWEEN</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>정렬리 1회로 줄어든다. 이 방법이 SQL 표준으로 중앙값을 구하는 가장 빠른 방법이다.</li></ul><h3 id=2-순번을-사용한-테이블-분할>2. 순번을 사용한 테이블 분할<a hidden class=anchor aria-hidden=true href=#2-순번을-사용한-테이블-분할>#</a></h3><ul><li>비어있는 자리 출력하기</li></ul><h4 id=1-집합-지향적-방법---집합의-경계선>1) 집합 지향적 방법 - 집합의 경계선<a hidden class=anchor aria-hidden=true href=#1-집합-지향적-방법---집합의-경계선>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=p>(</span><span class=n>N1</span><span class=p>.</span><span class=n>num</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>gap_start</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	   </span><span class=s1>&#39;~&#39;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	   </span><span class=p>(</span><span class=k>MIN</span><span class=p>(</span><span class=n>N2</span><span class=p>.</span><span class=k>min</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>gap_end</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>FROM</span><span class=w> </span><span class=nb>Number</span><span class=w> </span><span class=n>N1</span><span class=w> </span><span class=k>INNER</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>Numbers</span><span class=w> </span><span class=n>N2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>ON</span><span class=w> </span><span class=n>N2</span><span class=p>.</span><span class=n>num</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>N1</span><span class=p>.</span><span class=n>num</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>N1</span><span class=p>.</span><span class=n>num</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>HAVING</span><span class=w> </span><span class=p>(</span><span class=n>N1</span><span class=p>.</span><span class=n>num</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=k>MIN</span><span class=p>(</span><span class=n>N2</span><span class=p>.</span><span class=n>num</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>코드도 간단하며 집합 지향적인 방식이라 좋다. 다만, 자기 결합을 사용해야 한다(Nested Loop).</li></ul><h4 id=2-절차-지향적-방법---다음-레코드와-비교>2) 절차 지향적 방법 - 다음 레코드와 비교<a hidden class=anchor aria-hidden=true href=#2-절차-지향적-방법---다음-레코드와-비교>#</a></h4><ul><li>컨셉 : 현재 레코드와 다음 레코드를 비교해 차이가 1이 아니면</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>NUM</span><span class=o>+</span><span class=mi>1</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>gap_start</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	   </span><span class=s1>&#39;~&#39;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	   </span><span class=p>(</span><span class=n>num</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>diff</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=k>As</span><span class=w> </span><span class=n>gap_end</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>num</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>MAX</span><span class=p>(</span><span class=n>num</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=n>OVER</span><span class=p>(</span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>num</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>					</span><span class=k>ROWS</span><span class=w> </span><span class=k>BETWEEN</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=n>FOLLOWING</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>							</span><span class=k>AND</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=n>FOLLOWING</span><span class=p>)</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>num</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>FROM</span><span class=w> </span><span class=n>numbers</span><span class=p>)</span><span class=w> </span><span class=n>TMP</span><span class=w> </span><span class=p>(</span><span class=n>num</span><span class=p>,</span><span class=w> </span><span class=n>diff</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>WHERE</span><span class=w> </span><span class=n>diff</span><span class=w> </span><span class=o>&lt;&gt;</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>테이블 접근 1회, 정렬 1회로 안정적 성능</li></ul><h3 id=3-테이블에-존재하는-시퀀스-찾기>3. 테이블에 존재하는 시퀀스 찾기<a hidden class=anchor aria-hidden=true href=#3-테이블에-존재하는-시퀀스-찾기>#</a></h3><ul><li>친구 또는 가족 인원수에 맞게 자리를 예약하는 경우 활용됨</li></ul><h4 id=1-집합-지향적-방법---다시-집합의-경계선>1) 집합 지향적 방법 - 다시, 집합의 경계선<a hidden class=anchor aria-hidden=true href=#1-집합-지향적-방법---다시-집합의-경계선>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>MIN</span><span class=p>(</span><span class=n>NUM</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>low</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	   </span><span class=s1>&#39;~&#39;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	   </span><span class=k>MAX</span><span class=p>(</span><span class=n>num</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>high</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>N1</span><span class=p>.</span><span class=n>num</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>COUNT</span><span class=p>(</span><span class=n>N2</span><span class=p>.</span><span class=n>num</span><span class=p>)</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>N1</span><span class=p>.</span><span class=n>num</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>FROM</span><span class=w> </span><span class=n>Numbers</span><span class=w> </span><span class=n>N1</span><span class=w> </span><span class=k>INNER</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>Numbers</span><span class=w> </span><span class=n>N2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>ON</span><span class=w> </span><span class=n>N2</span><span class=p>.</span><span class=n>num</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>N1</span><span class=p>.</span><span class=n>num</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>N1</span><span class=p>.</span><span class=n>num</span><span class=p>)</span><span class=w> </span><span class=n>N</span><span class=p>(</span><span class=n>num</span><span class=p>,</span><span class=w> </span><span class=n>gp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>gp</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=2-집합-지향적-방법---다시-다음-레코드-하나와-비교>2) 집합 지향적 방법 - 다시, 다음 레코드 하나와 비교<a hidden class=anchor aria-hidden=true href=#2-집합-지향적-방법---다시-다음-레코드-하나와-비교>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>low</span><span class=p>,</span><span class=w> </span><span class=n>high</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>FROM</span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>low</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>CASE</span><span class=w> </span><span class=k>WHEN</span><span class=w> </span><span class=n>high</span><span class=w> </span><span class=k>IS</span><span class=w> </span><span class=k>NULL</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>THEN</span><span class=w> </span><span class=k>MIN</span><span class=p>(</span><span class=n>high</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>					</span><span class=n>OVER</span><span class=w> </span><span class=p>(</span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>seq</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>						</span><span class=k>ROW</span><span class=w> </span><span class=k>BETWEEN</span><span class=w> </span><span class=k>CURRENT</span><span class=w> </span><span class=k>ROW</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>							</span><span class=k>AND</span><span class=w> </span><span class=n>UNBOUNDED</span><span class=w> </span><span class=n>FOLLOWING</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>ELSE</span><span class=w> </span><span class=n>high</span><span class=w> </span><span class=k>END</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>high</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=k>CASE</span><span class=w> </span><span class=k>WHEN</span><span class=w> </span><span class=n>COALESCE</span><span class=p>(</span><span class=n>prev_diff</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=o>&lt;&gt;</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>						</span><span class=k>THEN</span><span class=w> </span><span class=n>num</span><span class=w> </span><span class=k>ELSE</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>END</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>low</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>					</span><span class=k>CASE</span><span class=w> </span><span class=k>WHEN</span><span class=w> </span><span class=n>COALESCE</span><span class=p>(</span><span class=n>next_diff</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=o>&lt;&gt;</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>						</span><span class=k>THEN</span><span class=w> </span><span class=n>num</span><span class=w> </span><span class=k>ELSE</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>END</span><span class=w> </span><span class=k>As</span><span class=w> </span><span class=n>high</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>					</span><span class=n>seq</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=k>SELECT</span><span class=w> </span><span class=n>num</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>						</span><span class=k>MAX</span><span class=p>(</span><span class=n>num</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>						</span><span class=n>OVER</span><span class=p>(</span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>num</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>								</span><span class=k>ROWS</span><span class=w> </span><span class=k>BETWEEN</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=n>FOLLOWING</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>									</span><span class=k>AND</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=n>FOLLOWING</span><span class=p>)</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>num</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>next_diff</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>						</span><span class=n>num</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=k>MAX</span><span class=p>(</span><span class=n>num</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>							</span><span class=n>OVER</span><span class=p>(</span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>num</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>									</span><span class=k>ROWS</span><span class=w> </span><span class=k>BETWEEN</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=n>PRECEDING</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>										</span><span class=k>AND</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=n>PRECEDING</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>prev_diff</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>						</span><span class=n>ROW_NUMBER</span><span class=p>()</span><span class=w> </span><span class=n>OVER</span><span class=w> </span><span class=p>(</span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>num</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>seq</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>					</span><span class=k>FROM</span><span class=w> </span><span class=n>Numbers</span><span class=p>)</span><span class=w> </span><span class=n>TMP1</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=n>TMP2</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=n>TMP3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>low</span><span class=w> </span><span class=k>IS</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=25강-시퀀스-객체-identify-필드-채번-테이블>25강. 시퀀스 객체, IDENTIFY 필드, 채번 테이블<a hidden class=anchor aria-hidden=true href=#25강-시퀀스-객체-identify-필드-채번-테이블>#</a></h2><ul><li>표준 SQL에는 순번을 다루는 기능으로 시퀀셜 객체나 IDENTIFY 필드가 존재한다. 하지만 사용하는 것을 권장하지는 않고, 사용한다면 시퀀스 객체를 권한다.</li></ul><h3 id=1-시퀀스-객체>1. 시퀀스 객체<a hidden class=anchor aria-hidden=true href=#1-시퀀스-객체>#</a></h3><ul><li>테이블 또는 뷰처럼 스키마 내부에 존재하는 객체 중 하나</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=n>SEQUENCE</span><span class=w> </span><span class=n>testseq</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>START</span><span class=w> </span><span class=k>WITH</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INCREMENT</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>MAXVALUE</span><span class=w> </span><span class=mi>10000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>MINVALUE</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CYCLE</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>INSERT 구문에서 흔히 사용된다.</li></ul><h4 id=1-시퀀스-객체의-문제점>1) 시퀀스 객체의 문제점<a hidden class=anchor aria-hidden=true href=#1-시퀀스-객체의-문제점>#</a></h4><ul><li>표준화가 늦어서, 구현에 따라 구문이 달라 이식성이 없고, 사용할 수 없는 구현도 있다</li><li>시스템에서 자동으로 생성되는 값이므로 실제 엔티티 속성이 아니다.</li><li>성능적인 문제를 일으킨다</li></ul><h4 id=2-시퀀스-객체로-발생하는-성능-문제>2) 시퀀스 객체로 발생하는 성능 문제<a hidden class=anchor aria-hidden=true href=#2-시퀀스-객체로-발생하는-성능-문제>#</a></h4><ul><li>순서성(순번의 대소 관계가 유지됨), 유일성, 연속성</li><li>사용자 A가 시퀀스 객체에서 NEXT VALUE를 검색할 때의 처리</li></ul><ol><li>시퀀스 기개체에 배타 락을 적용</li><li>NEXT VALUEfmf rjator</li><li>CURRENT VALUE를 1만큼 증가</li><li>시퀀스 객체에 배타 락을 해제</li></ol><h4 id=3-시퀀스-객체로-발생하는-성능-문제의-대처>3) 시퀀스 객체로 발생하는 성능 문제의 대처<a hidden class=anchor aria-hidden=true href=#3-시퀀스-객체로-발생하는-성능-문제의-대처>#</a></h4><h5 id=1-cache>(1) CACHE<a hidden class=anchor aria-hidden=true href=#1-cache>#</a></h5><ol><li>읽어들일 변수를 메모리에 설정하는 것, 다만 시스템 장애시 정상동작을 담보할 수 없다.</li></ol><h5 id=1-noorder>(1) NOORDER<a hidden class=anchor aria-hidden=true href=#1-noorder>#</a></h5><ol><li>순서성을 담보하지 않음으로써 오버 헤드를 줄인다.</li></ol><h4 id=4-순번을-키로-사용할-때의-성능-문제>4) 순번을 키로 사용할 때의 성능 문제<a hidden class=anchor aria-hidden=true href=#4-순번을-키로-사용할-때의-성능-문제>#</a></h4><ul><li>Hot spot 과 관련된 문제임</li><li>DBMS는 비슷한 데이털르 연속적으로 INSERT하면 물리적으로 같은 영역에 저장한다. 이 때 특정 물리적 블록에만 I/O 부하가 커지므로 성능 악화가 발생 = Hot spot, Hot block</li><li>시퀀스 객체를 사용해 INSERT를 반복하는 경우 발생하고, 대처가 불가능</li></ul><h4 id=5-순번을-키로-사용할-때의-성능-문제에-대처>5) 순번을 키로 사용할 때의 성능 문제에 대처<a hidden class=anchor aria-hidden=true href=#5-순번을-키로-사용할-때의-성능-문제에-대처>#</a></h4><h5 id=1-oracle의-열-키-인덱스>(1) Oracle의 열 키 인덱스<a hidden class=anchor aria-hidden=true href=#1-oracle의-열-키-인덱스>#</a></h5><ul><li>연속된 값을 도입하는 경우라도 DBMS 내부에서 변화를 주어 제대로 분산할 수 있는 구조를 사용하는 것, 다만 SELECT 성능이 나빠질 수 있다.</li></ul><h5 id=2-인덱스에-복잡한-필드를-추가해서-데이터의-분산도를-높인다>(2) 인덱스에 복잡한 필드를 추가해서 데이터의 분산도를 높인다.<a hidden class=anchor aria-hidden=true href=#2-인덱스에-복잡한-필드를-추가해서-데이터의-분산도를-높인다>#</a></h5><ul><li>논리적으로 좋은 설계가 아님</li></ul><h3 id=2-identify-필드>2. IDENTIFY 필드<a hidden class=anchor aria-hidden=true href=#2-identify-필드>#</a></h3><ul><li>&lsquo;자동 순번 필드&rsquo;라고도 한다. 테이블의 필드로 정의하고, INSERT 발생할때마다 자동을 순번을 붙여주는 기능이다.</li><li>시퀀스 객체에 비해 단점이 많다.</li><li>시퀀스 객체는 여러 테이블에서 사용가능하지만, IDENTIFY 필드는 특정 테이블에 국한된다.</li><li>CACHE, NOORDER를 지정할 수도 없다.</li><li>이점이 거의 없다.</li></ul><h3 id=3-채번-테이블>3. 채번 테이블<a hidden class=anchor aria-hidden=true href=#3-채번-테이블>#</a></h3><ul><li>순번을 부여하기 위해 어플리케이션에서 채번 테이블이라는 것을 만들어 사용했었다.</li><li>구시대 유물이며 문제가 안생기기를 바라는 것이 최선(튜닝할 방법도 없다)</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://jaejin0me.github.io/tags/sql-%ED%8A%9C%EB%8B%9D/>sql 튜닝</a></li></ul></footer></article></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>