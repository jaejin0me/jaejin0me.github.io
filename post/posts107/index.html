<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>책뿌수기 - SQL 레벨업 6 | Jaejin's blog</title>
<meta name=keywords content="sql 튜닝"><meta name=description content="6. 결합(결합을 지배하는 자가 SQL을 지배한다)
ch 18. 기능적인 관점으로 구분하는 결합의 종류

크로스 결합
내부 결합
외부 결합
자기 결합
등가 결합/비등가 결합
자연 결합
위에서 3개는 배타적 결합이다.
컬럼) 자연 결합 구문

자연결합 = 내부 결합 + 등가 결합



1) 크로스 결합 - 모든 결합의 모체

데카르트 곱

(1) 실무에서 사용하지 않음

그런 결과가 필요없다
비용이 크다

(2) 실수로 사용한 크로스 결합

SELECT * FROM Employees, Departments;

2) 내부 결합 - 왜 ‘내부’라는 말을 사용할까?
(1) 내부 결합의 작용

크로스 결합 결과의 부분집합

(2) 내부 결합과 같은 기능을 하는 상관 서브쿼리

스칼라 서브쿼리 = 리턴값이 하나인쿼리(SELECT의 필요 조건)
상관 서브쿼리보다 결합이 우수하다

3) 외부 결합 - 왜 ‘외부’라는 말을 사용할까?
(1) 외부 결합의 작동

왼쪽/오른쪽/완전 외부 결합
키를 모두 가진 레이아웃의 리포트를 만들때 사용

4) 외부 결합과 내부 결합의 차이

외부 결합은 NULL을 생성한다

5) 자기 결합 - ‘자기’란 누구일까?
ch 19. 결합 알고리즘과 성능

Nested Loops
Hash
Sort Merge

1) Nested Loops

이중 반복
바깥 반복 테이블(구동 테이블, 외부 테이블) <-> 내부 테이블
접근하는 레코드 수 R(A) * R(B)이며 실행 시간은 레코드수에 비례한다.
구동 테이블을 작게 만드는 것이 중요하다

(1) 구동 테이블의 중요성

(내부 테이블의 결합키 필드에 인덱스가 존재) 구동 테이블을 작게
내부 테이블의 반복을 줄일 수 있음
이상적으로 구동 테이블의 레코드 한개에 내부 테이블의 레코드 한개가 대응하고, 해당 레코드를 내부 테이블의 인덱스로 사용해 찾을 수 있는 경우 레코드 레코드 수는 R(A) * 2

(2) Nested Loops 의 단점

결합키로 내부 테이블에 접근할 때 히트되는 레코드가 너무 많기 때문이다.
해결



역설적이게 구동 테이블을 큰것으로




Hash





2) Hash
(1) Hash의 작동

작은 테이블을 스캔해 결합키 Hash (워키 메모리 사용량을 줄이기 위해)
큰 테이블에 접근해 Hash하고 매칭

(2) Hash의 특징

결합 테이블로부터 해시 테이블을 만드므로 Nested Loops에 비해 메모리를 많이 사용
메모리가 부족하면 저장소 사용으로 지연
출력되는 해시값은 입력값의 순서를 알지 못하므로, 등치 결합에만 사용 가능

(3) Hash가 유용한 경우

Nested Loops에서 적절한 구동 테이블이 존재하지 않는 경우
적절한 구동 테이블이 있지만, 내부 테이블에서 히트되는 레코드 수가 많은 경우
Nested Loops의 내부 테이블에 인덱스가 존재하지 않는 경우

(4) 유의사항

OLTP에서는 사용하면 안된다.
풀스캔(해시를 위해)의 비용도 고려할 것

3) Sort Merge
(1) Sort Merge의 작동

결합키로 테이블들을 정렬하고, 일치하는 것 끼리 결합
대상 테이블을 모두 정렬해야하므로 메모리가 많이 사용
Hash와 달리 부등호를 사용해 결합 가능
테이블이 정렬되어 있다면 정렬을 생략 가능
테이블을 정렬하므로 테이블을 모두 스캔한 시점에 결합 완료

(2) Sort Meger가 유효한 경우

테이블 정렬을 생략 가능한 경우

4) 의도하지 않은 크로스 결합

삼각 결합 : 결합 조건이 A-B, A-C인 경우
B-C 사이에 크로스 결합이 일어날 수 있다. 옵티마이저가 B,C의 크기가 충분히 작다고 판단하는 경우

(1) 의도하지 않은 크로스 결합을 회피하는 방법

불필요한 결합 조건 추가

ch 20. 결합이 느리다면"><meta name=author content="Jaejin Jang"><link rel=canonical href=https://jaejin0me.github.io/post/posts107/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://jaejin0me.github.io/post/posts107/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8691946909799297" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T")}</script><meta property="og:title" content="책뿌수기 - SQL 레벨업 6"><meta property="og:description" content="6. 결합(결합을 지배하는 자가 SQL을 지배한다)
ch 18. 기능적인 관점으로 구분하는 결합의 종류

크로스 결합
내부 결합
외부 결합
자기 결합
등가 결합/비등가 결합
자연 결합
위에서 3개는 배타적 결합이다.
컬럼) 자연 결합 구문

자연결합 = 내부 결합 + 등가 결합



1) 크로스 결합 - 모든 결합의 모체

데카르트 곱

(1) 실무에서 사용하지 않음

그런 결과가 필요없다
비용이 크다

(2) 실수로 사용한 크로스 결합

SELECT * FROM Employees, Departments;

2) 내부 결합 - 왜 ‘내부’라는 말을 사용할까?
(1) 내부 결합의 작용

크로스 결합 결과의 부분집합

(2) 내부 결합과 같은 기능을 하는 상관 서브쿼리

스칼라 서브쿼리 = 리턴값이 하나인쿼리(SELECT의 필요 조건)
상관 서브쿼리보다 결합이 우수하다

3) 외부 결합 - 왜 ‘외부’라는 말을 사용할까?
(1) 외부 결합의 작동

왼쪽/오른쪽/완전 외부 결합
키를 모두 가진 레이아웃의 리포트를 만들때 사용

4) 외부 결합과 내부 결합의 차이

외부 결합은 NULL을 생성한다

5) 자기 결합 - ‘자기’란 누구일까?
ch 19. 결합 알고리즘과 성능

Nested Loops
Hash
Sort Merge

1) Nested Loops

이중 반복
바깥 반복 테이블(구동 테이블, 외부 테이블) <-> 내부 테이블
접근하는 레코드 수 R(A) * R(B)이며 실행 시간은 레코드수에 비례한다.
구동 테이블을 작게 만드는 것이 중요하다

(1) 구동 테이블의 중요성

(내부 테이블의 결합키 필드에 인덱스가 존재) 구동 테이블을 작게
내부 테이블의 반복을 줄일 수 있음
이상적으로 구동 테이블의 레코드 한개에 내부 테이블의 레코드 한개가 대응하고, 해당 레코드를 내부 테이블의 인덱스로 사용해 찾을 수 있는 경우 레코드 레코드 수는 R(A) * 2

(2) Nested Loops 의 단점

결합키로 내부 테이블에 접근할 때 히트되는 레코드가 너무 많기 때문이다.
해결



역설적이게 구동 테이블을 큰것으로




Hash





2) Hash
(1) Hash의 작동

작은 테이블을 스캔해 결합키 Hash (워키 메모리 사용량을 줄이기 위해)
큰 테이블에 접근해 Hash하고 매칭

(2) Hash의 특징

결합 테이블로부터 해시 테이블을 만드므로 Nested Loops에 비해 메모리를 많이 사용
메모리가 부족하면 저장소 사용으로 지연
출력되는 해시값은 입력값의 순서를 알지 못하므로, 등치 결합에만 사용 가능

(3) Hash가 유용한 경우

Nested Loops에서 적절한 구동 테이블이 존재하지 않는 경우
적절한 구동 테이블이 있지만, 내부 테이블에서 히트되는 레코드 수가 많은 경우
Nested Loops의 내부 테이블에 인덱스가 존재하지 않는 경우

(4) 유의사항

OLTP에서는 사용하면 안된다.
풀스캔(해시를 위해)의 비용도 고려할 것

3) Sort Merge
(1) Sort Merge의 작동

결합키로 테이블들을 정렬하고, 일치하는 것 끼리 결합
대상 테이블을 모두 정렬해야하므로 메모리가 많이 사용
Hash와 달리 부등호를 사용해 결합 가능
테이블이 정렬되어 있다면 정렬을 생략 가능
테이블을 정렬하므로 테이블을 모두 스캔한 시점에 결합 완료

(2) Sort Meger가 유효한 경우

테이블 정렬을 생략 가능한 경우

4) 의도하지 않은 크로스 결합

삼각 결합 : 결합 조건이 A-B, A-C인 경우
B-C 사이에 크로스 결합이 일어날 수 있다. 옵티마이저가 B,C의 크기가 충분히 작다고 판단하는 경우

(1) 의도하지 않은 크로스 결합을 회피하는 방법

불필요한 결합 조건 추가

ch 20. 결합이 느리다면"><meta property="og:type" content="article"><meta property="og:url" content="https://jaejin0me.github.io/post/posts107/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-01-31T22:20:56+09:00"><meta property="article:modified_time" content="2019-01-31T22:20:56+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="책뿌수기 - SQL 레벨업 6"><meta name=twitter:description content="6. 결합(결합을 지배하는 자가 SQL을 지배한다)
ch 18. 기능적인 관점으로 구분하는 결합의 종류

크로스 결합
내부 결합
외부 결합
자기 결합
등가 결합/비등가 결합
자연 결합
위에서 3개는 배타적 결합이다.
컬럼) 자연 결합 구문

자연결합 = 내부 결합 + 등가 결합



1) 크로스 결합 - 모든 결합의 모체

데카르트 곱

(1) 실무에서 사용하지 않음

그런 결과가 필요없다
비용이 크다

(2) 실수로 사용한 크로스 결합

SELECT * FROM Employees, Departments;

2) 내부 결합 - 왜 ‘내부’라는 말을 사용할까?
(1) 내부 결합의 작용

크로스 결합 결과의 부분집합

(2) 내부 결합과 같은 기능을 하는 상관 서브쿼리

스칼라 서브쿼리 = 리턴값이 하나인쿼리(SELECT의 필요 조건)
상관 서브쿼리보다 결합이 우수하다

3) 외부 결합 - 왜 ‘외부’라는 말을 사용할까?
(1) 외부 결합의 작동

왼쪽/오른쪽/완전 외부 결합
키를 모두 가진 레이아웃의 리포트를 만들때 사용

4) 외부 결합과 내부 결합의 차이

외부 결합은 NULL을 생성한다

5) 자기 결합 - ‘자기’란 누구일까?
ch 19. 결합 알고리즘과 성능

Nested Loops
Hash
Sort Merge

1) Nested Loops

이중 반복
바깥 반복 테이블(구동 테이블, 외부 테이블) <-> 내부 테이블
접근하는 레코드 수 R(A) * R(B)이며 실행 시간은 레코드수에 비례한다.
구동 테이블을 작게 만드는 것이 중요하다

(1) 구동 테이블의 중요성

(내부 테이블의 결합키 필드에 인덱스가 존재) 구동 테이블을 작게
내부 테이블의 반복을 줄일 수 있음
이상적으로 구동 테이블의 레코드 한개에 내부 테이블의 레코드 한개가 대응하고, 해당 레코드를 내부 테이블의 인덱스로 사용해 찾을 수 있는 경우 레코드 레코드 수는 R(A) * 2

(2) Nested Loops 의 단점

결합키로 내부 테이블에 접근할 때 히트되는 레코드가 너무 많기 때문이다.
해결



역설적이게 구동 테이블을 큰것으로




Hash





2) Hash
(1) Hash의 작동

작은 테이블을 스캔해 결합키 Hash (워키 메모리 사용량을 줄이기 위해)
큰 테이블에 접근해 Hash하고 매칭

(2) Hash의 특징

결합 테이블로부터 해시 테이블을 만드므로 Nested Loops에 비해 메모리를 많이 사용
메모리가 부족하면 저장소 사용으로 지연
출력되는 해시값은 입력값의 순서를 알지 못하므로, 등치 결합에만 사용 가능

(3) Hash가 유용한 경우

Nested Loops에서 적절한 구동 테이블이 존재하지 않는 경우
적절한 구동 테이블이 있지만, 내부 테이블에서 히트되는 레코드 수가 많은 경우
Nested Loops의 내부 테이블에 인덱스가 존재하지 않는 경우

(4) 유의사항

OLTP에서는 사용하면 안된다.
풀스캔(해시를 위해)의 비용도 고려할 것

3) Sort Merge
(1) Sort Merge의 작동

결합키로 테이블들을 정렬하고, 일치하는 것 끼리 결합
대상 테이블을 모두 정렬해야하므로 메모리가 많이 사용
Hash와 달리 부등호를 사용해 결합 가능
테이블이 정렬되어 있다면 정렬을 생략 가능
테이블을 정렬하므로 테이블을 모두 스캔한 시점에 결합 완료

(2) Sort Meger가 유효한 경우

테이블 정렬을 생략 가능한 경우

4) 의도하지 않은 크로스 결합

삼각 결합 : 결합 조건이 A-B, A-C인 경우
B-C 사이에 크로스 결합이 일어날 수 있다. 옵티마이저가 B,C의 크기가 충분히 작다고 판단하는 경우

(1) 의도하지 않은 크로스 결합을 회피하는 방법

불필요한 결합 조건 추가

ch 20. 결합이 느리다면"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jaejin0me.github.io/post/"},{"@type":"ListItem","position":2,"name":"책뿌수기 - SQL 레벨업 6","item":"https://jaejin0me.github.io/post/posts107/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"책뿌수기 - SQL 레벨업 6","name":"책뿌수기 - SQL 레벨업 6","description":"6. 결합(결합을 지배하는 자가 SQL을 지배한다) ch 18. 기능적인 관점으로 구분하는 결합의 종류 크로스 결합 내부 결합 외부 결합 자기 결합 등가 결합/비등가 결합 자연 결합 위에서 3개는 배타적 결합이다. 컬럼) 자연 결합 구문 자연결합 = 내부 결합 + 등가 결합 1) 크로스 결합 - 모든 결합의 모체 데카르트 곱 (1) 실무에서 사용하지 않음 그런 결과가 필요없다 비용이 크다 (2) 실수로 사용한 크로스 결합 SELECT * FROM Employees, Departments; 2) 내부 결합 - 왜 ‘내부’라는 말을 사용할까? (1) 내부 결합의 작용 크로스 결합 결과의 부분집합 (2) 내부 결합과 같은 기능을 하는 상관 서브쿼리 스칼라 서브쿼리 = 리턴값이 하나인쿼리(SELECT의 필요 조건) 상관 서브쿼리보다 결합이 우수하다 3) 외부 결합 - 왜 ‘외부’라는 말을 사용할까? (1) 외부 결합의 작동 왼쪽/오른쪽/완전 외부 결합 키를 모두 가진 레이아웃의 리포트를 만들때 사용 4) 외부 결합과 내부 결합의 차이 외부 결합은 NULL을 생성한다 5) 자기 결합 - ‘자기’란 누구일까? ch 19. 결합 알고리즘과 성능 Nested Loops Hash Sort Merge 1) Nested Loops 이중 반복 바깥 반복 테이블(구동 테이블, 외부 테이블) \u0026lt;-\u0026gt; 내부 테이블 접근하는 레코드 수 R(A) * R(B)이며 실행 시간은 레코드수에 비례한다. 구동 테이블을 작게 만드는 것이 중요하다 (1) 구동 테이블의 중요성 (내부 테이블의 결합키 필드에 인덱스가 존재) 구동 테이블을 작게 내부 테이블의 반복을 줄일 수 있음 이상적으로 구동 테이블의 레코드 한개에 내부 테이블의 레코드 한개가 대응하고, 해당 레코드를 내부 테이블의 인덱스로 사용해 찾을 수 있는 경우 레코드 레코드 수는 R(A) * 2 (2) Nested Loops 의 단점 결합키로 내부 테이블에 접근할 때 히트되는 레코드가 너무 많기 때문이다. 해결 역설적이게 구동 테이블을 큰것으로 Hash 2) Hash (1) Hash의 작동 작은 테이블을 스캔해 결합키 Hash (워키 메모리 사용량을 줄이기 위해) 큰 테이블에 접근해 Hash하고 매칭 (2) Hash의 특징 결합 테이블로부터 해시 테이블을 만드므로 Nested Loops에 비해 메모리를 많이 사용 메모리가 부족하면 저장소 사용으로 지연 출력되는 해시값은 입력값의 순서를 알지 못하므로, 등치 결합에만 사용 가능 (3) Hash가 유용한 경우 Nested Loops에서 적절한 구동 테이블이 존재하지 않는 경우 적절한 구동 테이블이 있지만, 내부 테이블에서 히트되는 레코드 수가 많은 경우 Nested Loops의 내부 테이블에 인덱스가 존재하지 않는 경우 (4) 유의사항 OLTP에서는 사용하면 안된다. 풀스캔(해시를 위해)의 비용도 고려할 것 3) Sort Merge (1) Sort Merge의 작동 결합키로 테이블들을 정렬하고, 일치하는 것 끼리 결합 대상 테이블을 모두 정렬해야하므로 메모리가 많이 사용 Hash와 달리 부등호를 사용해 결합 가능 테이블이 정렬되어 있다면 정렬을 생략 가능 테이블을 정렬하므로 테이블을 모두 스캔한 시점에 결합 완료 (2) Sort Meger가 유효한 경우 테이블 정렬을 생략 가능한 경우 4) 의도하지 않은 크로스 결합 삼각 결합 : 결합 조건이 A-B, A-C인 경우 B-C 사이에 크로스 결합이 일어날 수 있다. 옵티마이저가 B,C의 크기가 충분히 작다고 판단하는 경우 (1) 의도하지 않은 크로스 결합을 회피하는 방법 불필요한 결합 조건 추가 ch 20. 결합이 느리다면","keywords":["sql 튜닝"],"articleBody":"6. 결합(결합을 지배하는 자가 SQL을 지배한다) ch 18. 기능적인 관점으로 구분하는 결합의 종류 크로스 결합 내부 결합 외부 결합 자기 결합 등가 결합/비등가 결합 자연 결합 위에서 3개는 배타적 결합이다. 컬럼) 자연 결합 구문 자연결합 = 내부 결합 + 등가 결합 1) 크로스 결합 - 모든 결합의 모체 데카르트 곱 (1) 실무에서 사용하지 않음 그런 결과가 필요없다 비용이 크다 (2) 실수로 사용한 크로스 결합 SELECT * FROM Employees, Departments; 2) 내부 결합 - 왜 ‘내부’라는 말을 사용할까? (1) 내부 결합의 작용 크로스 결합 결과의 부분집합 (2) 내부 결합과 같은 기능을 하는 상관 서브쿼리 스칼라 서브쿼리 = 리턴값이 하나인쿼리(SELECT의 필요 조건) 상관 서브쿼리보다 결합이 우수하다 3) 외부 결합 - 왜 ‘외부’라는 말을 사용할까? (1) 외부 결합의 작동 왼쪽/오른쪽/완전 외부 결합 키를 모두 가진 레이아웃의 리포트를 만들때 사용 4) 외부 결합과 내부 결합의 차이 외부 결합은 NULL을 생성한다 5) 자기 결합 - ‘자기’란 누구일까? ch 19. 결합 알고리즘과 성능 Nested Loops Hash Sort Merge 1) Nested Loops 이중 반복 바깥 반복 테이블(구동 테이블, 외부 테이블) \u003c-\u003e 내부 테이블 접근하는 레코드 수 R(A) * R(B)이며 실행 시간은 레코드수에 비례한다. 구동 테이블을 작게 만드는 것이 중요하다 (1) 구동 테이블의 중요성 (내부 테이블의 결합키 필드에 인덱스가 존재) 구동 테이블을 작게 내부 테이블의 반복을 줄일 수 있음 이상적으로 구동 테이블의 레코드 한개에 내부 테이블의 레코드 한개가 대응하고, 해당 레코드를 내부 테이블의 인덱스로 사용해 찾을 수 있는 경우 레코드 레코드 수는 R(A) * 2 (2) Nested Loops 의 단점 결합키로 내부 테이블에 접근할 때 히트되는 레코드가 너무 많기 때문이다. 해결 역설적이게 구동 테이블을 큰것으로 Hash 2) Hash (1) Hash의 작동 작은 테이블을 스캔해 결합키 Hash (워키 메모리 사용량을 줄이기 위해) 큰 테이블에 접근해 Hash하고 매칭 (2) Hash의 특징 결합 테이블로부터 해시 테이블을 만드므로 Nested Loops에 비해 메모리를 많이 사용 메모리가 부족하면 저장소 사용으로 지연 출력되는 해시값은 입력값의 순서를 알지 못하므로, 등치 결합에만 사용 가능 (3) Hash가 유용한 경우 Nested Loops에서 적절한 구동 테이블이 존재하지 않는 경우 적절한 구동 테이블이 있지만, 내부 테이블에서 히트되는 레코드 수가 많은 경우 Nested Loops의 내부 테이블에 인덱스가 존재하지 않는 경우 (4) 유의사항 OLTP에서는 사용하면 안된다. 풀스캔(해시를 위해)의 비용도 고려할 것 3) Sort Merge (1) Sort Merge의 작동 결합키로 테이블들을 정렬하고, 일치하는 것 끼리 결합 대상 테이블을 모두 정렬해야하므로 메모리가 많이 사용 Hash와 달리 부등호를 사용해 결합 가능 테이블이 정렬되어 있다면 정렬을 생략 가능 테이블을 정렬하므로 테이블을 모두 스캔한 시점에 결합 완료 (2) Sort Meger가 유효한 경우 테이블 정렬을 생략 가능한 경우 4) 의도하지 않은 크로스 결합 삼각 결합 : 결합 조건이 A-B, A-C인 경우 B-C 사이에 크로스 결합이 일어날 수 있다. 옵티마이저가 B,C의 크기가 충분히 작다고 판단하는 경우 (1) 의도하지 않은 크로스 결합을 회피하는 방법 불필요한 결합 조건 추가 ch 20. 결합이 느리다면 ","wordCount":"1187","inLanguage":"ko","datePublished":"2019-01-31T22:20:56+09:00","dateModified":"2019-01-31T22:20:56+09:00","author":{"@type":"Person","name":"Jaejin Jang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jaejin0me.github.io/post/posts107/"},"publisher":{"@type":"Organization","name":"Jaejin's blog","logo":{"@type":"ImageObject","url":"https://jaejin0me.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io/ accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">책뿌수기 - SQL 레벨업 6</h1><div class=post-meta><span title='2019-01-31 22:20:56 +0900 +0900'>1월 31, 2019</span>&nbsp;·&nbsp;Jaejin Jang</div></header><div class=post-content><h1 id=6-결합결합을-지배하는-자가-sql을-지배한다>6. 결합(결합을 지배하는 자가 SQL을 지배한다)<a hidden class=anchor aria-hidden=true href=#6-결합결합을-지배하는-자가-sql을-지배한다>#</a></h1><h2 id=ch-18-기능적인-관점으로-구분하는-결합의-종류>ch 18. 기능적인 관점으로 구분하는 결합의 종류<a hidden class=anchor aria-hidden=true href=#ch-18-기능적인-관점으로-구분하는-결합의-종류>#</a></h2><ul><li>크로스 결합</li><li>내부 결합</li><li>외부 결합</li><li>자기 결합</li><li>등가 결합/비등가 결합</li><li>자연 결합</li><li>위에서 3개는 배타적 결합이다.</li><li>컬럼) 자연 결합 구문<ul><li>자연결합 = 내부 결합 + 등가 결합</li></ul></li></ul><h3 id=1-크로스-결합---모든-결합의-모체>1) 크로스 결합 - 모든 결합의 모체<a hidden class=anchor aria-hidden=true href=#1-크로스-결합---모든-결합의-모체>#</a></h3><ul><li>데카르트 곱</li></ul><h4 id=1-실무에서-사용하지-않음>(1) 실무에서 사용하지 않음<a hidden class=anchor aria-hidden=true href=#1-실무에서-사용하지-않음>#</a></h4><ul><li>그런 결과가 필요없다</li><li>비용이 크다</li></ul><h4 id=2-실수로-사용한-크로스-결합>(2) 실수로 사용한 크로스 결합<a hidden class=anchor aria-hidden=true href=#2-실수로-사용한-크로스-결합>#</a></h4><ul><li>SELECT * FROM Employees, Departments;</li></ul><h3 id=2-내부-결합---왜-내부라는-말을-사용할까>2) 내부 결합 - 왜 ‘내부’라는 말을 사용할까?<a hidden class=anchor aria-hidden=true href=#2-내부-결합---왜-내부라는-말을-사용할까>#</a></h3><h4 id=1-내부-결합의-작용><a href=https://jaejin0me.github.io/post/db25/#1-%EB%82%B4%EB%B6%80-%EA%B2%B0%ED%95%A9%EC%9D%98-%EC%9E%91%EC%9A%A9 title="(1) 내부 결합의 작용"></a>(1) 내부 결합의 작용<a hidden class=anchor aria-hidden=true href=#1-내부-결합의-작용>#</a></h4><ul><li>크로스 결합 결과의 부분집합</li></ul><h4 id=2-내부-결합과-같은-기능을-하는-상관-서브쿼리>(2) 내부 결합과 같은 기능을 하는 상관 서브쿼리<a hidden class=anchor aria-hidden=true href=#2-내부-결합과-같은-기능을-하는-상관-서브쿼리>#</a></h4><ul><li>스칼라 서브쿼리 = 리턴값이 하나인쿼리(SELECT의 필요 조건)</li><li>상관 서브쿼리보다 결합이 우수하다</li></ul><h3 id=3-외부-결합---왜-외부라는-말을-사용할까>3) 외부 결합 - 왜 ‘외부’라는 말을 사용할까?<a hidden class=anchor aria-hidden=true href=#3-외부-결합---왜-외부라는-말을-사용할까>#</a></h3><h4 id=1-외부-결합의-작동>(1) 외부 결합의 작동<a hidden class=anchor aria-hidden=true href=#1-외부-결합의-작동>#</a></h4><ul><li>왼쪽/오른쪽/완전 외부 결합</li><li>키를 모두 가진 레이아웃의 리포트를 만들때 사용</li></ul><h3 id=4-외부-결합과-내부-결합의-차이>4) 외부 결합과 내부 결합의 차이<a hidden class=anchor aria-hidden=true href=#4-외부-결합과-내부-결합의-차이>#</a></h3><ul><li>외부 결합은 NULL을 생성한다</li></ul><h3 id=5-자기-결합---자기란-누구일까>5) 자기 결합 - ‘자기’란 누구일까?<a hidden class=anchor aria-hidden=true href=#5-자기-결합---자기란-누구일까>#</a></h3><h2 id=ch-19-결합-알고리즘과-성능>ch 19. 결합 알고리즘과 성능<a hidden class=anchor aria-hidden=true href=#ch-19-결합-알고리즘과-성능>#</a></h2><ul><li>Nested Loops</li><li>Hash</li><li>Sort Merge</li></ul><h3 id=1-nested-loops>1) Nested Loops<a hidden class=anchor aria-hidden=true href=#1-nested-loops>#</a></h3><ul><li>이중 반복</li><li>바깥 반복 테이블(구동 테이블, 외부 테이블) &lt;-> 내부 테이블</li><li>접근하는 레코드 수 R(A) * R(B)이며 실행 시간은 레코드수에 비례한다.</li><li>구동 테이블을 작게 만드는 것이 중요하다</li></ul><h4 id=1-구동-테이블의-중요성>(1) 구동 테이블의 중요성<a hidden class=anchor aria-hidden=true href=#1-구동-테이블의-중요성>#</a></h4><ul><li>(내부 테이블의 결합키 필드에 인덱스가 존재) 구동 테이블을 작게</li><li>내부 테이블의 반복을 줄일 수 있음</li><li>이상적으로 구동 테이블의 레코드 한개에 내부 테이블의 레코드 한개가 대응하고, 해당 레코드를 내부 테이블의 인덱스로 사용해 찾을 수 있는 경우 레코드 레코드 수는 R(A) * 2</li></ul><h4 id=2-nested-loops-의-단점>(2) Nested Loops 의 단점<a hidden class=anchor aria-hidden=true href=#2-nested-loops-의-단점>#</a></h4><ul><li>결합키로 내부 테이블에 접근할 때 히트되는 레코드가 너무 많기 때문이다.</li><li>해결<ul><li><ol><li>역설적이게 구동 테이블을 큰것으로</li></ol></li><li><ol start=2><li>Hash</li></ol></li></ul></li></ul><h3 id=2-hash>2) Hash<a hidden class=anchor aria-hidden=true href=#2-hash>#</a></h3><h4 id=1-hash의-작동>(1) Hash의 작동<a hidden class=anchor aria-hidden=true href=#1-hash의-작동>#</a></h4><ul><li>작은 테이블을 스캔해 결합키 Hash (워키 메모리 사용량을 줄이기 위해)</li><li>큰 테이블에 접근해 Hash하고 매칭</li></ul><h4 id=2-hash의-특징>(2) Hash의 특징<a hidden class=anchor aria-hidden=true href=#2-hash의-특징>#</a></h4><ul><li>결합 테이블로부터 해시 테이블을 만드므로 Nested Loops에 비해 메모리를 많이 사용</li><li>메모리가 부족하면 저장소 사용으로 지연</li><li>출력되는 해시값은 입력값의 순서를 알지 못하므로, 등치 결합에만 사용 가능</li></ul><h4 id=3-hash가-유용한-경우>(3) Hash가 유용한 경우<a hidden class=anchor aria-hidden=true href=#3-hash가-유용한-경우>#</a></h4><ul><li>Nested Loops에서 적절한 구동 테이블이 존재하지 않는 경우</li><li>적절한 구동 테이블이 있지만, 내부 테이블에서 히트되는 레코드 수가 많은 경우</li><li>Nested Loops의 내부 테이블에 인덱스가 존재하지 않는 경우</li></ul><h4 id=4-유의사항>(4) 유의사항<a hidden class=anchor aria-hidden=true href=#4-유의사항>#</a></h4><ul><li>OLTP에서는 사용하면 안된다.</li><li>풀스캔(해시를 위해)의 비용도 고려할 것</li></ul><h3 id=3-sort-merge>3) Sort Merge<a hidden class=anchor aria-hidden=true href=#3-sort-merge>#</a></h3><h4 id=1-sort-merge의-작동>(1) Sort Merge의 작동<a hidden class=anchor aria-hidden=true href=#1-sort-merge의-작동>#</a></h4><ul><li>결합키로 테이블들을 정렬하고, 일치하는 것 끼리 결합</li><li>대상 테이블을 모두 정렬해야하므로 메모리가 많이 사용</li><li>Hash와 달리 부등호를 사용해 결합 가능</li><li>테이블이 정렬되어 있다면 정렬을 생략 가능</li><li>테이블을 정렬하므로 테이블을 모두 스캔한 시점에 결합 완료</li></ul><h4 id=2-sort-meger가-유효한-경우>(2) Sort Meger가 유효한 경우<a hidden class=anchor aria-hidden=true href=#2-sort-meger가-유효한-경우>#</a></h4><ul><li>테이블 정렬을 생략 가능한 경우</li></ul><h3 id=4-의도하지-않은-크로스-결합>4) 의도하지 않은 크로스 결합<a hidden class=anchor aria-hidden=true href=#4-의도하지-않은-크로스-결합>#</a></h3><ul><li>삼각 결합 : 결합 조건이 A-B, A-C인 경우</li><li>B-C 사이에 크로스 결합이 일어날 수 있다. 옵티마이저가 B,C의 크기가 충분히 작다고 판단하는 경우</li></ul><h4 id=1-의도하지-않은-크로스-결합을-회피하는-방법>(1) 의도하지 않은 크로스 결합을 회피하는 방법<a hidden class=anchor aria-hidden=true href=#1-의도하지-않은-크로스-결합을-회피하는-방법>#</a></h4><ul><li>불필요한 결합 조건 추가</li></ul><h2 id=ch-20-결합이-느리다면>ch 20. 결합이 느리다면<a hidden class=anchor aria-hidden=true href=#ch-20-결합이-느리다면>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://jaejin0me.github.io/tags/sql-%ED%8A%9C%EB%8B%9D/>Sql 튜닝</a></li></ul></footer><script src=https://utteranc.es/client.js repo=jaejin0me/blog_comment issue-term=title label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>