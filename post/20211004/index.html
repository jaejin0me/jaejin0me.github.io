<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>몰입! 자바스크립트 - 08 자바스크립트의 언어적 개념 | Jaejin's blog</title>
<meta name=keywords content="javascript"><meta name=description content="이력 2021.10.04 포스팅 2021.11.25 사소한 수정 2021.11.26 사소한 수정 모든 내용을 상세히 담으려 하지 않았습니다. 제가 모르는 부분이나, &ldquo;이런 것도 있었어?&rdquo; 하"><meta name=author content="Jaejin Jang"><link rel=canonical href=https://jaejin0me.github.io/post/20211004/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://jaejin0me.github.io/post/20211004/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T",{anonymize_ip:!0})}</script><meta property="og:title" content="몰입! 자바스크립트 - 08 자바스크립트의 언어적 개념"><meta property="og:description" content="이력 2021.10.04 포스팅 2021.11.25 사소한 수정 2021.11.26 사소한 수정 모든 내용을 상세히 담으려 하지 않았습니다. 제가 모르는 부분이나, &ldquo;이런 것도 있었어?&rdquo; 하"><meta property="og:type" content="article"><meta property="og:url" content="https://jaejin0me.github.io/post/20211004/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-10-04T17:12:52+09:00"><meta property="article:modified_time" content="2021-10-04T17:12:52+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="몰입! 자바스크립트 - 08 자바스크립트의 언어적 개념"><meta name=twitter:description content="이력 2021.10.04 포스팅 2021.11.25 사소한 수정 2021.11.26 사소한 수정 모든 내용을 상세히 담으려 하지 않았습니다. 제가 모르는 부분이나, &ldquo;이런 것도 있었어?&rdquo; 하"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jaejin0me.github.io/post/"},{"@type":"ListItem","position":2,"name":"몰입! 자바스크립트 - 08 자바스크립트의 언어적 개념","item":"https://jaejin0me.github.io/post/20211004/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"몰입! 자바스크립트 - 08 자바스크립트의 언어적 개념","name":"몰입! 자바스크립트 - 08 자바스크립트의 언어적 개념","description":"이력 2021.10.04 포스팅 2021.11.25 사소한 수정 2021.11.26 사소한 수정 모든 내용을 상세히 담으려 하지 않았습니다. 제가 모르는 부분이나, \u0026ldquo;이런 것도 있었어?\u0026rdquo; 하","keywords":["javascript"],"articleBody":"이력\n2021.10.04 포스팅 2021.11.25 사소한 수정 2021.11.26 사소한 수정 모든 내용을 상세히 담으려 하지 않았습니다.\n제가 모르는 부분이나, “이런 것도 있었어?” 하는 부분, 중요하다고 생각되는 부분,\n다시 한번 되새기고 싶은 부분만 기록했습니다.\n읽어주셔서 감사합니다.\n8.1 자바스크립트 기준과 범위 js는 OOP 언어이다. js는 스크립트 언어이다. 스크립트 언어 환경에서 객체 지향 프로그램을 구현하며, 객체지향 환경에서 스크립트 언어로 프로그램을 구현한다. OOP를 지원하는 방법은 언어마다 다르다. 사전 컴파일 언어와 스크립트 언어는 환경이 다르므로 구현 방법이 다르다. js도 마찬가지다. 8.2 빌트인 브라우저가 html 파일의 처음부터 한줄씩 해석하다가, script 태그를 만나면 js 실행환경을 만든다. 실행환경을 만드는 과정을 렌더링(Rendering) 이라고 한다. 렌더링을 완료하면 코드를 컴파일하고 실행한다. 렌더링 과정에서는 “오브젝트 생성, 값 초기화, 연산자 설정\"을 한다. 렌더링 단계에서 만드는 것을 총칭해 “빌트인\"이라고 하며, 크게 연산자, 데이터 타입, 오브젝트로 나눈다. 빌트인은 프로그램이 실행되기 전에 생성되므로 프로그램에서 사용할 수 있다. 빌트인에서 자바스크립트의 특징을 나타낸 것이 빌트인 오브젝트이다. 빌트인 연산자 ++, –, +, -, ~, !, *, /, %, ==, !=, ===, !==, *=, /=, %= 등 빌트인 데이터 타입 Undefined, Null, Boolean, Number, String 빌트인 오브젝트 Global, Object, Function, Array, String, Boolean, Number Math, Date, RegExp, JSON Error 처리용(Error, EvalError, RangeError … ) 8.3 빌트인 오브젝트 Global 오브젝트 전체를 통해서 하나만 존재한다. 따로 선언된 script 태그에서도 글로벌 오브젝트를 공유한다. Object 오브젝트 오브젝트를 생성, 제어하며 대부부분의 빌트인 오브젝트에 상속된다. 소스에서 중괄호 {} 를 작성하면 새로운 오브젝트를 생성해 반환한다. Function 오브젝트 함수 오브젝트를 생성 제어 한다. function f() { } 를 작성하면 새로운 Function 오브젝트를 생성해 반환한다. js는 Function 오브젝트로 시작해, Function 오브젝트로 끝난다고 해도 과언이 아니다. Array 오브젝트 배열을 생성, 제어 한다. 대괄호 []를 작성하면 Array 오브젝트를 생성해 반환한다. String 오브젝트 문자열을 제어한다. Number 오브젝트 Math 오브젝트 Date 오브젝트 RegExp 오브젝트 JSON 오브젝트 8.4 오브젝트 인식 메소드로 데이터를 연결하려면 아래와 같은 순서로 처리하게 된다. 1 2 3 4 5 6 1. 연결 기능을 가진 메소드를 선택합니다. 2. 메소드가 속한 오브젝트를 선택합니다. 3. 파라미터로 넘겨 줄 데이터를 준비합니다. 4. 데이터 타입에 따라 오브젝트를 생성합니다. 5. 오브젝트 메소드 형태로 호출하면서 연결하려는 값을 파라미터로 넘겨줍니다. 6. 메소드가 실행되며 메소드에서 값을 반환합니다. 위의 흐름을 전형적인 객체 지향 형태로 코딩하면 아래와 같다. 해당 오브젝트를 만들고, 그 오브젝트의 메소드를 호출하게 된다. 1 2 3 4 5 6 7 var obj = new String(); var result = obj.concat('sports', 'soccer', 11); js.log(result); obj = new Array(); result = obj.concat('sports', 'soccer', 11); js.log(result) 자바스크립트 형태는 아래와 같이, 오브젝트를 생성하지 않고도 메소드를 호출해서 사용할 수 있다. 1 2 3 4 5 var result = 'sports'.concat('soccer'), 11); js. log(result); result = ['sports'].concat('soccer', 11); js.log(result); 메소드 호출시, 오브젝트.메소드(), 에서 오브젝트의 위치에 작성항 데이터 타입에 의해 오브젝트가 결정된다. 전형적인 객체지향 프로그램과 형태가 다르다. 데이터 타입에 의해 오브젝트가 속한 메소드가 호출되는 메커니즘을 뒷받침하는 것이 빌트인 타입, 빌트인 오브젝트입니다. 8.5 prototype 오브젝트 prototype을 사용하여 오브젝트에 메소드를 연결한다. 이 외에도 다른 오브젝트를 상속받아 연결하거나 prototype에 연결된 프로퍼티를 공유할 때 사용한다. 8.6 new 연산자 인스턴스를 생성해 반환한다.\n구분 타입 데이터(값) constructor Function 생성자 파라미터 any 값(옵션) 반환 Object 생성한 오브젝트 파라미터로 넘겨줄 값이 없으면 new String;과 같이 소괄호를 작성하지 않아도 되지만, 소괄호 작성은 코등의 관례이다.\n일부 빌트인 오브젝트는 new 연산자를 사용하지 않고 생성자만 작성해도 오브젝트를 생성해 반환한다.(Function, Number …)\nnew 연산자로 인스턴스를 생성하면 원본 오브젝트의 prototype에 연결된 메소드를 인스턴스에서 공유(참조, Reference) 한다. 따라서 인스턴스의 메소드를 호출하면 원본 오브젝트의 prototype에 연결된 메소드가 호출된다.\nfallback 메소드: 엔진 버전에 따라 지원하지 않는 메소드가 있다. 개발자가 이 메소드를 만들어 빌트인 오브젝트의 prototype에 연결해 사용할 수 있다. 이 메소드를 fallback 메소드라고 한다,\n8.7 constructor 생성자를 참조한다.(Global, Math, JSON 오브젝트를 생성자가 없어 인스턴스 생성이 불가) 8.8 instanceof 연산자 ","wordCount":"1757","inLanguage":"ko","datePublished":"2021-10-04T17:12:52+09:00","dateModified":"2021-10-04T17:12:52+09:00","author":{"@type":"Person","name":"Jaejin Jang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jaejin0me.github.io/post/20211004/"},"publisher":{"@type":"Organization","name":"Jaejin's blog","logo":{"@type":"ImageObject","url":"https://jaejin0me.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io/ accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>몰입! 자바스크립트 - 08 자바스크립트의 언어적 개념</h1><div class=post-meta>&lt;span title='2021-10-04 17:12:52 +0900 +0900'>10월 4, 2021&lt;/span>&amp;nbsp;·&amp;nbsp;Jaejin Jang</div></header><div class=post-content><p>이력</p><ul><li>2021.10.04 포스팅</li><li>2021.11.25 사소한 수정</li><li>2021.11.26 사소한 수정</li></ul><p><em>모든 내용을 상세히 담으려 하지 않았습니다.<br>제가 모르는 부분이나, &ldquo;이런 것도 있었어?&rdquo; 하는 부분, 중요하다고 생각되는 부분,<br>다시 한번 되새기고 싶은 부분만 기록했습니다.<br>읽어주셔서 감사합니다.</em></p><h2 id=81-자바스크립트-기준과-범위>8.1 자바스크립트 기준과 범위<a hidden class=anchor aria-hidden=true href=#81-자바스크립트-기준과-범위>#</a></h2><ul><li>js는 OOP 언어이다.</li><li>js는 스크립트 언어이다.</li><li>스크립트 언어 환경에서 객체 지향 프로그램을 구현하며, 객체지향 환경에서 스크립트 언어로 프로그램을 구현한다.</li><li>OOP를 지원하는 방법은 언어마다 다르다. 사전 컴파일 언어와 스크립트 언어는 환경이 다르므로 구현 방법이 다르다. js도 마찬가지다.</li></ul><h2 id=82-빌트인>8.2 빌트인<a hidden class=anchor aria-hidden=true href=#82-빌트인>#</a></h2><ul><li>브라우저가 html 파일의 처음부터 한줄씩 해석하다가, script 태그를 만나면 js 실행환경을 만든다. 실행환경을 만드는 과정을 렌더링(Rendering) 이라고 한다.</li><li>렌더링을 완료하면 코드를 컴파일하고 실행한다.</li><li>렌더링 과정에서는 &ldquo;오브젝트 생성, 값 초기화, 연산자 설정"을 한다.</li><li>렌더링 단계에서 만드는 것을 총칭해 &ldquo;빌트인"이라고 하며, 크게 연산자, 데이터 타입, 오브젝트로 나눈다.</li><li>빌트인은 프로그램이 실행되기 전에 생성되므로 프로그램에서 사용할 수 있다.</li><li>빌트인에서 자바스크립트의 특징을 나타낸 것이 빌트인 오브젝트이다.</li><li>빌트인 연산자<ul><li>++, &ndash;, +, -, ~, !, *, /, %, ==, !=, ===, !==, *=, /=, %= 등</li></ul></li><li>빌트인 데이터 타입<ul><li>Undefined, Null, Boolean, Number, String</li></ul></li><li>빌트인 오브젝트<ul><li>Global, Object, Function, Array, String, Boolean, Number</li><li>Math, Date, RegExp, JSON</li><li>Error 처리용(Error, EvalError, RangeError &mldr; )</li></ul></li></ul><h2 id=83-빌트인-오브젝트>8.3 빌트인 오브젝트<a hidden class=anchor aria-hidden=true href=#83-빌트인-오브젝트>#</a></h2><ul><li>Global 오브젝트<ul><li>전체를 통해서 하나만 존재한다. 따로 선언된 script 태그에서도 글로벌 오브젝트를 공유한다.</li></ul></li><li>Object 오브젝트<ul><li>오브젝트를 생성, 제어하며 대부부분의 빌트인 오브젝트에 상속된다.</li><li>소스에서 중괄호 {} 를 작성하면 새로운 오브젝트를 생성해 반환한다.</li></ul></li><li>Function 오브젝트<ul><li>함수 오브젝트를 생성 제어 한다.</li><li>function f() { } 를 작성하면 새로운 Function 오브젝트를 생성해 반환한다.</li><li>js는 Function 오브젝트로 시작해, Function 오브젝트로 끝난다고 해도 과언이 아니다.</li></ul></li><li>Array 오브젝트<ul><li>배열을 생성, 제어 한다.</li><li>대괄호 []를 작성하면 Array 오브젝트를 생성해 반환한다.</li></ul></li><li>String 오브젝트<ul><li>문자열을 제어한다.</li></ul></li><li>Number 오브젝트</li><li>Math 오브젝트</li><li>Date 오브젝트</li><li>RegExp 오브젝트</li><li>JSON 오브젝트</li></ul><h2 id=84-오브젝트-인식>8.4 오브젝트 인식<a hidden class=anchor aria-hidden=true href=#84-오브젝트-인식>#</a></h2><ul><li>메소드로 데이터를 연결하려면 아래와 같은 순서로 처리하게 된다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. 연결 기능을 가진 메소드를 선택합니다.
</span></span><span class=line><span class=cl>2. 메소드가 속한 오브젝트를 선택합니다.
</span></span><span class=line><span class=cl>3. 파라미터로 넘겨 줄 데이터를 준비합니다.
</span></span><span class=line><span class=cl>4. 데이터 타입에 따라 오브젝트를 생성합니다.
</span></span><span class=line><span class=cl>5. 오브젝트 메소드 형태로 호출하면서 연결하려는 값을 파라미터로 넘겨줍니다.
</span></span><span class=line><span class=cl>6. 메소드가 실행되며 메소드에서 값을 반환합니다.
</span></span></code></pre></td></tr></table></div></div><ul><li>위의 흐름을 전형적인 객체 지향 형태로 코딩하면 아래와 같다.</li><li>해당 오브젝트를 만들고, 그 오브젝트의 메소드를 호출하게 된다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>var</span> <span class=n>obj</span> <span class=o>=</span> <span class=n>new</span> <span class=ne>String</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>var</span> <span class=n>result</span> <span class=o>=</span> <span class=n>obj</span><span class=o>.</span><span class=n>concat</span><span class=p>(</span><span class=s1>&#39;sports&#39;</span><span class=p>,</span> <span class=s1>&#39;soccer&#39;</span><span class=p>,</span> <span class=mi>11</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>js</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>obj</span> <span class=o>=</span> <span class=n>new</span> <span class=ne>Array</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>obj</span><span class=o>.</span><span class=n>concat</span><span class=p>(</span><span class=s1>&#39;sports&#39;</span><span class=p>,</span> <span class=s1>&#39;soccer&#39;</span><span class=p>,</span> <span class=mi>11</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>js</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>자바스크립트 형태는 아래와 같이, 오브젝트를 생성하지 않고도 메소드를 호출해서 사용할 수 있다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>var</span> <span class=n>result</span> <span class=o>=</span> <span class=s1>&#39;sports&#39;</span><span class=o>.</span><span class=n>concat</span><span class=p>(</span><span class=s1>&#39;soccer&#39;</span><span class=p>),</span> <span class=mi>11</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>js</span><span class=o>.</span> <span class=nb>log</span><span class=p>(</span><span class=n>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;sports&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>concat</span><span class=p>(</span><span class=s1>&#39;soccer&#39;</span><span class=p>,</span> <span class=mi>11</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>js</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>result</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>메소드 호출시, 오브젝트.메소드(), 에서 오브젝트의 위치에 작성항 데이터 타입에 의해 오브젝트가 결정된다. 전형적인 객체지향 프로그램과 형태가 다르다.</li><li>데이터 타입에 의해 오브젝트가 속한 메소드가 호출되는 메커니즘을 뒷받침하는 것이 빌트인 타입, 빌트인 오브젝트입니다.</li></ul><h2 id=85-prototype-오브젝트>8.5 prototype 오브젝트<a hidden class=anchor aria-hidden=true href=#85-prototype-오브젝트>#</a></h2><ul><li>prototype을 사용하여 오브젝트에 메소드를 연결한다. 이 외에도 다른 오브젝트를 상속받아 연결하거나 prototype에 연결된 프로퍼티를 공유할 때 사용한다.</li></ul><h2 id=86-new-연산자>8.6 new 연산자<a hidden class=anchor aria-hidden=true href=#86-new-연산자>#</a></h2><ul><li><p>인스턴스를 생성해 반환한다.</p><table><thead><tr><th>구분</th><th>타입</th><th>데이터(값)</th></tr></thead><tbody><tr><td>constructor</td><td>Function</td><td>생성자</td></tr><tr><td>파라미터</td><td>any</td><td>값(옵션)</td></tr><tr><td>반환</td><td>Object</td><td>생성한 오브젝트</td></tr></tbody></table></li><li><p>파라미터로 넘겨줄 값이 없으면 new String;과 같이 소괄호를 작성하지 않아도 되지만, 소괄호 작성은 코등의 관례이다.</p></li><li><p>일부 빌트인 오브젝트는 new 연산자를 사용하지 않고 생성자만 작성해도 오브젝트를 생성해 반환한다.(Function, Number &mldr;)</p></li><li><p>new 연산자로 인스턴스를 생성하면 원본 오브젝트의 prototype에 연결된 메소드를 인스턴스에서 공유(참조, Reference) 한다. 따라서 인스턴스의 메소드를 호출하면 원본 오브젝트의 prototype에 연결된 메소드가 호출된다.</p></li><li><p>fallback 메소드: 엔진 버전에 따라 지원하지 않는 메소드가 있다. 개발자가 이 메소드를 만들어 빌트인 오브젝트의 prototype에 연결해 사용할 수 있다. 이 메소드를 fallback 메소드라고 한다,</p></li></ul><h2 id=87-constructor>8.7 constructor<a hidden class=anchor aria-hidden=true href=#87-constructor>#</a></h2><ul><li>생성자를 참조한다.(Global, Math, JSON 오브젝트를 생성자가 없어 인스턴스 생성이 불가)</li></ul><h2 id=88-instanceof-연산자>8.8 instanceof 연산자<a hidden class=anchor aria-hidden=true href=#88-instanceof-연산자>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://jaejin0me.github.io/tags/javascript/>Javascript</a></li></ul></footer><script src=https://utteranc.es/client.js repo=jaejin0me/blog_comment issue-term=title label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>