<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Jaejin's blog</title>
<meta name=keywords content><meta name=description content="Posts - Jaejin's blog"><meta name=author content="Jaejin Jang"><link rel=canonical href=https://jaejin0me.github.io/post/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jaejin0me.github.io/post/index.xml><link rel=alternate hreflang=ko href=https://jaejin0me.github.io/post/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8691946909799297" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T")}</script><meta property="og:title" content="Posts"><meta property="og:description" content="Jaejin Jang's blog"><meta property="og:type" content="website"><meta property="og:url" content="https://jaejin0me.github.io/post/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Jaejin Jang's blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jaejin0me.github.io/post/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io/ accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>블로그 리뉴얼 사항</h2></header><div class=entry-content><p>겉으로 보기에 바뀐것은 없어 보이지만 내부적으로 몇가지를 수정했습니다.
1. 빌드 및 deploy 자동화 현재까지 블로그에 새로운 글을 올리기 위한 과정을 다음과 같았습니다.
새로운 포스트를 추가한다. 빌드 한다. 블로그 github에 푸쉬한다. 이 중에서 23번 과정을 자동화 시켰습니다. 새로운 포스트를 추가하고 빌드용 repository에 push하기만 하면 빌드가 되고 블로그용 repository에 push가 되게 수정되었습니다.
이 과정에서 Travis CI 라는 사이트를 이용했습니다. 제일 고생한게 trivis ci에서 어떻게 빌드할지에 대한 스크립트인 .travis.yml 에서 hugo 설치였습니다.
구글에서 검색한 스크립트를 써도 잘안되더라고요. go get github 뭐 이렇게 시작하는 스크립트들이 많아서 따라해봤는데 저는 잘안됐습니다.
그래서 그냥 wget으로 dep받아서 설치하게 작성했습니다. 단순하지만 가장 확실한 방법!
...</p></div><footer class=entry-footer><span title='2019-05-28 21:59:55 +0900 +0900'>5월 28, 2019</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 블로그 리뉴얼 사항" href=https://jaejin0me.github.io/post/posts180/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Travis CI 테스트</h2></header><div class=entry-content><p>자동으로 빌드되어 올라가는지 테스트</p></div><footer class=entry-footer><span title='2019-05-27 17:26:41 +0900 +0900'>5월 27, 2019</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to Travis CI 테스트" href=https://jaejin0me.github.io/post/posts173/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>오랜만의 근황~ 19년 3월</h2></header><div class=entry-content><p>오랜만의 근황이네요. 요즘에 회사에 일도 많고, 고민도 많아요. 선택이란게 참 쉬운게 아닌거 같아요. 머리아프지만 잘 해결해 나가려고 노력중이에요. 업무외에도 공부는 계속하고 있는데, 요약한걸 타이핑해서 올리는 것도 일이라 요즘 못올리고 있네요. 시간날 때 몰아서 올려야겠어요
...</p></div><footer class=entry-footer><span title='2019-03-05 00:32:42 +0900 +0900'>3월 5, 2019</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 오랜만의 근황~ 19년 3월" href=https://jaejin0me.github.io/post/posts82/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>책뿌수기 - SQL 레벨업 7</h2></header><div class=entry-content><p>최근 sql 튜닝에 대해서 책도 보고 유투브에서 동영상도 몇편 봤었는데
그 중에서 저에게 가장 큰 통찰?을 줬던 영상이 있어서 링크 올립니다
[SQL Unplugged 2013] 쉽고 재미있는 인덱스 이야기/ 씨퀄로 이장래
...</p></div><footer class=entry-footer><span title='2019-02-07 22:20:56 +0900 +0900'>2월 7, 2019</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 책뿌수기 - SQL 레벨업 7" href=https://jaejin0me.github.io/post/posts109/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>책뿌수기 - SQL 레벨업 6</h2></header><div class=entry-content><p>6. 결합(결합을 지배하는 자가 SQL을 지배한다) ch 18. 기능적인 관점으로 구분하는 결합의 종류 크로스 결합 내부 결합 외부 결합 자기 결합 등가 결합/비등가 결합 자연 결합 위에서 3개는 배타적 결합이다. 컬럼) 자연 결합 구문 자연결합 = 내부 결합 + 등가 결합 1) 크로스 결합 - 모든 결합의 모체 데카르트 곱 (1) 실무에서 사용하지 않음 그런 결과가 필요없다 비용이 크다 (2) 실수로 사용한 크로스 결합 SELECT * FROM Employees, Departments; 2) 내부 결합 - 왜 ‘내부’라는 말을 사용할까? (1) 내부 결합의 작용 크로스 결합 결과의 부분집합 (2) 내부 결합과 같은 기능을 하는 상관 서브쿼리 스칼라 서브쿼리 = 리턴값이 하나인쿼리(SELECT의 필요 조건) 상관 서브쿼리보다 결합이 우수하다 3) 외부 결합 - 왜 ‘외부’라는 말을 사용할까? (1) 외부 결합의 작동 왼쪽/오른쪽/완전 외부 결합 키를 모두 가진 레이아웃의 리포트를 만들때 사용 4) 외부 결합과 내부 결합의 차이 외부 결합은 NULL을 생성한다 5) 자기 결합 - ‘자기’란 누구일까? ch 19. 결합 알고리즘과 성능 Nested Loops Hash Sort Merge 1) Nested Loops 이중 반복 바깥 반복 테이블(구동 테이블, 외부 테이블) &lt;-> 내부 테이블 접근하는 레코드 수 R(A) * R(B)이며 실행 시간은 레코드수에 비례한다. 구동 테이블을 작게 만드는 것이 중요하다 (1) 구동 테이블의 중요성 (내부 테이블의 결합키 필드에 인덱스가 존재) 구동 테이블을 작게 내부 테이블의 반복을 줄일 수 있음 이상적으로 구동 테이블의 레코드 한개에 내부 테이블의 레코드 한개가 대응하고, 해당 레코드를 내부 테이블의 인덱스로 사용해 찾을 수 있는 경우 레코드 레코드 수는 R(A) * 2 (2) Nested Loops 의 단점 결합키로 내부 테이블에 접근할 때 히트되는 레코드가 너무 많기 때문이다. 해결 역설적이게 구동 테이블을 큰것으로 Hash 2) Hash (1) Hash의 작동 작은 테이블을 스캔해 결합키 Hash (워키 메모리 사용량을 줄이기 위해) 큰 테이블에 접근해 Hash하고 매칭 (2) Hash의 특징 결합 테이블로부터 해시 테이블을 만드므로 Nested Loops에 비해 메모리를 많이 사용 메모리가 부족하면 저장소 사용으로 지연 출력되는 해시값은 입력값의 순서를 알지 못하므로, 등치 결합에만 사용 가능 (3) Hash가 유용한 경우 Nested Loops에서 적절한 구동 테이블이 존재하지 않는 경우 적절한 구동 테이블이 있지만, 내부 테이블에서 히트되는 레코드 수가 많은 경우 Nested Loops의 내부 테이블에 인덱스가 존재하지 않는 경우 (4) 유의사항 OLTP에서는 사용하면 안된다. 풀스캔(해시를 위해)의 비용도 고려할 것 3) Sort Merge (1) Sort Merge의 작동 결합키로 테이블들을 정렬하고, 일치하는 것 끼리 결합 대상 테이블을 모두 정렬해야하므로 메모리가 많이 사용 Hash와 달리 부등호를 사용해 결합 가능 테이블이 정렬되어 있다면 정렬을 생략 가능 테이블을 정렬하므로 테이블을 모두 스캔한 시점에 결합 완료 (2) Sort Meger가 유효한 경우 테이블 정렬을 생략 가능한 경우 4) 의도하지 않은 크로스 결합 삼각 결합 : 결합 조건이 A-B, A-C인 경우 B-C 사이에 크로스 결합이 일어날 수 있다. 옵티마이저가 B,C의 크기가 충분히 작다고 판단하는 경우 (1) 의도하지 않은 크로스 결합을 회피하는 방법 불필요한 결합 조건 추가 ch 20. 결합이 느리다면</p></div><footer class=entry-footer><span title='2019-01-31 22:20:56 +0900 +0900'>1월 31, 2019</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 책뿌수기 - SQL 레벨업 6" href=https://jaejin0me.github.io/post/posts107/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>책뿌수기 - SQL 레벨업 7</h2></header><div class=entry-content><p>7. 서브쿼리(곤란한 부분은 분할해야만 할까?) ch 21. 서브쿼리가 일으키는 폐해 1) 서브쿼리의 문제점 성능적 문제는 서브쿼리가 실체적인 데이터를 저장하고 있지 않다는 것에 있다. (1) 연산 비용 추가 서브쿼리 = SELECT 이므로 실행할때마다 SELECT 하는 것 (2) 데이터 I/O 비용 발생 연살결과가 커 저장소를 쓰게 되는 경우 급격한 속도 저하 발생 (3) 최적화를 받을 수 없음 서브쿼리의 결과에는 메타 정보가 없어 최적화가 불가능 2) 서브쿼리 의존증 (1) 서브쿼리를 사용한 방법 코드가 복잡해 읽기 어렵다 성능 결과가 일시적인 영역에 확보되므로 오버헤드 발생 최적화 불가 결합을 필요로 하기 때문에 비용이 높고 실행계획 변동 리스크가 존재 recipts 테이블 두번 스캔 필요 (2) 상관 서브쿼리는 답이 될 수 없다 어쨋든 테이블에 2번 접근해야 한다 (3) 윈도우 함수로 결합 해결 목표는 테이블 접근 1회로 줄이기 ROW_NUMBER를 사용해 구매 이력 번호를 붙이고, 이력이 1인 레코드 추출 3) 장기적인 관점에서의 리스크 관리 결합을 사용한 쿼리의 불안정 요소(상관 서브쿼리도 유사) 결합 알고리즘의 변동 리스크 환경 요인에 의한 지연 리스크(인덱스, 메모리, 매개변수 등) (1) 알고리즘 변동리스크 상황에 따라 변하는 결합 알고리즘 (2) 환경 요인에 의한 지연 리스크 결합을 사용한다는 것 = 장기적인 관점에서의 리스크 증가 4) 서브쿼리 의존증 - 응용편 (1) 다시 서브쿼리 의존증 (5) 서브쿼리는 정말 나쁠까? 생각하기는 쉬우나 RDB와는 맞지 않다 ch 22. 서브쿼리 사용이 더 나은 경우 결합쿼리는 최대한 결합 대상 레코드수를 줄이는 것이 중요한데, 옵티마이저가 잘 판단하지 못하는 경우 직접 연산 순서를 명시하는 용도로 힌트 사용 1) 결합과 집약 순서 (1) 두 가지 방법 결합 -> 집약 집약 -> 결합 (2) 결합 대상의 레코드 수 2의 경우 레코드수가 줄기 때문에 더 나은 선택일 수 있다(사전에 결합 레코드수 압축)</p></div><footer class=entry-footer><span title='2019-01-31 22:20:56 +0900 +0900'>1월 31, 2019</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 책뿌수기 - SQL 레벨업 7" href=https://jaejin0me.github.io/post/posts108/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>책뿌수기 - SQL 레벨업 5</h2></header><div class=entry-content><p>인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다
5. 반복된(절차 지향형의 속박) ch 14. 반복문 의존증 RDB는 관계 전체를 조작의 대상으로 삼기 때문에 설계상에서 반복을 제외했다 ch 15. 반복계의 공포 record at a time 사고 방식 반복계의 장점은 생각하기 쉽고 단순하다는 것 1) 반복계의 단점 성능 (1) SQL 실행의 오버헤드 전처리 a. sql 구문을 네트워크로 전송 b. DB 연결 c. sql 구문 파스 d. sql 구문의 실행 계획 생성 또는 평가 후처리 e. 결과 집합을 네트워크로 전송 a, e는 동일한 본체에 있거나 분리되어 있어도 고만고만함 b는 요즘에 커넥션 풀이라는 기술로 오버헤드를 감소시킴 c와 d가 주된 오버헤드이다. 그중에서도 c가 성가시다 c는 db가 sql을 받을때 마다 실행하므로 반복계에서는 오버헤드의 비중이 커진다 (2) 병렬 분산이 힘들다 반본계는 하나씩만 처리하기 때문에 병렬처리가 힘들다 저장소의 분산 효율이 낮다(하나씩 처리하다보니 한번에 처리하는 데이터가 얼마안됨) (3) 데이터 베이스의 진화로 인한 혜택을 받을 수 없다 대규모의 데이터를 효율적으로 다루기 위해 진화하고 있으나, 반복계를 사요하면 그 혜택을 받을 수 없다 포장계 sql이 반복계에 비해 복잡하므로 튜닝을 잘해야 하는 단점도 있는 반면 제대로만 튜닝하면 현격한 성능차이가 발생한다 반복계는 단순해 튜닝포인트도 적다 2) 반복계를 빠르게 만드는 방법은 없다 (1) 반복계를 포장계로 다시 작성 애플리케이션의 수정을 의미 (2) 각각의 sql을 빠르게 수정 너무 단순해 튜닝한 건덕지가 없음 (3) 다중화 처리 리소스 여유가 있고, 처리를 나눌 수 있는 키가 있고, 순서가 중요하지 않다면 다중화 가능 3) 반복계의 장점 sql이 단순하다 (1) 실행 계획의 안정성 실행계획이 바뀌어 느려지는 경우가 없다 (2) 예상 처리 시간의 정밀도 (3) 트랜잭션 제어가 편리 ch 16. sql에서는 반복을 어떻게 표현할까? 1) 포인트는 CASE식과 윈도우 함수 1 2 3 4 5 6 7 8 9 10 11 12 INSERT INTO Sales2 SELECT company, year, sale, CASE SIGN(sale - max(sale) OVER(PARTITION BY company ORDER BY year ROWS BETWEEN 1 PRECENDING AND 1 PRECENDING) WHEN 0 THEN '=' WHEN 1 THEN '+' WHEN -1 THEN '-' ELSE NULL END AS Var FROM Sales; 1 ROWS BETWEEN 1 PRECENDING AND 1 PRECENDING 현재 레코드에서 1개 이전부터 1개 이전까지의 레코드 범위 지정
...</p></div><footer class=entry-footer><span title='2019-01-30 22:20:56 +0900 +0900'>1월 30, 2019</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 책뿌수기 - SQL 레벨업 5" href=https://jaejin0me.github.io/post/posts106/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>책뿌수기 - SQL 레벨업 4</h2></header><div class=entry-content><p>4. 집약과 자르기 ch 12. 집약 COUNT, SUM, AVG, MAX, MIN(Aggregate function) 1) 여러 개의 리코드를 한 개의 레코드로 집합 필드 수가 다르면 UNION 적용이 불가능하다. 또한 UNION으로 여러개의 쿼리를 머지하는 것은 성능적으로 안티패턴이다. GROUP BY 구로 집약을 했을 때 SELECT 구에 입력할 수 있는 것은 상수 GROUP BY 구에서 사용한 집약 키 집약함수 집약함수가 적용되면 여러 요소가 있는 집합으로부터 연산결과가 나옴 집약, 해시, 정렬 집약시에는 해쉬 알고리즘을 사용한다(때로는 정렬) GROUP BY 구에 지정된 필드를 해쉬 함수로 사용해 결과를 만들고, 같은 결과로 그룹을 만들어 집약한다. 고전적인 방법보다 효율적 해쉬와 정렬 모두 메모미를 많이 사용하기 때문에, 충분한 워킹 메모리가 확보되지 않으면 스왑이 발생한다(극단적 성능저하 발생) 2) 합쳐서 하나 문제 : 연령대 별로 가격이 다른 제품중에서 0 ~ 100세가 이용가능한 제품 고르기 hint : 각 범위의 상수를 합해 101인 제품 선택하기 1 2 3 4 SELECT product_id FROM PriceByAge GROUP BY product_id HAVING SUM(high_age - low_age + 1) = 101; ch 13. 자르기 집약 이외에도 중요한 자르기 라는 기능이 있다 1) 자르기와 파티션 1 2 3 4 SELECT SUBSTRING(name, 1, 1) AS label, COUNT(*) FROM Persons GROUP BY SUBSTRING(name, 1, 1); GROUP BY 구로 잘라 만든 하나 하나의 부분 집합을 ‘파티션’이라고 한다.
...</p></div><footer class=entry-footer><span title='2019-01-29 22:20:56 +0900 +0900'>1월 29, 2019</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 책뿌수기 - SQL 레벨업 4" href=https://jaejin0me.github.io/post/posts105/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>책뿌수기 - SQL 레벨업 3</h2></header><div class=entry-content><p>3. SQL의 조건 분기 ch 8. UNION을 사용한 쓸데없이 긴 표현 UNION을 사용한 조건 분기는 좋지 않다. UNION은 내부적으로 여러개의 SELECT 구문을 실행하는 실행계획으로 해석된다 (= 테이블에 접근하는 횟수(I/O)가 늘어난다) 1) UNION을 사용한 조건 분기와 관련된 간단한 예제 UNION을 사용한 조건 분기 1 2 3 4 5 6 7 SELECT item_name, year, price_tax_ex AS price FROM Items WHERE year &lt;= 2001 UNION ALL SELECT item_name, year, price_tax_in AS price FROM Items WHERE year >= 2002 단점 : 1. 길다, 2. 테이블에 2회 접근한다. 2) WHERE 구에서 조건 분기를 하는 사람을 초보자 1 2 3 4 SELECT item_name, year CASE WHEN year &lt;= 2001 TEHN price_tax_ex WHEN year >= 2002 THEN price_tax_in END AS price FROM Items 3) SELECT 구를 사용한 조건 분기의 실행 계획 테이블 1회 접근으로 끝난다 구문 => 식, UNION => CASE ch 9. SELECT 구를 사용한 조건 분기의 실행 계획 1) 집계 대상으로 조건 분기 UNION을 사용한 방법 1 2 3 4 5 6 7 8 9 SELECT prefecture, SUM(pop_men) AS pop_men, SUM(pop_wom) AS pop_wom FROM(SELECT prefecture, pop AS pop_men null AS pop_wom) FROM Population WHERE sex = '1' # 남성 UNION SELECT prefecture, null AS pop_men, pop AS pop_wom FROM Population WHERE sex = '2') TMP # 여성 GROUP BY prefecture 풀스캔이 2회 수행된다.
...</p></div><footer class=entry-footer><span title='2019-01-20 22:20:56 +0900 +0900'>1월 20, 2019</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 책뿌수기 - SQL 레벨업 3" href=https://jaejin0me.github.io/post/posts104/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>책뿌수기 - SQL 레벨업-2</h2></header><div class=entry-content><p>인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다
1. SQL 기초 ch 6. SELECT 구문 1) SELECT 구와 FROM 구 SELECT 1 처럼 상수를 선택하는 경우 FROM이 필요없다. )2) WHERE 구 WHERE 구의 조건이 많을 경우 IN 으로 대체 SELECT 구문은 테이블을 반환하는 읽기 전용 함수 이다. 3) GROUP BY 구 일부 DBMS에서는 지원하지 않음 4) HAVING GROUP BY에 조건을 걸때 WHERE가 레코드에 조건을 거는 것이라면, HAVING은 집합에 조건을 거는 것 5) ORDER BY 6) 뷰와 서브쿼리 자주 사용하는 SELECT 구문을 DB에 저장 = 뷰(view) 뷰는 내부에 데이터러 보유하지 않음(SELECT 구문을 저장할 뿐) 서브쿼리의 실행과 동일하다 WHERE 조건에 서브쿼리를 거면 조건이 바뀌어도 문제없음(조건을 하나하나 하드코딩하는 번거로움을 없앨수있다) ch 7. 조건 분기, 집합 연산, 윈도우 함수, 갱신 1) SQL과 조건 분기 SQL의 조건 분기는 CASE식을 통해 한다. SQL의 조건 분기는 특정한 값을 리턴하는 것이 특징이다. CASE는 식이기 때문에 활용성이 높은 것이 강점이다. 2) SQL의 집합 연산 UNION : 합집합(기본적으로 중복을 제거) INTERSECT : 교집합 EXCEPT : 차집합 3) 윈도우 함수 집약 기능이 없는 GROUP BY 구 PARTITION BY SELECT 구에만 사용됨 윈도우 전용함수로 RANK, ROW_NUMBER가 있다. 4) 트랜잭션과 갱신 INSERT, UPDATE, DELETE</p></div><footer class=entry-footer><span title='2019-01-20 22:20:56 +0900 +0900'>1월 20, 2019</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 책뿌수기 - SQL 레벨업-2" href=https://jaejin0me.github.io/post/posts103/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://jaejin0me.github.io/post/page/11/>«&nbsp;이전 페이지&nbsp;
</a><a class=next href=https://jaejin0me.github.io/post/page/13/>다음 페이지&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>