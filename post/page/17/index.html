<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Jaejin's blog</title>
<meta name=keywords content><meta name=description content="Posts - Jaejin's blog"><meta name=author content><link rel=canonical href=https://jaejin0me.github.io/post/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jaejin0me.github.io/post/index.xml><link rel=alternate hreflang=ko href=https://jaejin0me.github.io/post/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T")}</script><meta property="og:title" content="Posts"><meta property="og:description" content="Jaejin Jang's blog"><meta property="og:type" content="website"><meta property="og:url" content="https://jaejin0me.github.io/post/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Jaejin Jang's blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jaejin0me.github.io/post/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io/ accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 11495번 - 격자 0 만들기</h2></header><div class=entry-content><p>시간초과가 계속해서 나는 것은 최적화 하면서 근근이 풀긴했는데, 속도가 많이 느리다. 자바로 풀 사람들 중에서 꼴등임 ㅎ
다른 정답자들의 풀이를 보니, 나는 에드몬드 카프 알고리즘을 이용해 풀었지만 빠르게 푼 사람들은 “디닉 알고리즘"이라는 것을 이용해서 풀었다.
...</p></div><footer class=entry-footer><span title='2018-02-04 12:20:42 +0900 +0900'>2월 4, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 11495번 - 격자 0 만들기" href=https://jaejin0me.github.io/post/posts62/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 2316번 - 도시 왕복하기</h2></header><div class=entry-content><p>어제 못 풀고 오늘에서야 푼 문제
정점을 1번만 지나는 조건을 만족하기 위해 정점을 분할하고 분할된 정점사이에 용량의 1의 간선을 추가해야 한다.
주의해야 할 것은 입력되는 간선들을 분할될 정점을 고려해 잘 이어주는 것이다.
...</p></div><footer class=entry-footer><span title='2018-01-30 12:20:42 +0900 +0900'>1월 30, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 2316번 - 도시 왕복하기" href=https://jaejin0me.github.io/post/posts61/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>2017 암호경진대회 2번</h2></header><div class=entry-content><p>원본과 동일한 서명값을 만들어 내는 메시지를 구하는 문제입니다.
48bit의 해쉬함수가 사용되는데 함수를 분석해보면 16bit의 값만을 갖는 걸을 알 수 있습니다.
...</p></div><footer class=entry-footer><span title='2018-01-29 01:37:56 +0900 +0900'>1월 29, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 2017 암호경진대회 2번" href=https://jaejin0me.github.io/post/posts76/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 2188번 - 축사배정</h2></header><div class=entry-content><p>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 /** * */ import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.Queue; import java.util.Scanner; import java.util.StringTokenizer; /** * @author jaeji * */ class edge{ int to; int flow; int cap; edge rever; edge(){ this(0,0,0,null); } edge(int ar_to, int ar_flow, int ar_cap, edge ar_rever){ to = ar_to; flow = ar_flow; cap = ar_cap; rever = ar_rever; } int residu() { return cap-flow; } void addflow(int ar_flow) { flow+=ar_flow; rever.flow -=ar_flow; } } public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader( new InputStreamReader( System.in ) ); //BufferedReader br = new BufferedReader( new FileReader("input.txt" ) ); StringTokenizer st = new StringTokenizer(br.readLine()); int n = Integer.parseInt(st.nextToken()); int m = Integer.parseInt(st.nextToken()); int[] prev = new int[402]; ArrayList[] adj = new ArrayList[402]; Queue&lt;Integer> q = new LinkedList&lt;Integer>(); int total = 0; for(int i=0;i&lt;402;i++) { adj[i] = new ArrayList&lt;edge>(); } for(int i=0;i&lt;n;i++) { edge temp_edge = new edge(i,0,1,null); edge temp_rever_edge = new edge(400,0,0,temp_edge); temp_edge.rever = temp_rever_edge; adj[400].add(temp_edge); adj[i].add(temp_rever_edge); } for(int i=200;i&lt;200+m;i++) { edge temp = new edge(401,0,1,null); edge temp_rever_edge = new edge(i,0,0,temp); temp.rever = temp_rever_edge; adj[i].add(temp); adj[401].add(temp_rever_edge); } int no = 0; int temp = 0; for(int i=0;i&lt;n;i++) { st = new StringTokenizer(br.readLine()); no = Integer.parseInt(st.nextToken()); for(int j=0;j&lt;no;j++) { temp = Integer.parseInt(st.nextToken())+199; edge temp_edge = new edge(temp,0,1,null); edge temp_rever_edge = new edge(i,0,0,temp_edge); temp_edge.rever = temp_rever_edge; adj[i].add(temp_edge); adj[temp].add(temp_rever_edge); } } int curr = 0; edge next = null; int S = 400; int E = 401; while(true) { edge[] path = new edge[402]; Arrays.fill(prev, -1); q.clear(); q.add(S); curr = 0; next = null; while(!q.isEmpty()) { // 소스에서 흐를수 있는 유량찾기 curr = q.poll(); for(int i=0;i&lt;adj[curr].size();i++) { next = (edge) adj[curr].get(i); if(next.residu() > 0 && prev[next.to] == -1) { q.add(next.to); prev[next.to] = curr; path[next.to] = next; if(next.to == E) break; } } } if(prev[E] == -1) break; // 경로를 탐색 한 후 싱크로 가는 경로가 없는 경우 for(int i=E;i!=S;i=prev[i]) { path[i].addflow(1); } total += 1; } System.out.println(total); } }</p></div><footer class=entry-footer><span title='2018-01-28 12:20:42 +0900 +0900'>1월 28, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 2188번 - 축사배정" href=https://jaejin0me.github.io/post/posts60/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 1929번 - 소수 구하기</h2></header><div class=entry-content><p>주어진 두 정수 범위내의 소수를 구하는 문제입니다.
에라토스테네스의 체 라는 것을 사용해 구합니다.
개념적으로 주의해야 할 것은 소수 판별하는 것과 다릅니다. 에라토스테네스의 체 는 특점 범위의 소수를 구할때 쓰는 알고리즘입니다.
...</p></div><footer class=entry-footer><span title='2018-01-26 12:20:42 +0800 +0800'>1월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 1929번 - 소수 구하기" href=https://jaejin0me.github.io/post/posts57/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 1978번 - 소수 찾기</h2></header><div class=entry-content><p>주어지는 수들 중에서 소수의 개수를 출력하는 문제입니다.
소수를 판별하는 가장 기초적인 방법인 2~n-1 까지 나눠지는지 확인해서 판별하면 됩니다.
또한 $$\sqrt{n}$$ 까지 나눠지는 약수가 없으면 소수 라는 성질을 이용해 계산량을 줄일 수 있습니다.
...</p></div><footer class=entry-footer><span title='2018-01-26 12:20:42 +0800 +0800'>1월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 1978번 - 소수 찾기" href=https://jaejin0me.github.io/post/posts56/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 2609번 - 최대공약수와 최소공배수</h2></header><div class=entry-content><p>두 자연수의 최대 공약수와, 최소 공배수를 출력하는 문제입니다.
유클리드 호제법을 이용해 최대공약수를 구하고 최대공야수를 이용해 최소 공배수를 구하면 됩니다.
최소 공배수만 구하라고 하는 경우에도 최대공약수를 구하여 최소공배수를 구하는 것이 쉽습니다.
...</p></div><footer class=entry-footer><span title='2018-01-26 12:20:42 +0800 +0800'>1월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 2609번 - 최대공약수와 최소공배수" href=https://jaejin0me.github.io/post/posts58/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 2747번 - 피보나치 수</h2></header><div class=entry-content><p>피보나치 수를 구하는 가장 기초적인 알고리즘입니다.
$$ F_n = F_{n-1} + F_{n-2} (n>=2) $$
점화식을 그대로 구현하여 재귀적으로 풀어내면 됩니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /** * */ import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.Queue; import java.util.Scanner; import java.util.StringTokenizer; /** * @author jaeji * */ public class Main { static int fibonacci(int no) { if(no==0) return 0; else if(no==1) return 1; else return fibonacci(no-1)+fibonacci(no-2); } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader( new InputStreamReader( System.in ) ); //BufferedReader br = new BufferedReader( new FileReader("input.txt" ) ); StringTokenizer st = new StringTokenizer(br.readLine()); int n = Integer.parseInt(st.nextToken()); int result = fibonacci(n); System.out.println(result); } }</p></div><footer class=entry-footer><span title='2018-01-26 12:20:42 +0800 +0800'>1월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 2747번 - 피보나치 수" href=https://jaejin0me.github.io/post/posts54/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 2748번 - 피보나치 수 2</h2></header><div class=entry-content><p>피보나치 수 두번째 입니다.
DP로 푸는 문제입니다.
점화식으로 풀때는 Top-down 방식이지만 DP로 풀때는 Bottom-up 방식입니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.Queue; import java.util.Scanner; import java.util.StringTokenizer; /** * @author jaeji * */ public class Main { static long[] arr = new long[91]; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader( new InputStreamReader( System.in ) ); //BufferedReader br = new BufferedReader( new FileReader("input.txt" ) ); StringTokenizer st = new StringTokenizer(br.readLine()); int n = Integer.parseInt(st.nextToken()); arr[1] = 1; for(int i=2;i&lt;=n;i++) { arr[i] = arr[i-1] + arr[i-2]; } System.out.println(arr[n]); } }</p></div><footer class=entry-footer><span title='2018-01-26 12:20:42 +0800 +0800'>1월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 2748번 - 피보나치 수 2" href=https://jaejin0me.github.io/post/posts55/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>자바에서 입력 빠르게 받기</h2></header><div class=entry-content><p>Scanner는 성능이 떨어지기 때문에 입력이 많은 경우 문제가 생깁니다.
BufferedReader와 StringTokenizer를 이용해 입력받는 것을 습관화 시키는게 좋습니다.
...</p></div><footer class=entry-footer><span title='2018-01-26 12:20:42 +0900 +0900'>1월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 자바에서 입력 빠르게 받기" href=https://jaejin0me.github.io/post/posts59/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://jaejin0me.github.io/post/page/16/>«&nbsp;이전 페이지&nbsp;
</a><a class=next href=https://jaejin0me.github.io/post/page/18/>다음 페이지&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>