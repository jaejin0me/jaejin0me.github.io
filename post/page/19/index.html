<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Jaejin's blog</title>
<meta name=keywords content><meta name=description content="Posts - Jaejin's blog"><meta name=author content="Jaejin Jang"><link rel=canonical href=https://jaejin0me.github.io/post/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jaejin0me.github.io/post/index.xml><link rel=alternate hreflang=ko href=https://jaejin0me.github.io/post/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8691946909799297" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T")}</script><meta property="og:title" content="Posts"><meta property="og:description" content="Jaejin Jang's blog"><meta property="og:type" content="website"><meta property="og:url" content="https://jaejin0me.github.io/post/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Jaejin Jang's blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jaejin0me.github.io/post/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io/ accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 2748번 - 피보나치 수 2</h2></header><div class=entry-content><p>피보나치 수 두번째 입니다.
DP로 푸는 문제입니다.
점화식으로 풀때는 Top-down 방식이지만 DP로 풀때는 Bottom-up 방식입니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.Queue; import java.util.Scanner; import java.util.StringTokenizer; /** * @author jaeji * */ public class Main { static long[] arr = new long[91]; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader( new InputStreamReader( System.in ) ); //BufferedReader br = new BufferedReader( new FileReader("input.txt" ) ); StringTokenizer st = new StringTokenizer(br.readLine()); int n = Integer.parseInt(st.nextToken()); arr[1] = 1; for(int i=2;i&lt;=n;i++) { arr[i] = arr[i-1] + arr[i-2]; } System.out.println(arr[n]); } }</p></div><footer class=entry-footer><span title='2018-01-26 12:20:42 +0800 +0800'>1월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 2748번 - 피보나치 수 2" href=https://jaejin0me.github.io/post/posts55/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>자바에서 입력 빠르게 받기</h2></header><div class=entry-content><p>Scanner는 성능이 떨어지기 때문에 입력이 많은 경우 문제가 생깁니다.
BufferedReader와 StringTokenizer를 이용해 입력받는 것을 습관화 시키는게 좋습니다.
...</p></div><footer class=entry-footer><span title='2018-01-26 12:20:42 +0900 +0900'>1월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 자바에서 입력 빠르게 받기" href=https://jaejin0me.github.io/post/posts59/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>영상처리 기초 - 2</h2></header><div class=entry-content><p>4. 화소값 기본 처리 1) 공간영역의 정의 (1) 공간 영역 화소들의 집단 또는 공간적 배열 (2) 주파수 영역 저주파 또는 고주파 (3) 마스크 기반 처리 마스크의 다른 이름 템플릿, 윈도우, 필터, 커널 등 Convolution(회선) 공간 영역 내에 있는 입력 화소값들과 마스크 내의 값을 곱하여 새로운 출력 화소값을 얻는 것이다. 공간 필터링이라 표현됨 $$Output(i,j) = \sum_{s=-k}^k \sum_{t=-k}^k m(s,t)p(i+s,j+t)$$ output(i,j) : Convolution(회선) 처리로 출력한 화소 p(i,j) : 입력 영상의 화소 m(i,j) : 입력 영상의 화소에 대응하는 가중치 1 2 3 4 5 6 7 8 9 (4) Convolution(회선) Convolution $$ f*g(t) = \int_{-inf}^{+inf}f(τ)g(t-τ)dτ $$ (5) Spatial Convolution(공간 회선) Convolution과정 유무에 따라 선형/비선형으로 구분된다. 선형 공간 필터링(출력:y=m1x1+m2x2+ ~~~ mnsx) Embossing:양각효과를 만드는 것 Bluring : 영상을 부드럽게 Shparpening : 세세한 부분을 두드러지게 또는 강조 Edge Detection : 방향성 검출 비선형 공간 필터링 Convolution 과정 대신 블록 내 일정 값만 추출하여 출력하는 형식 미디언, 평균값, 최대/최소 필터링 2) 양각 효과 (1)양각 효과 중앙값이 0이고, 마스크 내의 핪이 0인 마스크를 이용
...</p></div><footer class=entry-footer><span title='2018-01-24 16:42:42 +0900 +0900'>1월 24, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 영상처리 기초 - 2" href=https://jaejin0me.github.io/post/posts121/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>영상처리 기초 - 1</h2></header><div class=entry-content><p>1. 영상처리 기본 1) 영상처리의 개념 (1) 영상처리의 예 sharpening Image segmentation Noise filtering special effect(Sepia tone effect (2) 영상처리 기술 Image Transforms Image Transmissions Image Enhancement Image Restoration Image Compression Image Segmentation Representation and Description Recognition and Interpretation 1) 영상처리의 응용 분야 의료 영상처리 : 신경망 활용 문자인식 영상 검색 : 영상처리 기술들의 집약체 컴퓨터 비전 : 인간의 눈으로 확인할 수 없는 제품 결함 판단 인터넷에 기반한 스트리밍 기술 영상 압축 기술 : MPEG 영상 처리 관련 SW 개발 생물학/군사학 디스플레이 2. 컬러 공간 분석 1) Image Basics (1) Pexels rectangular triangular hexagonal (2) N-connected neighbors 4-connected 8-connected ambiguous (3) Distance metrics Euclidean : De(X,Y) = ((x2-y2)^2 + (y2-y1)^2)^1/2 City Block : Dcb(X,Y) = |x1-x2| + |y1-y2| Chessboard : Dcb(X,y) = max{|x1-x2|,|y1-y2|} (4) 명암도 영상(gray image) (5) RGB 영상 : 각 채널별 8비트, 24비트 개의 색 표현 가능 (6) 이진 영상 (7) 영상의 용량 : 시간(s)*프레임(f/s)화소의 수화소당 비트 2) 컬러 공간에 대한 이해 (1) 컬러는 인가의 눈에 보이는 가시 광선 (2) 빛의 3원색 : R, G, B 간의 가산 혼합 (3) 모니터에서는 RGB를 조합해 사용함 (4) 영상의 정의 컬러를 표현하는 화소값의 배열 (5) 흑백 영상 분리 RGB 컬러 공간 : 0.333R+0.333B+0.333G NTSC 제안 각 RGB값 중 하나만 사용 Green만 사용 Gray level = (R^2+B^2+G^2)^1/2 / 3^1/2 Gray level = 0.212671R + 0.715160G + 0.071169B (6) 다른 영상 처리 응용에 한계 RGB 컬러 요소들은 상호 관계가 너무 커서 특정 생성만 분리하기 어려움 (7) HSI 컬러 공간 색상, 채도, 명도로 구분한 컬러 공간으로 인간의 시각 시스템과 유사 3) HSI 컬러 공간 (1) 색의 3 요소 색상(hue) : pure colore 채도(saturation) : white 와 pure color 와의 혼합 비율 명도(Intensity) : 색의 밝고 어두운 정도 (2) 색입체 먼셀, 오스왈드, P.G.C.S 등 Hue : 원통모양의 주변, 0 ~ 360 Satuation : 중심으로부터의 거리, 0 ~ 1 Intensity : 하단 꼭지점에서 최상부 까지의 거리, 0 ~ 1, 색의 표현 범위가 달라짐 (3) RGB -> HSI H = { Θ if B&lt;=G ㅤㅤ{ 360 - 0 if B&lt;=G Θ = cos^-1[1/2*[(R-G)+(R+B)]/((R-G)^2+(R-B)(G-B))^1/2] S = 1 - 3/(R+G+B)*[min(R,G,B)] I = 1/3*(R+G+B) (4) CMYK 컬러 공간 : Printer 청록(Cyan) : C=255-R 자홍(Magenta) : M=255-G 노랑(Yellow) : Y=255-B 감산 혼합 C+M+Y= 검정 K = min(C,M,Y) C = 기존 C - K M = 기존 M - K Y = 기존 Y - K 인쇄를 보낼 때는 CMYK 컬러 공간으로 변환해 보내는 것이 좋다 CMYK 컬러 공간의 한계 RGB보다 범위에 한계 다소 뿌옇게 인쇄 CMYK 형태로 직접 모니터로 불러들여 작업하지 않음 5) 다른 컬러 공간 (1) YIQ 인간의 시각체계와 유사하게 흉내낸 최초의 색상공간 Y는 명조, I는 orange-cyan, Q는 Green-Magenta 1950년대, 컬러 텔레비전(NTSC방식) 개발자들의 의해 구성 (2) YCbCr 색상정보로 부터 명도를 분리하는 또 하나의 다른 색상 공간 Y는 명도, Cb는 푸른색, Cr, 붉은색 JPEG, MPEG 및 디지털 TV의 표준으로 사용 (3) CIE LAB : uniform color space L*, a*, b* L* 는 명도, a* red와 green, b*는 yellow와 blue 3. 화소값 기본 처리 1) 영상의 밝기 조절 (1) 명암도 영상(흑백 영상) 한 화소당 8비트의 데이터 크기 0 ~ 255의 범위 (2) 명암값을 더하거나 뺄 경우 0이하 이거나 255이상일 때 문제 발생 클랭핌을 이용한 해결 Saturation : 0이하 -> 0, 255 이상 -> 255 Wrap : 256 = 1, 257 = 2, 258 = 3, 반전 시키는 방법이지만 명암 불균등을 낳는다. (3) 영상의 산술 연산 밝게 = 255에 가깝게 어둡게 = 0에 가깝게 (4) 산술 연산 적용 예 차영상 : 움직임 추적에 쓰임 2) 영상의 명암대비 조절 (1) 명암 대비(Contrast) : 명암값의 분포 낮음 명암 대비 : 명암차가 적음 높은 명암 대비 : 명암차가 큼 (2) 대비의 증가 = 곱셈 연산 (3) 대비의 감소 = 나눗셈 연산 3) 히스토그램 (1) 히스토그램 각화소의 명암값의 개수 영상의 명암 값 프로필(profile) - > 히스토그램 유사도를 사용한 영상 비교에 유용하다 4) 히스토그램 평활화 한 쪽에 치우친 명암 분포를 가진 히스토그램을 재분배 하는 과정을 거쳐 일정한 분포를 가지게 하는 히스토그램 h(i) = (H(i)/Nt)*Gmax h(i) : 정규화 합 히스토그램 H(i) : 누적 히스토그램 Nt : 영상에서 픽셀의 총 개수 Gmax : 영상의 최대 밝기 5) 히스토그램 스트레칭 명암 대비 확장, 명암 대비 스트레칭 낮은 대비의 히스토그램을 균등한 분포로 만드는 알고리즘 X: 기존 명암 값 low : 히스토그램에서 가장 작은 화소값 high : 히스토그램에서 가장 큰 화소값 새로운 명암 값 = 255*(X-low)/(high-low) 스트레칭 변형 : 엔드인 탐색(ends-in search) low, high의 범위 값을 지정하여 스트레칭 한다. 히스토그램의 특정 부분에 화소들이 치우진 형상을 보정하는데 유용하다. 새로운 명암 값 = { 0 for X&lt;=low ㅤㅤㅤㅤㅤㅤㅤㅤ{ 255*(x-low)/(high-low) for low&lt;=X&lt;high ㅤㅤㅤㅤㅤㅤㅤㅤ{ 255 for high&lt;=X 6) 명암 변환 (1) 명암 변환(Intensity Transformation) 미리 지정된 함수 f(x)를 바탕으로 이진 화소값을 새로운 화소값으로 바꿔주는 알고리즘 널 변환(Null Transforamtion) : f(x) = x , 원영상과 같음 역 변환(Inverse Transformation) : f(x) = 255 - x (음화 영상,negative image) (2) 비트 플래너 슬라이싱(bit-planner slicing) 변환 각 비트에 대하여 0인지 1인지 검사하여 하나의 영상 형태로 만든 것을 비트 평면이라고 부른다 msb는 영상의 윤곽 정보를 가장 잘 간직하고 있다. lsb는 영상의 윤곽 정보를 거의 저장하고 있지 않다. 비트 평면 분할은 특정 비트의 중요도를 분석하는데 중요한 정보를 제공한다. 예) 영상 압축, 워터마킹 기법에 적용 7) 이진 영상 변환 및 처리 (1) 이진화 배경과 객체의 간단한 분리, 영상의 간략화 등의 목적으로 영상 분석 분야에서 필수적인 전처리 과정이다 (2) 경계값 설정 방법에 따른 이진 영상 생성 알고리즘 히스토그램의 분포를 파악하여 적합한 경계값을 설정 블록 이진화 기법 적용 -> 블록으로 나뉘어 평균값을 임계로 이중 경계값 설정 적응적 경계값 반복적 경계값 난수 경계값 (3) 단일 경계값과 이중 경계값 설정을 이용한 이진 영상 변환 단일 경계값을 이용한 이진 영상 변환 Binary-image[x][y] = { 1 if Gray-image[x][y]>=threshold ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ{ 0 else Gray-image[x][y]&lt;threshold 이중 경계값을 이용한 이진 영상 변환 Binary-image[x][y] = { 1 if low-threshold&lt;=Gray-image[x][y]&lt;high-threshold ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ{ 0 otherwise (4) 히스토그램 분포를 이용한 이진 영상 변환 Otsu(온츄) Algorithm 영상의 히스토그램의 형태가 쌍봉형이라고 가정 했을 때 그 사이의 계곡점을 찾아 임계값으로 하고 분할 후, 분할 된 클래스 사이의 분산을 최대화 시키는 임계값을 찾는 방법 클래스 내의 분산과 클래스 간의 분산화 전체 구간에서의 분산을 이용하여 클래스 간의 분산이 최대가 될 때의 값(클래스 내의 분산이 가장 작을 때)을 임계값으로 한다. 전체 분산 : αa^2(t) = αw^2(t) + αb^2(t) 클래스 내의 분산 : αw^2(t) = W1(t)α1^2(t) + W2(t)α2^2(t) 클래스 간의 분산 : αb^2(t) = αb^2-αw^2 = W1(t)W2(t)[u1(t)-u2(t)]^2 Wn : 전체 클래스에 대한 각 클래스의 확률 un : 각 클래스에 대한 평균 명도값 (5) 반본적 경계값 설정 을 이용한 이진 영상 변환 영상의 화소 평균 값을 구할 때 모든 화소의 값을 더해서 전체화소의 개수로 나누어 평균을 계산하는 것 보다 수행 속도 면에서 훨씬 빠른 것으로 알려져 있다. step 1. 모든 화소값의 평균값을 계산하여 초기 임계값을 T라고 한다 step 2. 그레이 스케일 값이 T 보다 작은 픽셀들의 그레이 스케일 값의 평균 u1이라고 하고, T보다 큰 스케일 값의 평균을 u2라고 하여 임계 값을 다음과 같이 계산한다 T = (u1+u2)/2 step 3. T간의 변화가 없을 때 가지 반복한다.</p></div><footer class=entry-footer><span title='2018-01-23 16:42:42 +0900 +0900'>1월 23, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 영상처리 기초 - 1" href=https://jaejin0me.github.io/post/posts120/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 6086번, 최대 유량</h2></header><div class=entry-content><p>드디어 네트워크플로우
처음에 목표한 알고리즘이 MCMF까지였기 때문에, 곧 결과에 쫓기듯 공부할 필요는 없을꺼같다.
배울 알고리즘이 참 많지만 사실 그런알고리즘은 내가 앞으로 쓸일이 있을까 하는 의문이 들어서 필요성을 느끼지 못하겠다. 그리고 필요하다면 그 때 배워서 사용하면 될꺼같기도 하다. 시험문제로 나온다면.. 그저 슬플수 밖에
...</p></div><footer class=entry-footer><span title='2018-01-04 18:00:42 +0900 +0900'>1월 4, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 6086번, 최대 유량" href=https://jaejin0me.github.io/post/posts10/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>디자인 패턴 - 싱글턴 패턴</h2></header><div class=entry-content><p>싱글턴 패턴 인스턴스가 하나 만들어지고 어디서든지 인스턴스에 접근하기 위한 패턴
간단히 인스턴스에 접근하기 위한 get메소드, 기본적인 생성자, 인스턴스 멤버변수로 구성된다고 가정해보자.
...</p></div><footer class=entry-footer><span title='2018-01-01 11:31:42 +0900 +0900'>1월 1, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 디자인 패턴 - 싱글턴 패턴" href=https://jaejin0me.github.io/post/posts111/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>프로그래머스 - 사칙연산</h2></header><div class=entry-content><p>완전 초급용은 아닌 dp
이제 자신감이 좀 붙는고만
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import java.awt.Point; import java.util.HashMap; class Solution { static int[] intarr; public static int solution(String arr[]) { HashMap&lt;Point,Integer> dmax = new HashMap&lt;Point,Integer>(); HashMap&lt;Point,Integer> dmin = new HashMap&lt;Point,Integer>(); int len = arr.length; int max_temp = 0; int min_temp = 0; int max = 0; int min = 0; // 숫자로 변환, 및 기본값 세팅 intarr = new int[arr.length]; for(int i=0;i&lt;len;i++) { if(arr[i].equals("+")) { intarr[i] = 1001; // 플러스는 1001로 치환 } else if (arr[i].equals("-")) { intarr[i] = 1002;// 마이너스는 1002로 치환 } else { intarr[i] = Integer.parseInt(arr[i]); dmax.put(new Point(i,i), intarr[i]); dmin.put(new Point(i,i), intarr[i]); } } for(int i=2;i&lt;len;i+=2) { //하나의 연산을 포함하는 길이에서 입력의 모든 연산을 포함하는 길이가 될때까지, 길이의 증가는 +2씩(연산자 하나, 숫자하나) for(int j=0;j+i&lt;len;j+=2) { // 0자리 부터 시작해서 해당 순서의 길이까지 반복, 최대 길이를 넘지 않아야 함 max_temp = 0; min_temp = 0; max = Integer.MIN_VALUE; min = Integer.MAX_VALUE; for(int k=j;k&lt;i+j;k++) { // +,- 연산이 오는 경우 범위에서의 min과 max를 구한다. if(intarr[k]==1001) { max_temp = dmax.get(new Point(j,k-1)) + dmax.get(new Point(k+1,i+j)); min_temp = dmin.get(new Point(j,k-1)) + dmin.get(new Point(k+1,i+j)); if(max_temp>max) max = max_temp; if(min_temp&lt;min) min = min_temp; } else if(intarr[k]==1002) { max_temp = dmax.get(new Point(j,k-1)) - dmin.get(new Point(k+1,i+j)); min_temp = dmin.get(new Point(j,k-1)) - dmax.get(new Point(k+1,i+j)); if(max_temp>max) max = max_temp; if(min_temp&lt;min) min = min_temp; } } dmax.put(new Point(j,j+i), max); dmin.put(new Point(j,j+i), min); } } return dmax.get((new Point(0,len-1))); } }</p></div><footer class=entry-footer><span title='2017-12-31 16:20:42 +0800 +0800'>12월 31, 2017</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 프로그래머스 - 사칙연산" href=https://jaejin0me.github.io/post/posts53/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>프로그래머스 - 게임 맵 최단거리</h2></header><div class=entry-content><p>BFS로 구현했는데, 효율성 테스트에서 자꾸 시간초과가 나서 고민했던 문제
알고보니 중복방문을 방지하기 위한 코드가 없었음.. 방문 확인의 중요성!!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import java.util.LinkedList; import java.util.Queue; import java.awt.Point; class Solution { public static int solution(int[][] maps) { int X = maps[0].length; int Y = maps.length; boolean[][] visited = new boolean[Y][X]; Queue&lt;Point> q = new LinkedList&lt;Point>(); int x = 0; int y = 0; int size = 0; int cnt = 0; Point p = new Point(); q.add(new Point(Y-1,X-1)); while(q.isEmpty()==false) { size = q.size(); cnt++; for(int i=0;i&lt;size;i++) { p = q.peek(); x = p.y; y = p.x; q.remove(); if(visited[y][x]==true) continue; maps[y][x] = 0; visited[y][x] = true; if(x==0 && y==0) { return cnt; } if(x-1>-1 && maps[y][x-1]==1) { //왼쪽 한칸 q.add(new Point(y,x-1)); } if(x+1&lt;X && maps[y][x+1]==1) { //오른쪽 한칸 q.add(new Point(y,x+1)); } if(y-1>-1 && maps[y-1][x]==1) { //위쪽 한칸 q.add(new Point(y-1,x)); } if(y+1&lt;Y && maps[y+1][x]==1) { //아래쪽 한칸 q.add(new Point(y+1,x)); } } } return -1; } }</p></div><footer class=entry-footer><span title='2017-12-27 16:42:42 +0800 +0800'>12월 27, 2017</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 프로그래머스 - 게임 맵 최단거리" href=https://jaejin0me.github.io/post/posts52/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>프로그래머스 - 폰켓몬</h2></header><div class=entry-content><p>문제를 잘 파악하면 어렵지 않은 문제
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.HashSet; import java.util.Iterator; public class Solution { public int solution(int[] nums) { HashSet&lt;Integer> abc = new HashSet&lt;Integer>(); for(int i=0;i&lt;nums.length;i++) { abc.add(nums[i]); } if(abc.size()>nums.length/2) return nums.length/2; else return abc.size(); } }</p></div><footer class=entry-footer><span title='2017-12-27 16:42:42 +0800 +0800'>12월 27, 2017</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 프로그래머스 - 폰켓몬" href=https://jaejin0me.github.io/post/posts51/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>다시</h2></header><div class=entry-content><p>Start</p></div><footer class=entry-footer><span title='2017-12-27 16:42:42 +0900 +0900'>12월 27, 2017</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 다시" href=https://jaejin0me.github.io/post/posts79/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://jaejin0me.github.io/post/page/18/>«&nbsp;이전 페이지&nbsp;
</a><a class=next href=https://jaejin0me.github.io/post/page/20/>다음 페이지&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>