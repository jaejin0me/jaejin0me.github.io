<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>백준알고리즘 5651번 - 완전 중요한 간선 | Jaejin's blog</title><meta name=keywords content="algorithm,네트워크플로우"><meta name=description content="중요한 간선을 찾는 코드에서 prev2[next2.to] 가 되어있어야 하는데 prev2[curr2]로 되어 있는 것을 발견하지 못해 푸는데 오래 걸린 문제이다. 중요한 간선의 여부는 최대"><meta name=author content="Jaejin Jang"><link rel=canonical href=https://jaejin0me.github.io/post/posts63/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T",{anonymize_ip:!0})}</script><meta property="og:title" content="백준알고리즘 5651번 - 완전 중요한 간선"><meta property="og:description" content="중요한 간선을 찾는 코드에서 prev2[next2.to] 가 되어있어야 하는데 prev2[curr2]로 되어 있는 것을 발견하지 못해 푸는데 오래 걸린 문제이다. 중요한 간선의 여부는 최대"><meta property="og:type" content="article"><meta property="og:url" content="https://jaejin0me.github.io/post/posts63/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-02-11T12:20:42+09:00"><meta property="article:modified_time" content="2018-02-11T12:20:42+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="백준알고리즘 5651번 - 완전 중요한 간선"><meta name=twitter:description content="중요한 간선을 찾는 코드에서 prev2[next2.to] 가 되어있어야 하는데 prev2[curr2]로 되어 있는 것을 발견하지 못해 푸는데 오래 걸린 문제이다. 중요한 간선의 여부는 최대"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://jaejin0me.github.io/post/"},{"@type":"ListItem","position":3,"name":"백준알고리즘 5651번 - 완전 중요한 간선","item":"https://jaejin0me.github.io/post/posts63/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"백준알고리즘 5651번 - 완전 중요한 간선","name":"백준알고리즘 5651번 - 완전 중요한 간선","description":"중요한 간선을 찾는 코드에서 prev2[next2.to] 가 되어있어야 하는데 prev2[curr2]로 되어 있는 것을 발견하지 못해 푸는데 오래 걸린 문제이다. 중요한 간선의 여부는 최대","keywords":["algorithm","네트워크플로우"],"articleBody":"중요한 간선을 찾는 코드에서 prev2[next2.to] 가 되어있어야 하는데 prev2[curr2]로 되어 있는 것을 발견하지 못해 푸는데 오래 걸린 문제이다.\n중요한 간선의 여부는 최대유량은 찾은 후에 입력 간선들 중에 u-\u003ev로 유량을 흘릴수 없는 경우 중요한 간선이라고 판단하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 import java.awt.Point; import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.Queue; import java.util.Scanner; import java.util.StringTokenizer; class edge { int to; int flow; int cap; edge rever; edge() { this(0, 0, 0, null); } edge(int ar_to, int ar_flow, int ar_cap, edge ar_rever) { to = ar_to; flow = ar_flow; cap = ar_cap; rever = ar_rever; } int residu() { return cap - flow; } void addflow(int ar_flow) { flow += ar_flow; rever.flow -= ar_flow; } } public class Main { public static void main(String[] args) throws IOException { // BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); // BufferedReader br = new BufferedReader(new FileReader(\"input.txt\")); // StringTokenizer st = new StringTokenizer(br.readLine()); Scanner sc = new Scanner(System.in); int K = sc.nextInt(); // 테스트 케이스 K번 반복한다 for (int i = 0; i \u003c K; i++) { int N = sc.nextInt(); int M = sc.nextInt(); edge f_edge = null; edge b_edge = null; int u = 0, v = 0, c = 0; int S = 0; int E = N - 1; int mf = 0; int cnt = 0; ArrayList edge_list = new ArrayList(); // 정점의 수만큼 인접리스트 생성 ArrayList[] adj = new ArrayList[N]; for (int j = 0; j \u003c N; j++) { adj[j] = new ArrayList(); } // 간선 입력 받기 for (int j = 0; j \u003c M; j++) { u = sc.nextInt() - 1; v = sc.nextInt() - 1; edge_list.add(new Point(u,v)); c = sc.nextInt(); f_edge = new edge(v, 0, c, null); b_edge = new edge(u, 0, 0, f_edge); f_edge.rever = b_edge; adj[u].add(f_edge); adj[v].add(b_edge); } // 최대 유량 찾기, 에드몬드 카프 while (true) { int[] prev = new int[N]; edge[] path = new edge[N]; Arrays.fill(prev, -1); Queue q = new LinkedList(); q.add(S); label1: while (!q.isEmpty() \u0026\u0026 prev[E] == -1) { int curr = q.poll(); for (int j = 0; j \u003c adj[curr].size(); j++) { edge next = adj[curr].get(j); if (next.residu() \u003e 0 \u0026\u0026 prev[next.to] == -1) { q.add(next.to); prev[next.to] = curr; path[next.to] = next; if(next.to == E) break label1; } } } // 입력 간선 리스트 중에서 중요한 간선을 확인함 if (prev[E] == -1) { for(int j=0;j","wordCount":"787","inLanguage":"ko","datePublished":"2018-02-11T12:20:42+09:00","dateModified":"2018-02-11T12:20:42+09:00","author":{"@type":"Person","name":"Jaejin Jang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jaejin0me.github.io/post/posts63/"},"publisher":{"@type":"Organization","name":"Jaejin's blog","logo":{"@type":"ImageObject","url":"https://jaejin0me.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>백준알고리즘 5651번 - 완전 중요한 간선</h1><div class=post-meta><span title='2018-02-11 12:20:42 +0900 +0900'>2월 11, 2018</span>&nbsp;·&nbsp;Jaejin Jang</div></header><div class=post-content><p>중요한 간선을 찾는 코드에서 prev2[next2.to] 가 되어있어야 하는데 prev2[curr2]로 되어 있는 것을 발견하지 못해 푸는데 오래 걸린 문제이다.</p><p>중요한 간선의 여부는 최대유량은 찾은 후에 입력 간선들 중에 u->v로 유량을 흘릴수 없는 경우 중요한 간선이라고 판단하였다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>import java.awt.Point;
</span></span><span class=line><span class=cl>import java.io.BufferedReader;
</span></span><span class=line><span class=cl>import java.io.FileReader;
</span></span><span class=line><span class=cl>import java.io.IOException;
</span></span><span class=line><span class=cl>import java.io.InputStream;
</span></span><span class=line><span class=cl>import java.io.InputStreamReader;
</span></span><span class=line><span class=cl>import java.util.ArrayList;
</span></span><span class=line><span class=cl>import java.util.Arrays;
</span></span><span class=line><span class=cl>import java.util.LinkedList;
</span></span><span class=line><span class=cl>import java.util.Queue;
</span></span><span class=line><span class=cl>import java.util.Scanner;
</span></span><span class=line><span class=cl>import java.util.StringTokenizer;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>class edge {
</span></span><span class=line><span class=cl>	int to;
</span></span><span class=line><span class=cl>	int flow;
</span></span><span class=line><span class=cl>	int cap;
</span></span><span class=line><span class=cl>	edge rever;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	edge() {
</span></span><span class=line><span class=cl>		this(0, 0, 0, null);
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	edge(int ar_to, int ar_flow, int ar_cap, edge ar_rever) {
</span></span><span class=line><span class=cl>		to = ar_to;
</span></span><span class=line><span class=cl>		flow = ar_flow;
</span></span><span class=line><span class=cl>		cap = ar_cap;
</span></span><span class=line><span class=cl>		rever = ar_rever;
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	int residu() {
</span></span><span class=line><span class=cl>		return cap - flow;
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	void addflow(int ar_flow) {
</span></span><span class=line><span class=cl>		flow += ar_flow;
</span></span><span class=line><span class=cl>		rever.flow -= ar_flow;
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>public class Main {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	public static void main(String[] args) throws IOException {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		// BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
</span></span><span class=line><span class=cl>		// BufferedReader br = new BufferedReader(new FileReader(&#34;input.txt&#34;));
</span></span><span class=line><span class=cl>		// StringTokenizer st = new StringTokenizer(br.readLine());
</span></span><span class=line><span class=cl>		Scanner sc = new Scanner(System.in);
</span></span><span class=line><span class=cl>		int K = sc.nextInt();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		// 테스트 케이스 K번 반복한다
</span></span><span class=line><span class=cl>		for (int i = 0; i &lt; K; i++) {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			int N = sc.nextInt();
</span></span><span class=line><span class=cl>			int M = sc.nextInt();
</span></span><span class=line><span class=cl>			edge f_edge = null;
</span></span><span class=line><span class=cl>			edge b_edge = null;
</span></span><span class=line><span class=cl>			int u = 0, v = 0, c = 0;
</span></span><span class=line><span class=cl>			int S = 0;
</span></span><span class=line><span class=cl>			int E = N - 1;
</span></span><span class=line><span class=cl>			int mf = 0;
</span></span><span class=line><span class=cl>			int cnt = 0;
</span></span><span class=line><span class=cl>			ArrayList&lt;Point&gt; edge_list = new ArrayList&lt;Point&gt;();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			// 정점의 수만큼 인접리스트 생성
</span></span><span class=line><span class=cl>			ArrayList&lt;edge&gt;[] adj = new ArrayList[N];
</span></span><span class=line><span class=cl>			for (int j = 0; j &lt; N; j++) {
</span></span><span class=line><span class=cl>				adj[j] = new ArrayList&lt;edge&gt;();
</span></span><span class=line><span class=cl>			}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			// 간선 입력 받기
</span></span><span class=line><span class=cl>			for (int j = 0; j &lt; M; j++) {
</span></span><span class=line><span class=cl>				u = sc.nextInt() - 1;
</span></span><span class=line><span class=cl>				v = sc.nextInt() - 1;
</span></span><span class=line><span class=cl>				edge_list.add(new Point(u,v));
</span></span><span class=line><span class=cl>				c = sc.nextInt();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				f_edge = new edge(v, 0, c, null);
</span></span><span class=line><span class=cl>				b_edge = new edge(u, 0, 0, f_edge);
</span></span><span class=line><span class=cl>				f_edge.rever = b_edge;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				adj[u].add(f_edge);
</span></span><span class=line><span class=cl>				adj[v].add(b_edge);
</span></span><span class=line><span class=cl>			}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			// 최대 유량 찾기, 에드몬드 카프
</span></span><span class=line><span class=cl>			while (true) {
</span></span><span class=line><span class=cl>				int[] prev = new int[N];
</span></span><span class=line><span class=cl>				edge[] path = new edge[N];
</span></span><span class=line><span class=cl>				Arrays.fill(prev, -1);
</span></span><span class=line><span class=cl>				Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();
</span></span><span class=line><span class=cl>				q.add(S);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				label1: while (!q.isEmpty() &amp;&amp; prev[E] == -1) {
</span></span><span class=line><span class=cl>					int curr = q.poll();
</span></span><span class=line><span class=cl>					for (int j = 0; j &lt; adj[curr].size(); j++) {
</span></span><span class=line><span class=cl>						edge next = adj[curr].get(j);
</span></span><span class=line><span class=cl>						if (next.residu() &gt; 0 &amp;&amp; prev[next.to] == -1) {
</span></span><span class=line><span class=cl>							q.add(next.to);
</span></span><span class=line><span class=cl>							prev[next.to] = curr;
</span></span><span class=line><span class=cl>							path[next.to] = next;
</span></span><span class=line><span class=cl>							if(next.to == E) break label1;
</span></span><span class=line><span class=cl>						}
</span></span><span class=line><span class=cl>					}
</span></span><span class=line><span class=cl>				}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				// 입력 간선 리스트 중에서 중요한 간선을 확인함
</span></span><span class=line><span class=cl>				if (prev[E] == -1) {
</span></span><span class=line><span class=cl>					
</span></span><span class=line><span class=cl>					for(int j=0;j&lt;edge_list.size();j++) {
</span></span><span class=line><span class=cl>						Point temp = new Point();
</span></span><span class=line><span class=cl>						temp = edge_list.get(j);
</span></span><span class=line><span class=cl>						int S2 = temp.x;
</span></span><span class=line><span class=cl>						int E2 = temp.y;
</span></span><span class=line><span class=cl>						int[] prev2 = new int[N];
</span></span><span class=line><span class=cl>						Arrays.fill(prev2, -1);
</span></span><span class=line><span class=cl>						Queue&lt;Integer&gt; q2 = new LinkedList&lt;Integer&gt;();
</span></span><span class=line><span class=cl>						q2.add(S2);
</span></span><span class=line><span class=cl>						label2: while (!q2.isEmpty()) {
</span></span><span class=line><span class=cl>							int curr2 = q2.poll();
</span></span><span class=line><span class=cl>							for (int l = 0; l &lt; adj[curr2].size(); l++) {
</span></span><span class=line><span class=cl>								edge next2 = adj[curr2].get(l);
</span></span><span class=line><span class=cl>								if ( next2.residu() &gt; 0 &amp;&amp; prev2[next2.to] == -1) {
</span></span><span class=line><span class=cl>									q2.add(next2.to);
</span></span><span class=line><span class=cl>									prev2[next2.to] = curr2;
</span></span><span class=line><span class=cl>									if(prev2[E2] == next2.to) break label2;
</span></span><span class=line><span class=cl>								}
</span></span><span class=line><span class=cl>							}
</span></span><span class=line><span class=cl>						}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>						if (prev2[E2] == -1)
</span></span><span class=line><span class=cl>							cnt++;
</span></span><span class=line><span class=cl>						
</span></span><span class=line><span class=cl>					}
</span></span><span class=line><span class=cl>					
</span></span><span class=line><span class=cl>					System.out.println(cnt);
</span></span><span class=line><span class=cl>					break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				int flow = Integer.MAX_VALUE;
</span></span><span class=line><span class=cl>				for (int k = E; k != S; k = prev[k])
</span></span><span class=line><span class=cl>					flow = Math.min(flow, path[k].residu());
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				for (int k = E; k != S; k = prev[k])
</span></span><span class=line><span class=cl>					path[k].addflow(flow);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				mf += flow;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://jaejin0me.github.io/tags/algorithm/>algorithm</a></li><li><a href=https://jaejin0me.github.io/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C%EC%9A%B0/>네트워크플로우</a></li></ul></footer></article></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>