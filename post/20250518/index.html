<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>디자인 패턴의 아름다움 - 1. 개요 | Jaejin's blog</title>
<meta name=keywords content="디자인 패턴"><meta name=description content="1. 개요
1.1 코드 설계를 배우는 이유

효율적인 코드 작성 = 데이터 구조 + 알고리즘
유지 보수가 용이한 고품질 코드 = 코드 설계에 대한 지식

1.1.1 고품질의 코드 작성
1.1.2 복잡한 코드 개발 다루기

소프트웨어 개발 시 만나는 어려움의 유형 2가지


높은 수준의 기술을 필요로 하는 경우: 자율 주행, 비디오 인식, AI




높은 수준의 기술을 필요로 하지 않는 대규모 프로젝트: 이 책에서 다룰 내용



1.1.3 프로그래머의 기본 능력
1.1.4 경력 개발에 필요한 기술
1.2 코드 품질 평가 방법
1.2.1 유지 보수성

기존의 코드 설계를 손상하거나 새로운 버그를 발생시키지 않고도 빠르게 코드를 수정하거나 추가할 수 있는 상태
코드가 간결하고 가독성이 높으며 확장성이 높다면 코드의 유지 보수도 쉬움
코드가 명확하게 계층화되어 있으며, 높은 모듈성, 높은 응집도와 낮은 결합도를 가짐

1.2.2 가독성

훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 작성한다.
제가 중요하게 생각하는 것 중 하나

1.2.3 확장성

약간 수정하는 것만으로도 혹은 전혀 수정하지 않고도 확장을 통해 새로운 기능을 추가하는 것
요구 사항의 미래 변화에 대처할 수 있는 코드의 능력

1.2.4 유연성

추상적인 평가 기준이기 때문에 정의하기 쉽지 않음


확장을 위한 인터페이스가 준비되어 있음




기본적으로 재사용 가능한 많은 모듈과 클래스 등이 기존 코드에 추상화된 형태로 이미 제공




클래스가 다양한 사용 시나리오에 대응하고, 다양한 요구를 충족 가능



1.2.5 간결성

널리 알려진 KISS(Keep It Simple, Stupid) 원칙
많은 프로그래머는 단순한 코드에 복잡한 디자인 패턴을 도입하는 것을 좋아한다. 그러나 고수준의 프로그래머는 종종 간단한 방법으로 복잡한 문제를 해결한다.
저의 코딩 스타일 중 하나

1.2.6 재사용성

반복적인 코드 작성을 최소화하고 기존 코드를 재사용하는 것
단일 책임 원칙(single Responsibility principle)
DRY(Don&rsquo;t repeat yourself) 원칙

1.2.7 테스트 용이성

이 책에서 처음 보는 기준인데, 중요할 것 같네요.

1.3 고품질 코드를 작성하는 방법
1.3.1 객체지향

세 가지의 프로그래밍 패러다임(절차적, 함수형, 객체지향) 중에서 객체지향 프로그래밍이 가장 대중적임
이 책에서는 객체지향에 대해 마스터하는 것을 목표로 함

1.3.2 설계 원칙

각각의 설계 원칙이 어떤 문제와 응용 시나리오를 해결하는데 사용되는 것인지 파악해야 한다
모두 마스터해야만 설계 원칙을 프로젝트에 유연하고 적절하게 적용할 수 있다
설계 원칙은 디자인 패턴보다 더 보편적이고 중요한 것이다.

1.3.3 디자인 패턴

자주 접하게 되는 일부 설계 문제에 대해 요약된 솔루션 또는 설계 사상

1.3.4 코딩 규칙

주로 가독성 문제 해결

1.3.5 리팩터링 기법
1.4 과도한 설계를 피하는 방법
1.4.1 코드 설계의 원래 의도는 코드 품질을 향상시키는 것이다
1.4.2 코드 설계의 원칙은 앞에 문제가 있고, 뒤에 방안이 있다는 것이다
1.4.3 코드 설계의 응용 시나리오는 복잡한 코드에 적용되어야 한다

디자인 패턴을 적용하는 목적은 디커플링, 즉 더 나은 코드 구조를 사용하여 단일 책임을 위해 큰 조각을 작은 클래스로 분할하여 코드가 높은 응집도와 낮은 결합도의 특성을 충족하도록 하는 것이다.

1.4.4 지속적인 리팩토링은 과도한 설계를 효과적으로 방지할 수 있다

실현 가능성이 낮은 미래의 요구 사항을 위해 처음부터 디자인 패턴을 적용하기보다, 진짜 문제가 발생했을 때 이를 해결하기 위한 디자인 패턴을 사용하는 것을 고려하는 것이다.

1.4.5 특정 시나리오 외의 코드 설계에 대해 이야기하지 않는다"><meta name=author content="Jaejin Jang"><link rel=canonical href=https://jaejin0me.github.io/post/20250518/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://jaejin0me.github.io/post/20250518/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8691946909799297" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T")}</script><meta property="og:title" content="디자인 패턴의 아름다움 - 1. 개요"><meta property="og:description" content="1. 개요
1.1 코드 설계를 배우는 이유

효율적인 코드 작성 = 데이터 구조 + 알고리즘
유지 보수가 용이한 고품질 코드 = 코드 설계에 대한 지식

1.1.1 고품질의 코드 작성
1.1.2 복잡한 코드 개발 다루기

소프트웨어 개발 시 만나는 어려움의 유형 2가지


높은 수준의 기술을 필요로 하는 경우: 자율 주행, 비디오 인식, AI




높은 수준의 기술을 필요로 하지 않는 대규모 프로젝트: 이 책에서 다룰 내용



1.1.3 프로그래머의 기본 능력
1.1.4 경력 개발에 필요한 기술
1.2 코드 품질 평가 방법
1.2.1 유지 보수성

기존의 코드 설계를 손상하거나 새로운 버그를 발생시키지 않고도 빠르게 코드를 수정하거나 추가할 수 있는 상태
코드가 간결하고 가독성이 높으며 확장성이 높다면 코드의 유지 보수도 쉬움
코드가 명확하게 계층화되어 있으며, 높은 모듈성, 높은 응집도와 낮은 결합도를 가짐

1.2.2 가독성

훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 작성한다.
제가 중요하게 생각하는 것 중 하나

1.2.3 확장성

약간 수정하는 것만으로도 혹은 전혀 수정하지 않고도 확장을 통해 새로운 기능을 추가하는 것
요구 사항의 미래 변화에 대처할 수 있는 코드의 능력

1.2.4 유연성

추상적인 평가 기준이기 때문에 정의하기 쉽지 않음


확장을 위한 인터페이스가 준비되어 있음




기본적으로 재사용 가능한 많은 모듈과 클래스 등이 기존 코드에 추상화된 형태로 이미 제공




클래스가 다양한 사용 시나리오에 대응하고, 다양한 요구를 충족 가능



1.2.5 간결성

널리 알려진 KISS(Keep It Simple, Stupid) 원칙
많은 프로그래머는 단순한 코드에 복잡한 디자인 패턴을 도입하는 것을 좋아한다. 그러나 고수준의 프로그래머는 종종 간단한 방법으로 복잡한 문제를 해결한다.
저의 코딩 스타일 중 하나

1.2.6 재사용성

반복적인 코드 작성을 최소화하고 기존 코드를 재사용하는 것
단일 책임 원칙(single Responsibility principle)
DRY(Don&rsquo;t repeat yourself) 원칙

1.2.7 테스트 용이성

이 책에서 처음 보는 기준인데, 중요할 것 같네요.

1.3 고품질 코드를 작성하는 방법
1.3.1 객체지향

세 가지의 프로그래밍 패러다임(절차적, 함수형, 객체지향) 중에서 객체지향 프로그래밍이 가장 대중적임
이 책에서는 객체지향에 대해 마스터하는 것을 목표로 함

1.3.2 설계 원칙

각각의 설계 원칙이 어떤 문제와 응용 시나리오를 해결하는데 사용되는 것인지 파악해야 한다
모두 마스터해야만 설계 원칙을 프로젝트에 유연하고 적절하게 적용할 수 있다
설계 원칙은 디자인 패턴보다 더 보편적이고 중요한 것이다.

1.3.3 디자인 패턴

자주 접하게 되는 일부 설계 문제에 대해 요약된 솔루션 또는 설계 사상

1.3.4 코딩 규칙

주로 가독성 문제 해결

1.3.5 리팩터링 기법
1.4 과도한 설계를 피하는 방법
1.4.1 코드 설계의 원래 의도는 코드 품질을 향상시키는 것이다
1.4.2 코드 설계의 원칙은 앞에 문제가 있고, 뒤에 방안이 있다는 것이다
1.4.3 코드 설계의 응용 시나리오는 복잡한 코드에 적용되어야 한다

디자인 패턴을 적용하는 목적은 디커플링, 즉 더 나은 코드 구조를 사용하여 단일 책임을 위해 큰 조각을 작은 클래스로 분할하여 코드가 높은 응집도와 낮은 결합도의 특성을 충족하도록 하는 것이다.

1.4.4 지속적인 리팩토링은 과도한 설계를 효과적으로 방지할 수 있다

실현 가능성이 낮은 미래의 요구 사항을 위해 처음부터 디자인 패턴을 적용하기보다, 진짜 문제가 발생했을 때 이를 해결하기 위한 디자인 패턴을 사용하는 것을 고려하는 것이다.

1.4.5 특정 시나리오 외의 코드 설계에 대해 이야기하지 않는다"><meta property="og:type" content="article"><meta property="og:url" content="https://jaejin0me.github.io/post/20250518/"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-05-18T14:30:00+09:00"><meta property="article:modified_time" content="2025-05-18T14:30:00+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="디자인 패턴의 아름다움 - 1. 개요"><meta name=twitter:description content="1. 개요
1.1 코드 설계를 배우는 이유

효율적인 코드 작성 = 데이터 구조 + 알고리즘
유지 보수가 용이한 고품질 코드 = 코드 설계에 대한 지식

1.1.1 고품질의 코드 작성
1.1.2 복잡한 코드 개발 다루기

소프트웨어 개발 시 만나는 어려움의 유형 2가지


높은 수준의 기술을 필요로 하는 경우: 자율 주행, 비디오 인식, AI




높은 수준의 기술을 필요로 하지 않는 대규모 프로젝트: 이 책에서 다룰 내용



1.1.3 프로그래머의 기본 능력
1.1.4 경력 개발에 필요한 기술
1.2 코드 품질 평가 방법
1.2.1 유지 보수성

기존의 코드 설계를 손상하거나 새로운 버그를 발생시키지 않고도 빠르게 코드를 수정하거나 추가할 수 있는 상태
코드가 간결하고 가독성이 높으며 확장성이 높다면 코드의 유지 보수도 쉬움
코드가 명확하게 계층화되어 있으며, 높은 모듈성, 높은 응집도와 낮은 결합도를 가짐

1.2.2 가독성

훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 작성한다.
제가 중요하게 생각하는 것 중 하나

1.2.3 확장성

약간 수정하는 것만으로도 혹은 전혀 수정하지 않고도 확장을 통해 새로운 기능을 추가하는 것
요구 사항의 미래 변화에 대처할 수 있는 코드의 능력

1.2.4 유연성

추상적인 평가 기준이기 때문에 정의하기 쉽지 않음


확장을 위한 인터페이스가 준비되어 있음




기본적으로 재사용 가능한 많은 모듈과 클래스 등이 기존 코드에 추상화된 형태로 이미 제공




클래스가 다양한 사용 시나리오에 대응하고, 다양한 요구를 충족 가능



1.2.5 간결성

널리 알려진 KISS(Keep It Simple, Stupid) 원칙
많은 프로그래머는 단순한 코드에 복잡한 디자인 패턴을 도입하는 것을 좋아한다. 그러나 고수준의 프로그래머는 종종 간단한 방법으로 복잡한 문제를 해결한다.
저의 코딩 스타일 중 하나

1.2.6 재사용성

반복적인 코드 작성을 최소화하고 기존 코드를 재사용하는 것
단일 책임 원칙(single Responsibility principle)
DRY(Don&rsquo;t repeat yourself) 원칙

1.2.7 테스트 용이성

이 책에서 처음 보는 기준인데, 중요할 것 같네요.

1.3 고품질 코드를 작성하는 방법
1.3.1 객체지향

세 가지의 프로그래밍 패러다임(절차적, 함수형, 객체지향) 중에서 객체지향 프로그래밍이 가장 대중적임
이 책에서는 객체지향에 대해 마스터하는 것을 목표로 함

1.3.2 설계 원칙

각각의 설계 원칙이 어떤 문제와 응용 시나리오를 해결하는데 사용되는 것인지 파악해야 한다
모두 마스터해야만 설계 원칙을 프로젝트에 유연하고 적절하게 적용할 수 있다
설계 원칙은 디자인 패턴보다 더 보편적이고 중요한 것이다.

1.3.3 디자인 패턴

자주 접하게 되는 일부 설계 문제에 대해 요약된 솔루션 또는 설계 사상

1.3.4 코딩 규칙

주로 가독성 문제 해결

1.3.5 리팩터링 기법
1.4 과도한 설계를 피하는 방법
1.4.1 코드 설계의 원래 의도는 코드 품질을 향상시키는 것이다
1.4.2 코드 설계의 원칙은 앞에 문제가 있고, 뒤에 방안이 있다는 것이다
1.4.3 코드 설계의 응용 시나리오는 복잡한 코드에 적용되어야 한다

디자인 패턴을 적용하는 목적은 디커플링, 즉 더 나은 코드 구조를 사용하여 단일 책임을 위해 큰 조각을 작은 클래스로 분할하여 코드가 높은 응집도와 낮은 결합도의 특성을 충족하도록 하는 것이다.

1.4.4 지속적인 리팩토링은 과도한 설계를 효과적으로 방지할 수 있다

실현 가능성이 낮은 미래의 요구 사항을 위해 처음부터 디자인 패턴을 적용하기보다, 진짜 문제가 발생했을 때 이를 해결하기 위한 디자인 패턴을 사용하는 것을 고려하는 것이다.

1.4.5 특정 시나리오 외의 코드 설계에 대해 이야기하지 않는다"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jaejin0me.github.io/post/"},{"@type":"ListItem","position":2,"name":"디자인 패턴의 아름다움 - 1. 개요","item":"https://jaejin0me.github.io/post/20250518/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"디자인 패턴의 아름다움 - 1. 개요","name":"디자인 패턴의 아름다움 - 1. 개요","description":"1. 개요 1.1 코드 설계를 배우는 이유 효율적인 코드 작성 = 데이터 구조 + 알고리즘 유지 보수가 용이한 고품질 코드 = 코드 설계에 대한 지식 1.1.1 고품질의 코드 작성 1.1.2 복잡한 코드 개발 다루기 소프트웨어 개발 시 만나는 어려움의 유형 2가지 높은 수준의 기술을 필요로 하는 경우: 자율 주행, 비디오 인식, AI 높은 수준의 기술을 필요로 하지 않는 대규모 프로젝트: 이 책에서 다룰 내용 1.1.3 프로그래머의 기본 능력 1.1.4 경력 개발에 필요한 기술 1.2 코드 품질 평가 방법 1.2.1 유지 보수성 기존의 코드 설계를 손상하거나 새로운 버그를 발생시키지 않고도 빠르게 코드를 수정하거나 추가할 수 있는 상태 코드가 간결하고 가독성이 높으며 확장성이 높다면 코드의 유지 보수도 쉬움 코드가 명확하게 계층화되어 있으며, 높은 모듈성, 높은 응집도와 낮은 결합도를 가짐 1.2.2 가독성 훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 작성한다. 제가 중요하게 생각하는 것 중 하나 1.2.3 확장성 약간 수정하는 것만으로도 혹은 전혀 수정하지 않고도 확장을 통해 새로운 기능을 추가하는 것 요구 사항의 미래 변화에 대처할 수 있는 코드의 능력 1.2.4 유연성 추상적인 평가 기준이기 때문에 정의하기 쉽지 않음 확장을 위한 인터페이스가 준비되어 있음 기본적으로 재사용 가능한 많은 모듈과 클래스 등이 기존 코드에 추상화된 형태로 이미 제공 클래스가 다양한 사용 시나리오에 대응하고, 다양한 요구를 충족 가능 1.2.5 간결성 널리 알려진 KISS(Keep It Simple, Stupid) 원칙 많은 프로그래머는 단순한 코드에 복잡한 디자인 패턴을 도입하는 것을 좋아한다. 그러나 고수준의 프로그래머는 종종 간단한 방법으로 복잡한 문제를 해결한다. 저의 코딩 스타일 중 하나 1.2.6 재사용성 반복적인 코드 작성을 최소화하고 기존 코드를 재사용하는 것 단일 책임 원칙(single Responsibility principle) DRY(Don\u0026rsquo;t repeat yourself) 원칙 1.2.7 테스트 용이성 이 책에서 처음 보는 기준인데, 중요할 것 같네요. 1.3 고품질 코드를 작성하는 방법 1.3.1 객체지향 세 가지의 프로그래밍 패러다임(절차적, 함수형, 객체지향) 중에서 객체지향 프로그래밍이 가장 대중적임 이 책에서는 객체지향에 대해 마스터하는 것을 목표로 함 1.3.2 설계 원칙 각각의 설계 원칙이 어떤 문제와 응용 시나리오를 해결하는데 사용되는 것인지 파악해야 한다 모두 마스터해야만 설계 원칙을 프로젝트에 유연하고 적절하게 적용할 수 있다 설계 원칙은 디자인 패턴보다 더 보편적이고 중요한 것이다. 1.3.3 디자인 패턴 자주 접하게 되는 일부 설계 문제에 대해 요약된 솔루션 또는 설계 사상 1.3.4 코딩 규칙 주로 가독성 문제 해결 1.3.5 리팩터링 기법 1.4 과도한 설계를 피하는 방법 1.4.1 코드 설계의 원래 의도는 코드 품질을 향상시키는 것이다 1.4.2 코드 설계의 원칙은 앞에 문제가 있고, 뒤에 방안이 있다는 것이다 1.4.3 코드 설계의 응용 시나리오는 복잡한 코드에 적용되어야 한다 디자인 패턴을 적용하는 목적은 디커플링, 즉 더 나은 코드 구조를 사용하여 단일 책임을 위해 큰 조각을 작은 클래스로 분할하여 코드가 높은 응집도와 낮은 결합도의 특성을 충족하도록 하는 것이다. 1.4.4 지속적인 리팩토링은 과도한 설계를 효과적으로 방지할 수 있다 실현 가능성이 낮은 미래의 요구 사항을 위해 처음부터 디자인 패턴을 적용하기보다, 진짜 문제가 발생했을 때 이를 해결하기 위한 디자인 패턴을 사용하는 것을 고려하는 것이다. 1.4.5 특정 시나리오 외의 코드 설계에 대해 이야기하지 않는다","keywords":["디자인 패턴"],"articleBody":"1. 개요 1.1 코드 설계를 배우는 이유 효율적인 코드 작성 = 데이터 구조 + 알고리즘 유지 보수가 용이한 고품질 코드 = 코드 설계에 대한 지식 1.1.1 고품질의 코드 작성 1.1.2 복잡한 코드 개발 다루기 소프트웨어 개발 시 만나는 어려움의 유형 2가지 높은 수준의 기술을 필요로 하는 경우: 자율 주행, 비디오 인식, AI 높은 수준의 기술을 필요로 하지 않는 대규모 프로젝트: 이 책에서 다룰 내용 1.1.3 프로그래머의 기본 능력 1.1.4 경력 개발에 필요한 기술 1.2 코드 품질 평가 방법 1.2.1 유지 보수성 기존의 코드 설계를 손상하거나 새로운 버그를 발생시키지 않고도 빠르게 코드를 수정하거나 추가할 수 있는 상태 코드가 간결하고 가독성이 높으며 확장성이 높다면 코드의 유지 보수도 쉬움 코드가 명확하게 계층화되어 있으며, 높은 모듈성, 높은 응집도와 낮은 결합도를 가짐 1.2.2 가독성 훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 작성한다. 제가 중요하게 생각하는 것 중 하나 1.2.3 확장성 약간 수정하는 것만으로도 혹은 전혀 수정하지 않고도 확장을 통해 새로운 기능을 추가하는 것 요구 사항의 미래 변화에 대처할 수 있는 코드의 능력 1.2.4 유연성 추상적인 평가 기준이기 때문에 정의하기 쉽지 않음 확장을 위한 인터페이스가 준비되어 있음 기본적으로 재사용 가능한 많은 모듈과 클래스 등이 기존 코드에 추상화된 형태로 이미 제공 클래스가 다양한 사용 시나리오에 대응하고, 다양한 요구를 충족 가능 1.2.5 간결성 널리 알려진 KISS(Keep It Simple, Stupid) 원칙 많은 프로그래머는 단순한 코드에 복잡한 디자인 패턴을 도입하는 것을 좋아한다. 그러나 고수준의 프로그래머는 종종 간단한 방법으로 복잡한 문제를 해결한다. 저의 코딩 스타일 중 하나 1.2.6 재사용성 반복적인 코드 작성을 최소화하고 기존 코드를 재사용하는 것 단일 책임 원칙(single Responsibility principle) DRY(Don’t repeat yourself) 원칙 1.2.7 테스트 용이성 이 책에서 처음 보는 기준인데, 중요할 것 같네요. 1.3 고품질 코드를 작성하는 방법 1.3.1 객체지향 세 가지의 프로그래밍 패러다임(절차적, 함수형, 객체지향) 중에서 객체지향 프로그래밍이 가장 대중적임 이 책에서는 객체지향에 대해 마스터하는 것을 목표로 함 1.3.2 설계 원칙 각각의 설계 원칙이 어떤 문제와 응용 시나리오를 해결하는데 사용되는 것인지 파악해야 한다 모두 마스터해야만 설계 원칙을 프로젝트에 유연하고 적절하게 적용할 수 있다 설계 원칙은 디자인 패턴보다 더 보편적이고 중요한 것이다. 1.3.3 디자인 패턴 자주 접하게 되는 일부 설계 문제에 대해 요약된 솔루션 또는 설계 사상 1.3.4 코딩 규칙 주로 가독성 문제 해결 1.3.5 리팩터링 기법 1.4 과도한 설계를 피하는 방법 1.4.1 코드 설계의 원래 의도는 코드 품질을 향상시키는 것이다 1.4.2 코드 설계의 원칙은 앞에 문제가 있고, 뒤에 방안이 있다는 것이다 1.4.3 코드 설계의 응용 시나리오는 복잡한 코드에 적용되어야 한다 디자인 패턴을 적용하는 목적은 디커플링, 즉 더 나은 코드 구조를 사용하여 단일 책임을 위해 큰 조각을 작은 클래스로 분할하여 코드가 높은 응집도와 낮은 결합도의 특성을 충족하도록 하는 것이다. 1.4.4 지속적인 리팩토링은 과도한 설계를 효과적으로 방지할 수 있다 실현 가능성이 낮은 미래의 요구 사항을 위해 처음부터 디자인 패턴을 적용하기보다, 진짜 문제가 발생했을 때 이를 해결하기 위한 디자인 패턴을 사용하는 것을 고려하는 것이다. 1.4.5 특정 시나리오 외의 코드 설계에 대해 이야기하지 않는다 ","wordCount":"1227","inLanguage":"ko","datePublished":"2025-05-18T14:30:00+09:00","dateModified":"2025-05-18T14:30:00+09:00","author":{"@type":"Person","name":"Jaejin Jang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jaejin0me.github.io/post/20250518/"},"publisher":{"@type":"Organization","name":"Jaejin's blog","logo":{"@type":"ImageObject","url":"https://jaejin0me.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io/ accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">디자인 패턴의 아름다움 - 1. 개요</h1><div class=post-meta><span title='2025-05-18 14:30:00 +0900 +0900'>5월 18, 2025</span>&nbsp;·&nbsp;Jaejin Jang</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#1-%ea%b0%9c%ec%9a%94 aria-label="1. 개요">1. 개요</a><ul><li><a href=#11-%ec%bd%94%eb%93%9c-%ec%84%a4%ea%b3%84%eb%a5%bc-%eb%b0%b0%ec%9a%b0%eb%8a%94-%ec%9d%b4%ec%9c%a0 aria-label="1.1 코드 설계를 배우는 이유">1.1 코드 설계를 배우는 이유</a><ul><li><a href=#111-%ea%b3%a0%ed%92%88%ec%a7%88%ec%9d%98-%ec%bd%94%eb%93%9c-%ec%9e%91%ec%84%b1 aria-label="1.1.1 고품질의 코드 작성">1.1.1 고품질의 코드 작성</a></li><li><a href=#112-%eb%b3%b5%ec%9e%a1%ed%95%9c-%ec%bd%94%eb%93%9c-%ea%b0%9c%eb%b0%9c-%eb%8b%a4%eb%a3%a8%ea%b8%b0 aria-label="1.1.2 복잡한 코드 개발 다루기">1.1.2 복잡한 코드 개발 다루기</a></li><li><a href=#113-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%a8%b8%ec%9d%98-%ea%b8%b0%eb%b3%b8-%eb%8a%a5%eb%a0%a5 aria-label="1.1.3 프로그래머의 기본 능력">1.1.3 프로그래머의 기본 능력</a></li><li><a href=#114-%ea%b2%bd%eb%a0%a5-%ea%b0%9c%eb%b0%9c%ec%97%90-%ed%95%84%ec%9a%94%ed%95%9c-%ea%b8%b0%ec%88%a0 aria-label="1.1.4 경력 개발에 필요한 기술">1.1.4 경력 개발에 필요한 기술</a></li></ul></li><li><a href=#12-%ec%bd%94%eb%93%9c-%ed%92%88%ec%a7%88-%ed%8f%89%ea%b0%80-%eb%b0%a9%eb%b2%95 aria-label="1.2 코드 품질 평가 방법">1.2 코드 품질 평가 방법</a><ul><li><a href=#121-%ec%9c%a0%ec%a7%80-%eb%b3%b4%ec%88%98%ec%84%b1 aria-label="1.2.1 유지 보수성">1.2.1 유지 보수성</a></li><li><a href=#122-%ea%b0%80%eb%8f%85%ec%84%b1 aria-label="1.2.2 가독성">1.2.2 가독성</a></li><li><a href=#123-%ed%99%95%ec%9e%a5%ec%84%b1 aria-label="1.2.3 확장성">1.2.3 확장성</a></li><li><a href=#124-%ec%9c%a0%ec%97%b0%ec%84%b1 aria-label="1.2.4 유연성">1.2.4 유연성</a></li><li><a href=#125-%ea%b0%84%ea%b2%b0%ec%84%b1 aria-label="1.2.5 간결성">1.2.5 간결성</a></li><li><a href=#126-%ec%9e%ac%ec%82%ac%ec%9a%a9%ec%84%b1 aria-label="1.2.6 재사용성">1.2.6 재사용성</a></li><li><a href=#127-%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%9a%a9%ec%9d%b4%ec%84%b1 aria-label="1.2.7 테스트 용이성">1.2.7 테스트 용이성</a></li></ul></li><li><a href=#13-%ea%b3%a0%ed%92%88%ec%a7%88-%ec%bd%94%eb%93%9c%eb%a5%bc-%ec%9e%91%ec%84%b1%ed%95%98%eb%8a%94-%eb%b0%a9%eb%b2%95 aria-label="1.3 고품질 코드를 작성하는 방법">1.3 고품질 코드를 작성하는 방법</a><ul><li><a href=#131-%ea%b0%9d%ec%b2%b4%ec%a7%80%ed%96%a5 aria-label="1.3.1 객체지향">1.3.1 객체지향</a></li><li><a href=#132-%ec%84%a4%ea%b3%84-%ec%9b%90%ec%b9%99 aria-label="1.3.2 설계 원칙">1.3.2 설계 원칙</a></li><li><a href=#133-%eb%94%94%ec%9e%90%ec%9d%b8-%ed%8c%a8%ed%84%b4 aria-label="1.3.3 디자인 패턴">1.3.3 디자인 패턴</a></li><li><a href=#134-%ec%bd%94%eb%94%a9-%ea%b7%9c%ec%b9%99 aria-label="1.3.4 코딩 규칙">1.3.4 코딩 규칙</a></li><li><a href=#135-%eb%a6%ac%ed%8c%a9%ed%84%b0%eb%a7%81-%ea%b8%b0%eb%b2%95 aria-label="1.3.5 리팩터링 기법">1.3.5 리팩터링 기법</a></li></ul></li><li><a href=#14-%ea%b3%bc%eb%8f%84%ed%95%9c-%ec%84%a4%ea%b3%84%eb%a5%bc-%ed%94%bc%ed%95%98%eb%8a%94-%eb%b0%a9%eb%b2%95 aria-label="1.4 과도한 설계를 피하는 방법">1.4 과도한 설계를 피하는 방법</a><ul><li><a href=#141-%ec%bd%94%eb%93%9c-%ec%84%a4%ea%b3%84%ec%9d%98-%ec%9b%90%eb%9e%98-%ec%9d%98%eb%8f%84%eb%8a%94-%ec%bd%94%eb%93%9c-%ed%92%88%ec%a7%88%ec%9d%84-%ed%96%a5%ec%83%81%ec%8b%9c%ed%82%a4%eb%8a%94-%ea%b2%83%ec%9d%b4%eb%8b%a4 aria-label="1.4.1 코드 설계의 원래 의도는 코드 품질을 향상시키는 것이다">1.4.1 코드 설계의 원래 의도는 코드 품질을 향상시키는 것이다</a></li><li><a href=#142-%ec%bd%94%eb%93%9c-%ec%84%a4%ea%b3%84%ec%9d%98-%ec%9b%90%ec%b9%99%ec%9d%80-%ec%95%9e%ec%97%90-%eb%ac%b8%ec%a0%9c%ea%b0%80-%ec%9e%88%ea%b3%a0-%eb%92%a4%ec%97%90-%eb%b0%a9%ec%95%88%ec%9d%b4-%ec%9e%88%eb%8b%a4%eb%8a%94-%ea%b2%83%ec%9d%b4%eb%8b%a4 aria-label="1.4.2 코드 설계의 원칙은 앞에 문제가 있고, 뒤에 방안이 있다는 것이다">1.4.2 코드 설계의 원칙은 앞에 문제가 있고, 뒤에 방안이 있다는 것이다</a></li><li><a href=#143-%ec%bd%94%eb%93%9c-%ec%84%a4%ea%b3%84%ec%9d%98-%ec%9d%91%ec%9a%a9-%ec%8b%9c%eb%82%98%eb%a6%ac%ec%98%a4%eb%8a%94-%eb%b3%b5%ec%9e%a1%ed%95%9c-%ec%bd%94%eb%93%9c%ec%97%90-%ec%a0%81%ec%9a%a9%eb%90%98%ec%96%b4%ec%95%bc-%ed%95%9c%eb%8b%a4 aria-label="1.4.3 코드 설계의 응용 시나리오는 복잡한 코드에 적용되어야 한다">1.4.3 코드 설계의 응용 시나리오는 복잡한 코드에 적용되어야 한다</a></li><li><a href=#144-%ec%a7%80%ec%86%8d%ec%a0%81%ec%9d%b8-%eb%a6%ac%ed%8c%a9%ed%86%a0%eb%a7%81%ec%9d%80-%ea%b3%bc%eb%8f%84%ed%95%9c-%ec%84%a4%ea%b3%84%eb%a5%bc-%ed%9a%a8%ea%b3%bc%ec%a0%81%ec%9c%bc%eb%a1%9c-%eb%b0%a9%ec%a7%80%ed%95%a0-%ec%88%98-%ec%9e%88%eb%8b%a4 aria-label="1.4.4 지속적인 리팩토링은 과도한 설계를 효과적으로 방지할 수 있다">1.4.4 지속적인 리팩토링은 과도한 설계를 효과적으로 방지할 수 있다</a></li><li><a href=#145-%ed%8a%b9%ec%a0%95-%ec%8b%9c%eb%82%98%eb%a6%ac%ec%98%a4-%ec%99%b8%ec%9d%98-%ec%bd%94%eb%93%9c-%ec%84%a4%ea%b3%84%ec%97%90-%eb%8c%80%ed%95%b4-%ec%9d%b4%ec%95%bc%ea%b8%b0%ed%95%98%ec%a7%80-%ec%95%8a%eb%8a%94%eb%8b%a4 aria-label="1.4.5 특정 시나리오 외의 코드 설계에 대해 이야기하지 않는다">1.4.5 특정 시나리오 외의 코드 설계에 대해 이야기하지 않는다</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=1-개요>1. 개요<a hidden class=anchor aria-hidden=true href=#1-개요>#</a></h1><h2 id=11-코드-설계를-배우는-이유>1.1 코드 설계를 배우는 이유<a hidden class=anchor aria-hidden=true href=#11-코드-설계를-배우는-이유>#</a></h2><ul><li>효율적인 코드 작성 = 데이터 구조 + 알고리즘</li><li><strong>유지 보수가 용이한 고품질 코드</strong> = 코드 설계에 대한 지식</li></ul><h3 id=111-고품질의-코드-작성>1.1.1 고품질의 코드 작성<a hidden class=anchor aria-hidden=true href=#111-고품질의-코드-작성>#</a></h3><h3 id=112-복잡한-코드-개발-다루기>1.1.2 복잡한 코드 개발 다루기<a hidden class=anchor aria-hidden=true href=#112-복잡한-코드-개발-다루기>#</a></h3><ul><li>소프트웨어 개발 시 만나는 어려움의 유형 2가지</li><li><ol><li>높은 수준의 기술을 필요로 하는 경우: 자율 주행, 비디오 인식, AI</li></ol></li><li><ol start=2><li><strong>높은 수준의 기술을 필요로 하지 않는 대규모 프로젝트: 이 책에서 다룰 내용</strong></li></ol></li></ul><h3 id=113-프로그래머의-기본-능력>1.1.3 프로그래머의 기본 능력<a hidden class=anchor aria-hidden=true href=#113-프로그래머의-기본-능력>#</a></h3><h3 id=114-경력-개발에-필요한-기술>1.1.4 경력 개발에 필요한 기술<a hidden class=anchor aria-hidden=true href=#114-경력-개발에-필요한-기술>#</a></h3><h2 id=12-코드-품질-평가-방법>1.2 코드 품질 평가 방법<a hidden class=anchor aria-hidden=true href=#12-코드-품질-평가-방법>#</a></h2><h3 id=121-유지-보수성>1.2.1 유지 보수성<a hidden class=anchor aria-hidden=true href=#121-유지-보수성>#</a></h3><ul><li>기존의 코드 설계를 손상하거나 새로운 버그를 발생시키지 않고도 빠르게 코드를 수정하거나 추가할 수 있는 상태</li><li>코드가 간결하고 가독성이 높으며 확장성이 높다면 코드의 유지 보수도 쉬움</li><li>코드가 명확하게 계층화되어 있으며, 높은 모듈성, 높은 응집도와 낮은 결합도를 가짐</li></ul><h3 id=122-가독성>1.2.2 가독성<a hidden class=anchor aria-hidden=true href=#122-가독성>#</a></h3><ul><li>훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 작성한다.</li><li>제가 중요하게 생각하는 것 중 하나</li></ul><h3 id=123-확장성>1.2.3 확장성<a hidden class=anchor aria-hidden=true href=#123-확장성>#</a></h3><ul><li>약간 수정하는 것만으로도 혹은 전혀 수정하지 않고도 확장을 통해 새로운 기능을 추가하는 것</li><li>요구 사항의 미래 변화에 대처할 수 있는 코드의 능력</li></ul><h3 id=124-유연성>1.2.4 유연성<a hidden class=anchor aria-hidden=true href=#124-유연성>#</a></h3><ul><li>추상적인 평가 기준이기 때문에 정의하기 쉽지 않음</li><li><ol><li>확장을 위한 인터페이스가 준비되어 있음</li></ol></li><li><ol start=2><li>기본적으로 재사용 가능한 많은 모듈과 클래스 등이 기존 코드에 추상화된 형태로 이미 제공</li></ol></li><li><ol start=3><li>클래스가 다양한 사용 시나리오에 대응하고, 다양한 요구를 충족 가능</li></ol></li></ul><h3 id=125-간결성>1.2.5 간결성<a hidden class=anchor aria-hidden=true href=#125-간결성>#</a></h3><ul><li>널리 알려진 KISS(Keep It Simple, Stupid) 원칙</li><li>많은 프로그래머는 단순한 코드에 복잡한 디자인 패턴을 도입하는 것을 좋아한다. 그러나 고수준의 프로그래머는 종종 간단한 방법으로 복잡한 문제를 해결한다.</li><li>저의 코딩 스타일 중 하나</li></ul><h3 id=126-재사용성>1.2.6 재사용성<a hidden class=anchor aria-hidden=true href=#126-재사용성>#</a></h3><ul><li>반복적인 코드 작성을 최소화하고 기존 코드를 재사용하는 것</li><li>단일 책임 원칙(single Responsibility principle)</li><li>DRY(Don&rsquo;t repeat yourself) 원칙</li></ul><h3 id=127-테스트-용이성>1.2.7 테스트 용이성<a hidden class=anchor aria-hidden=true href=#127-테스트-용이성>#</a></h3><ul><li>이 책에서 처음 보는 기준인데, 중요할 것 같네요.</li></ul><h2 id=13-고품질-코드를-작성하는-방법>1.3 고품질 코드를 작성하는 방법<a hidden class=anchor aria-hidden=true href=#13-고품질-코드를-작성하는-방법>#</a></h2><h3 id=131-객체지향>1.3.1 객체지향<a hidden class=anchor aria-hidden=true href=#131-객체지향>#</a></h3><ul><li>세 가지의 프로그래밍 패러다임(절차적, 함수형, 객체지향) 중에서 객체지향 프로그래밍이 가장 대중적임</li><li>이 책에서는 객체지향에 대해 마스터하는 것을 목표로 함</li></ul><h3 id=132-설계-원칙>1.3.2 설계 원칙<a hidden class=anchor aria-hidden=true href=#132-설계-원칙>#</a></h3><ul><li>각각의 설계 원칙이 어떤 문제와 응용 시나리오를 해결하는데 사용되는 것인지 파악해야 한다</li><li>모두 마스터해야만 설계 원칙을 프로젝트에 유연하고 적절하게 적용할 수 있다</li><li>설계 원칙은 디자인 패턴보다 더 보편적이고 중요한 것이다.</li></ul><h3 id=133-디자인-패턴>1.3.3 디자인 패턴<a hidden class=anchor aria-hidden=true href=#133-디자인-패턴>#</a></h3><ul><li>자주 접하게 되는 일부 설계 문제에 대해 요약된 솔루션 또는 설계 사상</li></ul><h3 id=134-코딩-규칙>1.3.4 코딩 규칙<a hidden class=anchor aria-hidden=true href=#134-코딩-규칙>#</a></h3><ul><li>주로 가독성 문제 해결</li></ul><h3 id=135-리팩터링-기법>1.3.5 리팩터링 기법<a hidden class=anchor aria-hidden=true href=#135-리팩터링-기법>#</a></h3><h2 id=14-과도한-설계를-피하는-방법>1.4 과도한 설계를 피하는 방법<a hidden class=anchor aria-hidden=true href=#14-과도한-설계를-피하는-방법>#</a></h2><h3 id=141-코드-설계의-원래-의도는-코드-품질을-향상시키는-것이다>1.4.1 코드 설계의 원래 의도는 코드 품질을 향상시키는 것이다<a hidden class=anchor aria-hidden=true href=#141-코드-설계의-원래-의도는-코드-품질을-향상시키는-것이다>#</a></h3><h3 id=142-코드-설계의-원칙은-앞에-문제가-있고-뒤에-방안이-있다는-것이다>1.4.2 코드 설계의 원칙은 앞에 문제가 있고, 뒤에 방안이 있다는 것이다<a hidden class=anchor aria-hidden=true href=#142-코드-설계의-원칙은-앞에-문제가-있고-뒤에-방안이-있다는-것이다>#</a></h3><h3 id=143-코드-설계의-응용-시나리오는-복잡한-코드에-적용되어야-한다>1.4.3 코드 설계의 응용 시나리오는 복잡한 코드에 적용되어야 한다<a hidden class=anchor aria-hidden=true href=#143-코드-설계의-응용-시나리오는-복잡한-코드에-적용되어야-한다>#</a></h3><ul><li>디자인 패턴을 적용하는 목적은 디커플링, 즉 더 나은 코드 구조를 사용하여 단일 책임을 위해 큰 조각을 작은 클래스로 분할하여 코드가 높은 응집도와 낮은 결합도의 특성을 충족하도록 하는 것이다.</li></ul><h3 id=144-지속적인-리팩토링은-과도한-설계를-효과적으로-방지할-수-있다>1.4.4 지속적인 리팩토링은 과도한 설계를 효과적으로 방지할 수 있다<a hidden class=anchor aria-hidden=true href=#144-지속적인-리팩토링은-과도한-설계를-효과적으로-방지할-수-있다>#</a></h3><ul><li>실현 가능성이 낮은 미래의 요구 사항을 위해 처음부터 디자인 패턴을 적용하기보다, 진짜 문제가 발생했을 때 이를 해결하기 위한 디자인 패턴을 사용하는 것을 고려하는 것이다.</li></ul><h3 id=145-특정-시나리오-외의-코드-설계에-대해-이야기하지-않는다>1.4.5 특정 시나리오 외의 코드 설계에 대해 이야기하지 않는다<a hidden class=anchor aria-hidden=true href=#145-특정-시나리오-외의-코드-설계에-대해-이야기하지-않는다>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=https://jaejin0me.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/>디자인 패턴</a></li></ul></footer><script src=https://utteranc.es/client.js repo=jaejin0me/blog_comment issue-term=title label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>