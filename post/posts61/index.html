<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>백준알고리즘 2316번 - 도시 왕복하기 | Jaejin's blog</title>
<meta name=keywords content="algorithm,네트워크플로우"><meta name=description content="어제 못 풀고 오늘에서야 푼 문제 정점을 1번만 지나는 조건을 만족하기 위해 정점을 분할하고 분할된 정점사이에 용량의 1의 간선을 추가해야 한다. 주의해야 할 것은 입력"><meta name=author content="Jaejin Jang"><link rel=canonical href=https://jaejin0me.github.io/post/posts61/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://jaejin0me.github.io/post/posts61/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T")}</script><meta property="og:title" content="백준알고리즘 2316번 - 도시 왕복하기"><meta property="og:description" content="어제 못 풀고 오늘에서야 푼 문제 정점을 1번만 지나는 조건을 만족하기 위해 정점을 분할하고 분할된 정점사이에 용량의 1의 간선을 추가해야 한다. 주의해야 할 것은 입력"><meta property="og:type" content="article"><meta property="og:url" content="https://jaejin0me.github.io/post/posts61/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-01-30T12:20:42+09:00"><meta property="article:modified_time" content="2018-01-30T12:20:42+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="백준알고리즘 2316번 - 도시 왕복하기"><meta name=twitter:description content="어제 못 풀고 오늘에서야 푼 문제 정점을 1번만 지나는 조건을 만족하기 위해 정점을 분할하고 분할된 정점사이에 용량의 1의 간선을 추가해야 한다. 주의해야 할 것은 입력"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jaejin0me.github.io/post/"},{"@type":"ListItem","position":2,"name":"백준알고리즘 2316번 - 도시 왕복하기","item":"https://jaejin0me.github.io/post/posts61/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"백준알고리즘 2316번 - 도시 왕복하기","name":"백준알고리즘 2316번 - 도시 왕복하기","description":"어제 못 풀고 오늘에서야 푼 문제 정점을 1번만 지나는 조건을 만족하기 위해 정점을 분할하고 분할된 정점사이에 용량의 1의 간선을 추가해야 한다. 주의해야 할 것은 입력","keywords":["algorithm","네트워크플로우"],"articleBody":"어제 못 풀고 오늘에서야 푼 문제\n정점을 1번만 지나는 조건을 만족하기 위해 정점을 분할하고 분할된 정점사이에 용량의 1의 간선을 추가해야 한다.\n주의해야 할 것은 입력되는 간선들을 분할될 정점을 고려해 잘 이어주는 것이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.Queue; import java.util.Scanner; import java.util.StringTokenizer; /** * @author jaeji * */ class edge{ int to; int flow; int cap; edge rever; edge(){ this(0,0,0,null);\t} edge(int ar_to, int ar_flow, int ar_cap, edge ar_rever){ to = ar_to; flow = ar_flow; cap = ar_cap; rever = ar_rever; } int residu() { return cap-flow; } void addflow(int ar_flow) { flow+=ar_flow; rever.flow -=ar_flow; } } public class Main { public static void main(String[] args) throws IOException { //정점 분할 필요 //0~399 까지는 나눴을 떄 간선이 들어오는 정점, 400~799까지는 나눴을 때 간선이 나가는 정점 BufferedReader br = new BufferedReader( new InputStreamReader( System.in ) ); //BufferedReader br = new BufferedReader( new FileReader(\"input.txt\" ) ); StringTokenizer st = new StringTokenizer(br.readLine());\tint n = Integer.parseInt(st.nextToken()); int p = Integer.parseInt(st.nextToken()); int[] prev = new int[800]; ArrayList[] adj = new ArrayList[800]; Queue q = new LinkedList(); int total = 0,u=0,v=0,u1=0,v1=0,temp=0,v2=0,u2=0; int flow = 0; for(int i=0;i\u003c800;i++) { adj[i] = new ArrayList(); } for(int i=0;i","wordCount":"674","inLanguage":"ko","datePublished":"2018-01-30T12:20:42+09:00","dateModified":"2018-01-30T12:20:42+09:00","author":{"@type":"Person","name":"Jaejin Jang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jaejin0me.github.io/post/posts61/"},"publisher":{"@type":"Organization","name":"Jaejin's blog","logo":{"@type":"ImageObject","url":"https://jaejin0me.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io/ accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">백준알고리즘 2316번 - 도시 왕복하기</h1><div class=post-meta><span title='2018-01-30 12:20:42 +0900 +0900'>1월 30, 2018</span>&nbsp;·&nbsp;Jaejin Jang</div></header><div class=post-content><p>어제 못 풀고 오늘에서야 푼 문제</p><p>정점을 1번만 지나는 조건을 만족하기 위해 정점을 분할하고 분할된 정점사이에 용량의 1의 간선을 추가해야 한다.</p><p>주의해야 할 것은 입력되는 간선들을 분할될 정점을 고려해 잘 이어주는 것이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>import java.io.BufferedReader;
</span></span><span class=line><span class=cl>import java.io.FileReader;
</span></span><span class=line><span class=cl>import java.io.IOException;
</span></span><span class=line><span class=cl>import java.io.InputStreamReader;
</span></span><span class=line><span class=cl>import java.util.ArrayList;
</span></span><span class=line><span class=cl>import java.util.Arrays;
</span></span><span class=line><span class=cl>import java.util.LinkedList;
</span></span><span class=line><span class=cl>import java.util.Queue;
</span></span><span class=line><span class=cl>import java.util.Scanner;
</span></span><span class=line><span class=cl>import java.util.StringTokenizer;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/**
</span></span><span class=line><span class=cl> * @author jaeji
</span></span><span class=line><span class=cl> *
</span></span><span class=line><span class=cl> */
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>class edge{
</span></span><span class=line><span class=cl>	int to;
</span></span><span class=line><span class=cl>	int flow;
</span></span><span class=line><span class=cl>	int cap;
</span></span><span class=line><span class=cl>	edge rever;
</span></span><span class=line><span class=cl>	edge(){
</span></span><span class=line><span class=cl>		this(0,0,0,null);		
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>	edge(int ar_to, int ar_flow, int ar_cap, edge ar_rever){
</span></span><span class=line><span class=cl>		to = ar_to;
</span></span><span class=line><span class=cl>		flow = ar_flow;
</span></span><span class=line><span class=cl>		cap = ar_cap;
</span></span><span class=line><span class=cl>		rever =  ar_rever;
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>	int residu() {
</span></span><span class=line><span class=cl>		return cap-flow;
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>	void addflow(int ar_flow) {
</span></span><span class=line><span class=cl>		flow+=ar_flow;
</span></span><span class=line><span class=cl>		rever.flow -=ar_flow;
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>public class Main {
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	public static void main(String[] args) throws IOException {
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		//정점 분할 필요
</span></span><span class=line><span class=cl>		//0~399 까지는 나눴을 떄 간선이 들어오는 정점, 400~799까지는 나눴을 때 간선이 나가는 정점
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		BufferedReader br = new BufferedReader( new InputStreamReader( System.in ) );
</span></span><span class=line><span class=cl>		//BufferedReader br = new BufferedReader( new FileReader(&#34;input.txt&#34; ) );
</span></span><span class=line><span class=cl>		StringTokenizer st = new StringTokenizer(br.readLine());		
</span></span><span class=line><span class=cl>		int n = Integer.parseInt(st.nextToken());
</span></span><span class=line><span class=cl>		int p = Integer.parseInt(st.nextToken());
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		int[] prev =  new int[800];
</span></span><span class=line><span class=cl>		ArrayList[] adj = new ArrayList[800];
</span></span><span class=line><span class=cl>		Queue&lt;Integer&gt; q =  new LinkedList&lt;Integer&gt;();
</span></span><span class=line><span class=cl>		int total = 0,u=0,v=0,u1=0,v1=0,temp=0,v2=0,u2=0;
</span></span><span class=line><span class=cl>        int flow =  0;
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		for(int i=0;i&lt;800;i++) {
</span></span><span class=line><span class=cl>			adj[i] = new ArrayList&lt;edge&gt;();
</span></span><span class=line><span class=cl>		}
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		for(int i=0;i&lt;n;i++) {
</span></span><span class=line><span class=cl>			u = i;
</span></span><span class=line><span class=cl>			v = i+400;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			edge temp_edge = new edge(v,0,1,null);
</span></span><span class=line><span class=cl>			edge temp_rever_edge = new edge(u,0,0,temp_edge);
</span></span><span class=line><span class=cl>			temp_edge.rever = temp_rever_edge;
</span></span><span class=line><span class=cl>			
</span></span><span class=line><span class=cl>			adj[u].add(temp_edge);
</span></span><span class=line><span class=cl>			adj[v].add(temp_rever_edge);
</span></span><span class=line><span class=cl>		}
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>				
</span></span><span class=line><span class=cl>		for(int i=0;i&lt;p;i++) {
</span></span><span class=line><span class=cl>			
</span></span><span class=line><span class=cl>			st =  new StringTokenizer(br.readLine());
</span></span><span class=line><span class=cl>			u1 = Integer.parseInt(st.nextToken())-1+400;
</span></span><span class=line><span class=cl>			v1 = Integer.parseInt(st.nextToken())-1;
</span></span><span class=line><span class=cl>			
</span></span><span class=line><span class=cl>			u2 = u1-400;
</span></span><span class=line><span class=cl>			v2 = v1+400;
</span></span><span class=line><span class=cl>			
</span></span><span class=line><span class=cl>			edge temp_edge1 = new edge(v1,0,1,null);
</span></span><span class=line><span class=cl>			edge temp_rever_edge1 = new edge(u1,0,0,temp_edge1);
</span></span><span class=line><span class=cl>			temp_edge1.rever = temp_rever_edge1;
</span></span><span class=line><span class=cl>			
</span></span><span class=line><span class=cl>			adj[u1].add(temp_edge1);
</span></span><span class=line><span class=cl>			adj[v1].add(temp_rever_edge1);
</span></span><span class=line><span class=cl>			
</span></span><span class=line><span class=cl>			edge temp_edge2 = new edge(v2,0,0,null);
</span></span><span class=line><span class=cl>			edge temp_rever_edge2 = new edge(u2,0,1,temp_edge1);
</span></span><span class=line><span class=cl>			temp_edge2.rever = temp_rever_edge2;
</span></span><span class=line><span class=cl>			
</span></span><span class=line><span class=cl>			adj[u2].add(temp_edge2);
</span></span><span class=line><span class=cl>			adj[v2].add(temp_rever_edge2);		
</span></span><span class=line><span class=cl>			
</span></span><span class=line><span class=cl>		}
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		int curr = 0;
</span></span><span class=line><span class=cl>		edge next = null;
</span></span><span class=line><span class=cl>		int S = 400; // 분할된 1번 정점의 나가는 곳
</span></span><span class=line><span class=cl>		int E = 1; // 분할된 2번 정점의 들어오는 곳
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		while(true) {
</span></span><span class=line><span class=cl>			edge[] path = new edge[800];
</span></span><span class=line><span class=cl>			Arrays.fill(prev, -1);
</span></span><span class=line><span class=cl>			q.clear();
</span></span><span class=line><span class=cl>			q.add(S);
</span></span><span class=line><span class=cl>			curr = 0;
</span></span><span class=line><span class=cl>			next = null;
</span></span><span class=line><span class=cl>			
</span></span><span class=line><span class=cl>			while(!q.isEmpty()) { // 소스에서 흐를수 있는 유량찾기
</span></span><span class=line><span class=cl>				curr = q.poll();
</span></span><span class=line><span class=cl>				
</span></span><span class=line><span class=cl>				for(int i=0;i&lt;adj[curr].size();i++) {
</span></span><span class=line><span class=cl>					
</span></span><span class=line><span class=cl>					next = (edge) adj[curr].get(i);
</span></span><span class=line><span class=cl>					if(next.residu() &gt; 0 &amp;&amp; prev[next.to] == -1) {
</span></span><span class=line><span class=cl>						q.add(next.to);
</span></span><span class=line><span class=cl>						prev[next.to] = curr;
</span></span><span class=line><span class=cl>						path[next.to] = next;
</span></span><span class=line><span class=cl>						if(next.to == E) break;
</span></span><span class=line><span class=cl>					}
</span></span><span class=line><span class=cl>				}
</span></span><span class=line><span class=cl>			}
</span></span><span class=line><span class=cl>			
</span></span><span class=line><span class=cl>			if(prev[E] == -1) break; // 경로를 탐색 한 후 싱크로 가는 경로가 없는 경우
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            flow =  Integer.MAX_VALUE;
</span></span><span class=line><span class=cl>            for(int i=E; i!=S; i=prev[i]) {
</span></span><span class=line><span class=cl>				flow = Math.min(flow,path[i].residu());
</span></span><span class=line><span class=cl>			}
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>			for(int i=E; i!=S; i=prev[i]) {
</span></span><span class=line><span class=cl>				path[i].addflow(flow);
</span></span><span class=line><span class=cl>			}
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>			total += flow;
</span></span><span class=line><span class=cl>			
</span></span><span class=line><span class=cl>		}
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		System.out.println(total);
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://jaejin0me.github.io/tags/algorithm/>Algorithm</a></li><li><a href=https://jaejin0me.github.io/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C%EC%9A%B0/>네트워크플로우</a></li></ul></footer><script src=https://utteranc.es/client.js repo=jaejin0me/blog_comment issue-term=title label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>