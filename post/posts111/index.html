<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>디자인 패턴 - 싱글턴 패턴 | Jaejin's blog</title><meta name=keywords content="디자인 패턴"><meta name=description content="싱글턴 패턴 인스턴스가 하나 만들어지고 어디서든지 인스턴스에 접근하기 위한 패턴 간단히 인스턴스에 접근하기 위한 get메소드, 기본적인 생성자, 인스턴스 멤버"><meta name=author content="Jaejin Jang"><link rel=canonical href=https://jaejin0me.github.io/post/posts111/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T",{anonymize_ip:!0})}</script><meta property="og:title" content="디자인 패턴 - 싱글턴 패턴"><meta property="og:description" content="싱글턴 패턴 인스턴스가 하나 만들어지고 어디서든지 인스턴스에 접근하기 위한 패턴 간단히 인스턴스에 접근하기 위한 get메소드, 기본적인 생성자, 인스턴스 멤버"><meta property="og:type" content="article"><meta property="og:url" content="https://jaejin0me.github.io/post/posts111/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-01-01T11:31:42+09:00"><meta property="article:modified_time" content="2018-01-01T11:31:42+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="디자인 패턴 - 싱글턴 패턴"><meta name=twitter:description content="싱글턴 패턴 인스턴스가 하나 만들어지고 어디서든지 인스턴스에 접근하기 위한 패턴 간단히 인스턴스에 접근하기 위한 get메소드, 기본적인 생성자, 인스턴스 멤버"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://jaejin0me.github.io/post/"},{"@type":"ListItem","position":3,"name":"디자인 패턴 - 싱글턴 패턴","item":"https://jaejin0me.github.io/post/posts111/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"디자인 패턴 - 싱글턴 패턴","name":"디자인 패턴 - 싱글턴 패턴","description":"싱글턴 패턴 인스턴스가 하나 만들어지고 어디서든지 인스턴스에 접근하기 위한 패턴 간단히 인스턴스에 접근하기 위한 get메소드, 기본적인 생성자, 인스턴스 멤버","keywords":["디자인 패턴"],"articleBody":"싱글턴 패턴 인스턴스가 하나 만들어지고 어디서든지 인스턴스에 접근하기 위한 패턴\n간단히 인스턴스에 접근하기 위한 get메소드, 기본적인 생성자, 인스턴스 멤버변수로 구성된다고 가정해보자.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class singleton { private static singleton instance; private singleton(){} public static singleton getinstance(){ if (instance == null){ instance = new singleton(); } return instance; } } get메소드를 통해 인스턴스가 만들어져 있으면 리턴하고, 없으면 생성한다. 미리 만들어 놓지 않고 get메소드가 호출될 때 인스턴스가 만들어진다. 이것은 lazy instantiation 이라고 한다. 하지만 이 코드는 멀티스터드 상황에서 문제가 발생한다. 여러개의 쓰레드에서 동시에 get메소드를 호출하는 경우 동기화가 되지 않아 인스턴스가 여러개 생성된다.\n이 문제를 해결하기 위한 방법은 다음과 같다.\nget메소드 동기화 get메소드를 동기화 하는 것이다. 동기화하는 경우 메소드의 성능이 아주 느려지기 때문에 문제가 되지 않는 경우에만 사용해야 한다.\n1 public static synchronized singleton getinstance(){ 성능개선을 위한 방법으로 DCL(Double-Checking Locking)을 통해 동기화 부분을 get메소드의 더 내부로 넣는 방법이 있다.\n1 2 3 4 5 6 7 8 if (instance == null){ synchronized (singleton.class){ if(uinstance == null){ instance = new singleton(); } } } return uniqueInstance; 널체크를 한번한후에 수행하기 때문에 get메소드에 동기화를 한 것보다는 동기화코드가 적게 불리게 된다. 동기화를 쓰면서 조금이나마 성능개선을 원하는 경우에 적합하다.\n인스턴스를 미리 만들어 둔다. 함수가 호출될때 만들지 말고 미리 만들어 두는 것이다. 나는 이 방법이 가장 괜찮다고 본다.\n1 private static singleton instance = new singleton(); ","wordCount":"574","inLanguage":"ko","datePublished":"2018-01-01T11:31:42+09:00","dateModified":"2018-01-01T11:31:42+09:00","author":{"@type":"Person","name":"Jaejin Jang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jaejin0me.github.io/post/posts111/"},"publisher":{"@type":"Organization","name":"Jaejin's blog","logo":{"@type":"ImageObject","url":"https://jaejin0me.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>디자인 패턴 - 싱글턴 패턴</h1><div class=post-meta><span title='2018-01-01 11:31:42 +0900 +0900'>1월 1, 2018</span>&nbsp;·&nbsp;Jaejin Jang</div></header><div class=post-content><h2 id=싱글턴-패턴>싱글턴 패턴<a hidden class=anchor aria-hidden=true href=#싱글턴-패턴>#</a></h2><p>인스턴스가 하나 만들어지고 어디서든지 인스턴스에 접근하기 위한 패턴</p><p>간단히 인스턴스에 접근하기 위한 get메소드, 기본적인 생성자, 인스턴스 멤버변수로 구성된다고 가정해보자.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>public class singleton {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	private static singleton instance;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	private singleton(){}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	public static singleton getinstance(){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		if (instance == null){
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			instance = new singleton();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		return instance;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> }
</span></span></code></pre></td></tr></table></div></div><p>get메소드를 통해 인스턴스가 만들어져 있으면 리턴하고, 없으면 생성한다. 미리 만들어 놓지 않고 get메소드가 호출될 때 인스턴스가 만들어진다. 이것은 lazy instantiation 이라고 한다.
하지만 이 코드는 멀티스터드 상황에서 문제가 발생한다. 여러개의 쓰레드에서 동시에 get메소드를 호출하는 경우 동기화가 되지 않아 인스턴스가 여러개 생성된다.</p><p>이 문제를 해결하기 위한 방법은 다음과 같다.</p><ol><li>get메소드 동기화</li></ol><p>get메소드를 동기화 하는 것이다. 동기화하는 경우 메소드의 성능이 아주 느려지기 때문에 문제가 되지 않는 경우에만 사용해야 한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>public static synchronized singleton getinstance(){
</span></span></code></pre></td></tr></table></div></div><p>성능개선을 위한 방법으로 DCL(Double-Checking Locking)을 통해 동기화 부분을 get메소드의 더 내부로 넣는 방법이 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>if (instance == null){
</span></span><span class=line><span class=cl>                        synchronized (singleton.class){
</span></span><span class=line><span class=cl>                                  if(uinstance == null){
</span></span><span class=line><span class=cl>                                             instance = new singleton();
</span></span><span class=line><span class=cl>                                  }
</span></span><span class=line><span class=cl>                        }
</span></span><span class=line><span class=cl>		}
</span></span><span class=line><span class=cl>		return uniqueInstance;
</span></span></code></pre></td></tr></table></div></div><p>널체크를 한번한후에 수행하기 때문에 get메소드에 동기화를 한 것보다는 동기화코드가 적게 불리게 된다.
동기화를 쓰면서 조금이나마 성능개선을 원하는 경우에 적합하다.</p><ol start=2><li>인스턴스를 미리 만들어 둔다.</li></ol><p>함수가 호출될때 만들지 말고 미리 만들어 두는 것이다. 나는 이 방법이 가장 괜찮다고 본다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>private static singleton instance = new singleton();
</span></span></code></pre></td></tr></table></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://jaejin0me.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/>디자인 패턴</a></li></ul></footer><script src=https://utteranc.es/client.js repo=jaejin0me/blog_comment issue-term=title label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>