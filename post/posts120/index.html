<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>영상처리 기초 - 1 | Jaejin's blog</title>
<meta name=keywords content="영상처리"><meta name=description content="1. 영상처리 기본 1) 영상처리의 개념 (1) 영상처리의 예 sharpening Image segmentation Noise filtering special effect(Sepia tone effect (2) 영상처리 기술 Image Transforms Image Transmissions Image Enhancement Image Restoration Image Compression Image Segmentation Representation and Description Recognition and Interpretation 1) 영상처리의 응용 분야 의료 영상"><meta name=author content="Jaejin Jang"><link rel=canonical href=https://jaejin0me.github.io/post/posts120/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://jaejin0me.github.io/post/posts120/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T",{anonymize_ip:!0})}</script><meta property="og:title" content="영상처리 기초 - 1"><meta property="og:description" content="1. 영상처리 기본 1) 영상처리의 개념 (1) 영상처리의 예 sharpening Image segmentation Noise filtering special effect(Sepia tone effect (2) 영상처리 기술 Image Transforms Image Transmissions Image Enhancement Image Restoration Image Compression Image Segmentation Representation and Description Recognition and Interpretation 1) 영상처리의 응용 분야 의료 영상"><meta property="og:type" content="article"><meta property="og:url" content="https://jaejin0me.github.io/post/posts120/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-01-23T16:42:42+09:00"><meta property="article:modified_time" content="2018-01-23T16:42:42+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="영상처리 기초 - 1"><meta name=twitter:description content="1. 영상처리 기본 1) 영상처리의 개념 (1) 영상처리의 예 sharpening Image segmentation Noise filtering special effect(Sepia tone effect (2) 영상처리 기술 Image Transforms Image Transmissions Image Enhancement Image Restoration Image Compression Image Segmentation Representation and Description Recognition and Interpretation 1) 영상처리의 응용 분야 의료 영상"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jaejin0me.github.io/post/"},{"@type":"ListItem","position":2,"name":"영상처리 기초 - 1","item":"https://jaejin0me.github.io/post/posts120/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"영상처리 기초 - 1","name":"영상처리 기초 - 1","description":"1. 영상처리 기본 1) 영상처리의 개념 (1) 영상처리의 예 sharpening Image segmentation Noise filtering special effect(Sepia tone effect (2) 영상처리 기술 Image Transforms Image Transmissions Image Enhancement Image Restoration Image Compression Image Segmentation Representation and Description Recognition and Interpretation 1) 영상처리의 응용 분야 의료 영상","keywords":["영상처리"],"articleBody":"1. 영상처리 기본 1) 영상처리의 개념 (1) 영상처리의 예 sharpening Image segmentation Noise filtering special effect(Sepia tone effect (2) 영상처리 기술 Image Transforms Image Transmissions Image Enhancement Image Restoration Image Compression Image Segmentation Representation and Description Recognition and Interpretation 1) 영상처리의 응용 분야 의료 영상처리 : 신경망 활용 문자인식 영상 검색 : 영상처리 기술들의 집약체 컴퓨터 비전 : 인간의 눈으로 확인할 수 없는 제품 결함 판단 인터넷에 기반한 스트리밍 기술 영상 압축 기술 : MPEG 영상 처리 관련 SW 개발 생물학/군사학 디스플레이 2. 컬러 공간 분석 1) Image Basics (1) Pexels rectangular triangular hexagonal (2) N-connected neighbors 4-connected 8-connected ambiguous (3) Distance metrics Euclidean : De(X,Y) = ((x2-y2)^2 + (y2-y1)^2)^1/2 City Block : Dcb(X,Y) = |x1-x2| + |y1-y2| Chessboard : Dcb(X,y) = max{|x1-x2|,|y1-y2|} (4) 명암도 영상(gray image) (5) RGB 영상 : 각 채널별 8비트, 24비트 개의 색 표현 가능 (6) 이진 영상 (7) 영상의 용량 : 시간(s)*프레임(f/s)화소의 수화소당 비트 2) 컬러 공간에 대한 이해 (1) 컬러는 인가의 눈에 보이는 가시 광선 (2) 빛의 3원색 : R, G, B 간의 가산 혼합 (3) 모니터에서는 RGB를 조합해 사용함 (4) 영상의 정의 컬러를 표현하는 화소값의 배열 (5) 흑백 영상 분리 RGB 컬러 공간 : 0.333R+0.333B+0.333G NTSC 제안 각 RGB값 중 하나만 사용 Green만 사용 Gray level = (R^2+B^2+G^2)^1/2 / 3^1/2 Gray level = 0.212671R + 0.715160G + 0.071169B (6) 다른 영상 처리 응용에 한계 RGB 컬러 요소들은 상호 관계가 너무 커서 특정 생성만 분리하기 어려움 (7) HSI 컬러 공간 색상, 채도, 명도로 구분한 컬러 공간으로 인간의 시각 시스템과 유사 3) HSI 컬러 공간 (1) 색의 3 요소 색상(hue) : pure colore 채도(saturation) : white 와 pure color 와의 혼합 비율 명도(Intensity) : 색의 밝고 어두운 정도 (2) 색입체 먼셀, 오스왈드, P.G.C.S 등 Hue : 원통모양의 주변, 0 ~ 360 Satuation : 중심으로부터의 거리, 0 ~ 1 Intensity : 하단 꼭지점에서 최상부 까지의 거리, 0 ~ 1, 색의 표현 범위가 달라짐 (3) RGB -\u003e HSI H = { Θ if B\u003c=G ㅤㅤ{ 360 - 0 if B\u003c=G Θ = cos^-1[1/2*[(R-G)+(R+B)]/((R-G)^2+(R-B)(G-B))^1/2] S = 1 - 3/(R+G+B)*[min(R,G,B)] I = 1/3*(R+G+B) (4) CMYK 컬러 공간 : Printer 청록(Cyan) : C=255-R 자홍(Magenta) : M=255-G 노랑(Yellow) : Y=255-B 감산 혼합 C+M+Y= 검정 K = min(C,M,Y) C = 기존 C - K M = 기존 M - K Y = 기존 Y - K 인쇄를 보낼 때는 CMYK 컬러 공간으로 변환해 보내는 것이 좋다 CMYK 컬러 공간의 한계 RGB보다 범위에 한계 다소 뿌옇게 인쇄 CMYK 형태로 직접 모니터로 불러들여 작업하지 않음 5) 다른 컬러 공간 (1) YIQ 인간의 시각체계와 유사하게 흉내낸 최초의 색상공간 Y는 명조, I는 orange-cyan, Q는 Green-Magenta 1950년대, 컬러 텔레비전(NTSC방식) 개발자들의 의해 구성 (2) YCbCr 색상정보로 부터 명도를 분리하는 또 하나의 다른 색상 공간 Y는 명도, Cb는 푸른색, Cr, 붉은색 JPEG, MPEG 및 디지털 TV의 표준으로 사용 (3) CIE LAB : uniform color space L*, a*, b* L* 는 명도, a* red와 green, b*는 yellow와 blue 3. 화소값 기본 처리 1) 영상의 밝기 조절 (1) 명암도 영상(흑백 영상) 한 화소당 8비트의 데이터 크기 0 ~ 255의 범위 (2) 명암값을 더하거나 뺄 경우 0이하 이거나 255이상일 때 문제 발생 클랭핌을 이용한 해결 Saturation : 0이하 -\u003e 0, 255 이상 -\u003e 255 Wrap : 256 = 1, 257 = 2, 258 = 3, 반전 시키는 방법이지만 명암 불균등을 낳는다. (3) 영상의 산술 연산 밝게 = 255에 가깝게 어둡게 = 0에 가깝게 (4) 산술 연산 적용 예 차영상 : 움직임 추적에 쓰임 2) 영상의 명암대비 조절 (1) 명암 대비(Contrast) : 명암값의 분포 낮음 명암 대비 : 명암차가 적음 높은 명암 대비 : 명암차가 큼 (2) 대비의 증가 = 곱셈 연산 (3) 대비의 감소 = 나눗셈 연산 3) 히스토그램 (1) 히스토그램 각화소의 명암값의 개수 영상의 명암 값 프로필(profile) - \u003e 히스토그램 유사도를 사용한 영상 비교에 유용하다 4) 히스토그램 평활화 한 쪽에 치우친 명암 분포를 가진 히스토그램을 재분배 하는 과정을 거쳐 일정한 분포를 가지게 하는 히스토그램 h(i) = (H(i)/Nt)*Gmax h(i) : 정규화 합 히스토그램 H(i) : 누적 히스토그램 Nt : 영상에서 픽셀의 총 개수 Gmax : 영상의 최대 밝기 5) 히스토그램 스트레칭 명암 대비 확장, 명암 대비 스트레칭 낮은 대비의 히스토그램을 균등한 분포로 만드는 알고리즘 X: 기존 명암 값 low : 히스토그램에서 가장 작은 화소값 high : 히스토그램에서 가장 큰 화소값 새로운 명암 값 = 255*(X-low)/(high-low) 스트레칭 변형 : 엔드인 탐색(ends-in search) low, high의 범위 값을 지정하여 스트레칭 한다. 히스토그램의 특정 부분에 화소들이 치우진 형상을 보정하는데 유용하다. 새로운 명암 값 = { 0 for X\u003c=low ㅤㅤㅤㅤㅤㅤㅤㅤ{ 255*(x-low)/(high-low) for low\u003c=X","wordCount":"2580","inLanguage":"ko","datePublished":"2018-01-23T16:42:42+09:00","dateModified":"2018-01-23T16:42:42+09:00","author":{"@type":"Person","name":"Jaejin Jang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jaejin0me.github.io/post/posts120/"},"publisher":{"@type":"Organization","name":"Jaejin's blog","logo":{"@type":"ImageObject","url":"https://jaejin0me.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io/ accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">영상처리 기초 - 1</h1><div class=post-meta><span title='2018-01-23 16:42:42 +0900 +0900'>1월 23, 2018</span>&nbsp;·&nbsp;Jaejin Jang</div></header><div class=post-content><h1 id=1-영상처리-기본>1. 영상처리 기본<a hidden class=anchor aria-hidden=true href=#1-영상처리-기본>#</a></h1><h2 id=1-영상처리의-개념>1) 영상처리의 개념<a hidden class=anchor aria-hidden=true href=#1-영상처리의-개념>#</a></h2><h3 id=1-영상처리의-예>(1) 영상처리의 예<a hidden class=anchor aria-hidden=true href=#1-영상처리의-예>#</a></h3><ul><li>sharpening</li><li>Image segmentation</li><li>Noise filtering</li><li>special effect(Sepia tone effect</li></ul><h2 id=2-영상처리-기술>(2) 영상처리 기술<a hidden class=anchor aria-hidden=true href=#2-영상처리-기술>#</a></h2><ul><li>Image Transforms</li><li>Image Transmissions</li><li>Image Enhancement</li><li>Image Restoration</li><li>Image Compression</li><li>Image Segmentation</li><li>Representation and Description</li><li>Recognition and Interpretation</li></ul><h2 id=1-영상처리의-응용-분야>1) 영상처리의 응용 분야<a hidden class=anchor aria-hidden=true href=#1-영상처리의-응용-분야>#</a></h2><ul><li>의료 영상처리 : 신경망 활용</li><li>문자인식</li><li>영상 검색 : 영상처리 기술들의 집약체</li><li>컴퓨터 비전 : 인간의 눈으로 확인할 수 없는 제품 결함 판단</li><li>인터넷에 기반한 스트리밍 기술</li><li>영상 압축 기술 : MPEG</li><li>영상 처리 관련 SW 개발</li><li>생물학/군사학</li><li>디스플레이</li></ul><h1 id=2-컬러-공간-분석>2. 컬러 공간 분석<a hidden class=anchor aria-hidden=true href=#2-컬러-공간-분석>#</a></h1><h2 id=1-image-basics>1) Image Basics<a hidden class=anchor aria-hidden=true href=#1-image-basics>#</a></h2><h3 id=1-pexels>(1) Pexels<a hidden class=anchor aria-hidden=true href=#1-pexels>#</a></h3><ul><li>rectangular</li><li>triangular</li><li>hexagonal</li></ul><h3 id=2-n-connected-neighbors>(2) N-connected neighbors<a hidden class=anchor aria-hidden=true href=#2-n-connected-neighbors>#</a></h3><ul><li>4-connected</li><li>8-connected</li><li>ambiguous</li></ul><h3 id=3-distance-metrics>(3) Distance metrics<a hidden class=anchor aria-hidden=true href=#3-distance-metrics>#</a></h3><ul><li>Euclidean : De(X,Y) = ((x2-y2)^2 + (y2-y1)^2)^1/2</li><li>City Block : Dcb(X,Y) = |x1-x2| + |y1-y2|</li><li>Chessboard : Dcb(X,y) = max{|x1-x2|,|y1-y2|}</li></ul><h3 id=4-명암도-영상gray-image>(4) 명암도 영상(gray image)<a hidden class=anchor aria-hidden=true href=#4-명암도-영상gray-image>#</a></h3><h3 id=5-rgb-영상--각-채널별-8비트-24비트-개의-색-표현-가능>(5) RGB 영상 : 각 채널별 8비트, 24비트 개의 색 표현 가능<a hidden class=anchor aria-hidden=true href=#5-rgb-영상--각-채널별-8비트-24비트-개의-색-표현-가능>#</a></h3><h3 id=6-이진-영상>(6) 이진 영상<a hidden class=anchor aria-hidden=true href=#6-이진-영상>#</a></h3><h3 id=7-영상의-용량--시간s프레임fs화소의-수화소당-비트>(7) 영상의 용량 : 시간(s)*프레임(f/s)<em>화소의 수</em>화소당 비트<a hidden class=anchor aria-hidden=true href=#7-영상의-용량--시간s프레임fs화소의-수화소당-비트>#</a></h3><h2 id=2-컬러-공간에-대한-이해>2) 컬러 공간에 대한 이해<a hidden class=anchor aria-hidden=true href=#2-컬러-공간에-대한-이해>#</a></h2><h3 id=1-컬러는-인가의-눈에-보이는-가시-광선>(1) 컬러는 인가의 눈에 보이는 가시 광선<a hidden class=anchor aria-hidden=true href=#1-컬러는-인가의-눈에-보이는-가시-광선>#</a></h3><h3 id=2-빛의-3원색--r-g-b-간의-가산-혼합>(2) 빛의 3원색 : R, G, B 간의 가산 혼합<a hidden class=anchor aria-hidden=true href=#2-빛의-3원색--r-g-b-간의-가산-혼합>#</a></h3><h3 id=3-모니터에서는-rgb를-조합해-사용함>(3) 모니터에서는 RGB를 조합해 사용함<a hidden class=anchor aria-hidden=true href=#3-모니터에서는-rgb를-조합해-사용함>#</a></h3><h3 id=4-영상의-정의>(4) 영상의 정의<a hidden class=anchor aria-hidden=true href=#4-영상의-정의>#</a></h3><ul><li>컬러를 표현하는 화소값의 배열</li></ul><h3 id=5-흑백-영상-분리>(5) 흑백 영상 분리<a hidden class=anchor aria-hidden=true href=#5-흑백-영상-분리>#</a></h3><ul><li><ol><li>RGB 컬러 공간 : 0.333R+0.333B+0.333G</li></ol><ul><li>NTSC 제안</li><li>각 RGB값 중 하나만 사용</li><li>Green만 사용</li><li>Gray level = (R^2+B^2+G^2)^1/2 / 3^1/2</li><li>Gray level = 0.212671R + 0.715160G + 0.071169B</li></ul></li></ul><h3 id=6-다른-영상-처리-응용에-한계>(6) 다른 영상 처리 응용에 한계<a hidden class=anchor aria-hidden=true href=#6-다른-영상-처리-응용에-한계>#</a></h3><ul><li>RGB 컬러 요소들은 상호 관계가 너무 커서 특정 생성만 분리하기 어려움</li></ul><h3 id=7-hsi-컬러-공간>(7) HSI 컬러 공간<a hidden class=anchor aria-hidden=true href=#7-hsi-컬러-공간>#</a></h3><ul><li>색상, 채도, 명도로 구분한 컬러 공간으로 인간의 시각 시스템과 유사</li></ul><h2 id=3-hsi-컬러-공간>3) HSI 컬러 공간<a hidden class=anchor aria-hidden=true href=#3-hsi-컬러-공간>#</a></h2><h3 id=1-색의-3-요소>(1) 색의 3 요소<a hidden class=anchor aria-hidden=true href=#1-색의-3-요소>#</a></h3><ul><li>색상(hue) : pure colore</li><li>채도(saturation) : white 와 pure color 와의 혼합 비율</li><li>명도(Intensity) : 색의 밝고 어두운 정도</li></ul><h3 id=2-색입체>(2) 색입체<a hidden class=anchor aria-hidden=true href=#2-색입체>#</a></h3><ul><li>먼셀, 오스왈드, P.G.C.S 등</li><li>Hue : 원통모양의 주변, 0 ~ 360</li><li>Satuation : 중심으로부터의 거리, 0 ~ 1</li><li>Intensity : 하단 꼭지점에서 최상부 까지의 거리, 0 ~ 1, 색의 표현 범위가 달라짐</li></ul><h3 id=3-rgb---hsi>(3) RGB -> HSI<a hidden class=anchor aria-hidden=true href=#3-rgb---hsi>#</a></h3><ul><li>H = { Θ if B&lt;=G</li><li>ㅤㅤ{ 360 - 0 if B&lt;=G</li><li>Θ = cos^-1[1/2*[(R-G)+(R+B)]/((R-G)^2+(R-B)(G-B))^1/2]</li><li>S = 1 - 3/(R+G+B)<code>*</code>[min(R,G,B)]</li><li>I = 1/3*(R+G+B)</li></ul><h3 id=4-cmyk-컬러-공간--printer>(4) CMYK 컬러 공간 : Printer<a hidden class=anchor aria-hidden=true href=#4-cmyk-컬러-공간--printer>#</a></h3><ul><li>청록(Cyan) : C=255-R</li><li>자홍(Magenta) : M=255-G</li><li>노랑(Yellow) : Y=255-B</li><li>감산 혼합</li><li>C+M+Y= 검정</li><li>K = min(C,M,Y)</li><li>C = 기존 C - K</li><li>M = 기존 M - K</li><li>Y = 기존 Y - K</li><li>인쇄를 보낼 때는 CMYK 컬러 공간으로 변환해 보내는 것이 좋다</li><li>CMYK 컬러 공간의 한계<ul><li>RGB보다 범위에 한계</li><li>다소 뿌옇게 인쇄</li><li>CMYK 형태로 직접 모니터로 불러들여 작업하지 않음</li></ul></li></ul><h2 id=5-다른-컬러-공간>5) 다른 컬러 공간<a hidden class=anchor aria-hidden=true href=#5-다른-컬러-공간>#</a></h2><h3 id=1-yiq>(1) YIQ<a hidden class=anchor aria-hidden=true href=#1-yiq>#</a></h3><ul><li>인간의 시각체계와 유사하게 흉내낸 최초의 색상공간</li><li>Y는 명조, I는 orange-cyan, Q는 Green-Magenta</li><li>1950년대, 컬러 텔레비전(NTSC방식) 개발자들의 의해 구성</li></ul><h3 id=2-ycbcr>(2) YCbCr<a hidden class=anchor aria-hidden=true href=#2-ycbcr>#</a></h3><ul><li>색상정보로 부터 명도를 분리하는 또 하나의 다른 색상 공간</li><li>Y는 명도, Cb는 푸른색, Cr, 붉은색</li><li>JPEG, MPEG 및 디지털 TV의 표준으로 사용</li></ul><h3 id=3-cie-lab--uniform-color-space>(3) CIE LAB : uniform color space<a hidden class=anchor aria-hidden=true href=#3-cie-lab--uniform-color-space>#</a></h3><ul><li>L<code>*</code>, a<code>*</code>, b<code>*</code></li><li>L<code>*</code> 는 명도, a<code>*</code> red와 green, b<code>*</code>는 yellow와 blue</li></ul><h1 id=3-화소값-기본-처리>3. 화소값 기본 처리<a hidden class=anchor aria-hidden=true href=#3-화소값-기본-처리>#</a></h1><h2 id=1-영상의-밝기-조절>1) 영상의 밝기 조절<a hidden class=anchor aria-hidden=true href=#1-영상의-밝기-조절>#</a></h2><h3 id=1-명암도-영상흑백-영상>(1) 명암도 영상(흑백 영상)<a hidden class=anchor aria-hidden=true href=#1-명암도-영상흑백-영상>#</a></h3><ul><li>한 화소당 8비트의 데이터 크기</li><li>0 ~ 255의 범위</li></ul><h3 id=2-명암값을-더하거나-뺄-경우>(2) 명암값을 더하거나 뺄 경우<a hidden class=anchor aria-hidden=true href=#2-명암값을-더하거나-뺄-경우>#</a></h3><ul><li>0이하 이거나 255이상일 때 문제 발생</li><li>클랭핌을 이용한 해결<ul><li>Saturation : 0이하 -> 0, 255 이상 -> 255</li><li>Wrap : 256 = 1, 257 = 2, 258 = 3, 반전 시키는 방법이지만 명암 불균등을 낳는다.</li></ul></li></ul><h3 id=3-영상의-산술-연산>(3) 영상의 산술 연산<a hidden class=anchor aria-hidden=true href=#3-영상의-산술-연산>#</a></h3><ul><li>밝게 = 255에 가깝게</li><li>어둡게 = 0에 가깝게</li></ul><h3 id=4-산술-연산-적용-예>(4) 산술 연산 적용 예<a hidden class=anchor aria-hidden=true href=#4-산술-연산-적용-예>#</a></h3><ul><li>차영상 : 움직임 추적에 쓰임</li></ul><h2 id=2-영상의-명암대비-조절>2) 영상의 명암대비 조절<a hidden class=anchor aria-hidden=true href=#2-영상의-명암대비-조절>#</a></h2><h3 id=1-명암-대비contrast--명암값의-분포>(1) 명암 대비(Contrast) : 명암값의 분포<a hidden class=anchor aria-hidden=true href=#1-명암-대비contrast--명암값의-분포>#</a></h3><ul><li>낮음 명암 대비 : 명암차가 적음</li><li>높은 명암 대비 : 명암차가 큼</li></ul><h3 id=2-대비의-증가--곱셈-연산>(2) 대비의 증가 = 곱셈 연산<a hidden class=anchor aria-hidden=true href=#2-대비의-증가--곱셈-연산>#</a></h3><h3 id=3-대비의-감소--나눗셈-연산>(3) 대비의 감소 = 나눗셈 연산<a hidden class=anchor aria-hidden=true href=#3-대비의-감소--나눗셈-연산>#</a></h3><h2 id=3-히스토그램>3) 히스토그램<a hidden class=anchor aria-hidden=true href=#3-히스토그램>#</a></h2><h3 id=1-히스토그램>(1) 히스토그램<a hidden class=anchor aria-hidden=true href=#1-히스토그램>#</a></h3><ul><li>각화소의 명암값의 개수</li><li>영상의 명암 값 프로필(profile) - > 히스토그램 유사도를 사용한 영상 비교에 유용하다</li></ul><h2 id=4-히스토그램-평활화>4) 히스토그램 평활화<a hidden class=anchor aria-hidden=true href=#4-히스토그램-평활화>#</a></h2><ul><li>한 쪽에 치우친 명암 분포를 가진 히스토그램을 재분배 하는 과정을 거쳐 일정한 분포를 가지게 하는 히스토그램</li><li>h(i) = (H(i)/Nt)*Gmax</li><li>h(i) : 정규화 합 히스토그램</li><li>H(i) : 누적 히스토그램</li><li>Nt : 영상에서 픽셀의 총 개수</li><li>Gmax : 영상의 최대 밝기</li></ul><h2 id=5-히스토그램-스트레칭>5) 히스토그램 스트레칭<a hidden class=anchor aria-hidden=true href=#5-히스토그램-스트레칭>#</a></h2><ul><li>명암 대비 확장, 명암 대비 스트레칭</li><li>낮은 대비의 히스토그램을 균등한 분포로 만드는 알고리즘</li><li>X: 기존 명암 값</li><li>low : 히스토그램에서 가장 작은 화소값</li><li>high : 히스토그램에서 가장 큰 화소값</li><li>새로운 명암 값 = 255*(X-low)/(high-low)</li><li>스트레칭 변형 : 엔드인 탐색(ends-in search)<ul><li>low, high의 범위 값을 지정하여 스트레칭 한다. 히스토그램의 특정 부분에 화소들이 치우진 형상을 보정하는데 유용하다.</li></ul></li><li>새로운 명암 값 = { 0 for X&lt;=low</li><li>ㅤㅤㅤㅤㅤㅤㅤㅤ{ 255*(x-low)/(high-low) for low&lt;=X&lt;high</li><li>ㅤㅤㅤㅤㅤㅤㅤㅤ{ 255 for high&lt;=X</li></ul><h2 id=6-명암-변환>6) 명암 변환<a hidden class=anchor aria-hidden=true href=#6-명암-변환>#</a></h2><h3 id=1-명암-변환intensity-transformation>(1) 명암 변환(Intensity Transformation)<a hidden class=anchor aria-hidden=true href=#1-명암-변환intensity-transformation>#</a></h3><ul><li>미리 지정된 함수 f(x)를 바탕으로 이진 화소값을 새로운 화소값으로 바꿔주는 알고리즘</li><li>널 변환(Null Transforamtion) : f(x) = x , 원영상과 같음</li><li>역 변환(Inverse Transformation) : f(x) = 255 - x (음화 영상,negative image)</li></ul><h3 id=2-비트-플래너-슬라이싱bit-planner-slicing-변환>(2) 비트 플래너 슬라이싱(bit-planner slicing) 변환<a hidden class=anchor aria-hidden=true href=#2-비트-플래너-슬라이싱bit-planner-slicing-변환>#</a></h3><ul><li>각 비트에 대하여 0인지 1인지 검사하여 하나의 영상 형태로 만든 것을 비트 평면이라고 부른다</li><li>msb는 영상의 윤곽 정보를 가장 잘 간직하고 있다.</li><li>lsb는 영상의 윤곽 정보를 거의 저장하고 있지 않다.</li><li>비트 평면 분할은 특정 비트의 중요도를 분석하는데 중요한 정보를 제공한다. 예) 영상 압축, 워터마킹 기법에 적용</li></ul><h2 id=7-이진-영상-변환-및-처리>7) 이진 영상 변환 및 처리<a hidden class=anchor aria-hidden=true href=#7-이진-영상-변환-및-처리>#</a></h2><h3 id=1-이진화>(1) 이진화<a hidden class=anchor aria-hidden=true href=#1-이진화>#</a></h3><ul><li>배경과 객체의 간단한 분리, 영상의 간략화 등의 목적으로 영상 분석 분야에서 필수적인 전처리 과정이다</li></ul><h3 id=2-경계값-설정-방법에-따른-이진-영상-생성-알고리즘>(2) 경계값 설정 방법에 따른 이진 영상 생성 알고리즘<a hidden class=anchor aria-hidden=true href=#2-경계값-설정-방법에-따른-이진-영상-생성-알고리즘>#</a></h3><ul><li>히스토그램의 분포를 파악하여 적합한 경계값을 설정</li><li>블록 이진화 기법 적용 -> 블록으로 나뉘어 평균값을 임계로</li><li>이중 경계값 설정</li><li>적응적 경계값</li><li>반복적 경계값</li><li>난수 경계값</li></ul><h3 id=3-단일-경계값과-이중-경계값-설정을-이용한-이진-영상-변환>(3) 단일 경계값과 이중 경계값 설정을 이용한 이진 영상 변환<a hidden class=anchor aria-hidden=true href=#3-단일-경계값과-이중-경계값-설정을-이용한-이진-영상-변환>#</a></h3><ul><li>단일 경계값을 이용한 이진 영상 변환</li><li>Binary-image[x][y] = { 1 if Gray-image[x][y]>=threshold</li><li>ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ{ 0 else Gray-image[x][y]&lt;threshold</li><li>이중 경계값을 이용한 이진 영상 변환</li><li>Binary-image[x][y] = { 1 if low-threshold&lt;=Gray-image[x][y]&lt;high-threshold</li><li>ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ{ 0 otherwise</li></ul><h3 id=4-히스토그램-분포를-이용한-이진-영상-변환>(4) 히스토그램 분포를 이용한 이진 영상 변환<a hidden class=anchor aria-hidden=true href=#4-히스토그램-분포를-이용한-이진-영상-변환>#</a></h3><ul><li>Otsu(온츄) Algorithm</li><li>영상의 히스토그램의 형태가 쌍봉형이라고 가정 했을 때 그 사이의 계곡점을 찾아 임계값으로 하고 분할 후, 분할 된 클래스 사이의 분산을 최대화 시키는 임계값을 찾는 방법</li><li>클래스 내의 분산과 클래스 간의 분산화 전체 구간에서의 분산을 이용하여 클래스 간의 분산이 최대가 될 때의 값(클래스 내의 분산이 가장 작을 때)을 임계값으로 한다.</li><li>전체 분산 : αa^2(t) = αw^2(t) + αb^2(t)</li><li>클래스 내의 분산 : αw^2(t) = W1(t)α1^2(t) + W2(t)α2^2(t)</li><li>클래스 간의 분산 : αb^2(t) = αb^2-αw^2 = W1(t)W2(t)[u1(t)-u2(t)]^2</li><li>Wn : 전체 클래스에 대한 각 클래스의 확률</li><li>un : 각 클래스에 대한 평균 명도값</li></ul><h3 id=5-반본적-경계값-설정-을-이용한-이진-영상-변환>(5) 반본적 경계값 설정 을 이용한 이진 영상 변환<a hidden class=anchor aria-hidden=true href=#5-반본적-경계값-설정-을-이용한-이진-영상-변환>#</a></h3><ul><li>영상의 화소 평균 값을 구할 때 모든 화소의 값을 더해서 전체화소의 개수로 나누어 평균을 계산하는 것 보다 수행 속도 면에서 훨씬 빠른 것으로 알려져 있다.</li><li>step 1. 모든 화소값의 평균값을 계산하여 초기 임계값을 T라고 한다</li><li>step 2. 그레이 스케일 값이 T 보다 작은 픽셀들의 그레이 스케일 값의 평균 u1이라고 하고, T보다 큰 스케일 값의 평균을 u2라고 하여 임계 값을 다음과 같이 계산한다</li><li>T = (u1+u2)/2</li><li>step 3. T간의 변화가 없을 때 가지 반복한다.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://jaejin0me.github.io/tags/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/>영상처리</a></li></ul></footer><script src=https://utteranc.es/client.js repo=jaejin0me/blog_comment issue-term=title label=comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>