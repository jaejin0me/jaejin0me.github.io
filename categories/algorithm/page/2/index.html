<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Algorithm | Jaejin's blog</title>
<meta name=keywords content><meta name=description content="Jaejin Jang's blog"><meta name=author content="Jaejin Jang"><link rel=canonical href=https://jaejin0me.github.io/categories/algorithm/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jaejin0me.github.io/categories/algorithm/index.xml><link rel=alternate hreflang=ko href=https://jaejin0me.github.io/categories/algorithm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T")}</script><meta property="og:title" content="Algorithm"><meta property="og:description" content="Jaejin Jang's blog"><meta property="og:type" content="website"><meta property="og:url" content="https://jaejin0me.github.io/categories/algorithm/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Algorithm"><meta name=twitter:description content="Jaejin Jang's blog"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io/ accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Algorithm</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 2747번 - 피보나치 수</h2></header><div class=entry-content><p>피보나치 수를 구하는 가장 기초적인 알고리즘입니다.
$$ F_n = F_{n-1} + F_{n-2} (n>=2) $$
점화식을 그대로 구현하여 재귀적으로 풀어내면 됩니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /** * */ import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.Queue; import java.util.Scanner; import java.util.StringTokenizer; /** * @author jaeji * */ public class Main { static int fibonacci(int no) { if(no==0) return 0; else if(no==1) return 1; else return fibonacci(no-1)+fibonacci(no-2); } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader( new InputStreamReader( System.in ) ); //BufferedReader br = new BufferedReader( new FileReader("input.txt" ) ); StringTokenizer st = new StringTokenizer(br.readLine()); int n = Integer.parseInt(st.nextToken()); int result = fibonacci(n); System.out.println(result); } }</p></div><footer class=entry-footer><span title='2018-01-26 12:20:42 +0800 +0800'>1월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 2747번 - 피보나치 수" href=https://jaejin0me.github.io/post/posts54/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 2748번 - 피보나치 수 2</h2></header><div class=entry-content><p>피보나치 수 두번째 입니다.
DP로 푸는 문제입니다.
점화식으로 풀때는 Top-down 방식이지만 DP로 풀때는 Bottom-up 방식입니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.Queue; import java.util.Scanner; import java.util.StringTokenizer; /** * @author jaeji * */ public class Main { static long[] arr = new long[91]; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader( new InputStreamReader( System.in ) ); //BufferedReader br = new BufferedReader( new FileReader("input.txt" ) ); StringTokenizer st = new StringTokenizer(br.readLine()); int n = Integer.parseInt(st.nextToken()); arr[1] = 1; for(int i=2;i&lt;=n;i++) { arr[i] = arr[i-1] + arr[i-2]; } System.out.println(arr[n]); } }</p></div><footer class=entry-footer><span title='2018-01-26 12:20:42 +0800 +0800'>1월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 2748번 - 피보나치 수 2" href=https://jaejin0me.github.io/post/posts55/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>자바에서 입력 빠르게 받기</h2></header><div class=entry-content><p>Scanner는 성능이 떨어지기 때문에 입력이 많은 경우 문제가 생깁니다.
BufferedReader와 StringTokenizer를 이용해 입력받는 것을 습관화 시키는게 좋습니다.
...</p></div><footer class=entry-footer><span title='2018-01-26 12:20:42 +0900 +0900'>1월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 자바에서 입력 빠르게 받기" href=https://jaejin0me.github.io/post/posts59/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 6086번, 최대 유량</h2></header><div class=entry-content><p>드디어 네트워크플로우
처음에 목표한 알고리즘이 MCMF까지였기 때문에, 곧 결과에 쫓기듯 공부할 필요는 없을꺼같다.
배울 알고리즘이 참 많지만 사실 그런알고리즘은 내가 앞으로 쓸일이 있을까 하는 의문이 들어서 필요성을 느끼지 못하겠다. 그리고 필요하다면 그 때 배워서 사용하면 될꺼같기도 하다. 시험문제로 나온다면.. 그저 슬플수 밖에
...</p></div><footer class=entry-footer><span title='2018-01-04 18:00:42 +0900 +0900'>1월 4, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 6086번, 최대 유량" href=https://jaejin0me.github.io/post/posts10/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>프로그래머스 - 사칙연산</h2></header><div class=entry-content><p>완전 초급용은 아닌 dp
이제 자신감이 좀 붙는고만
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import java.awt.Point; import java.util.HashMap; class Solution { static int[] intarr; public static int solution(String arr[]) { HashMap&lt;Point,Integer> dmax = new HashMap&lt;Point,Integer>(); HashMap&lt;Point,Integer> dmin = new HashMap&lt;Point,Integer>(); int len = arr.length; int max_temp = 0; int min_temp = 0; int max = 0; int min = 0; // 숫자로 변환, 및 기본값 세팅 intarr = new int[arr.length]; for(int i=0;i&lt;len;i++) { if(arr[i].equals("+")) { intarr[i] = 1001; // 플러스는 1001로 치환 } else if (arr[i].equals("-")) { intarr[i] = 1002;// 마이너스는 1002로 치환 } else { intarr[i] = Integer.parseInt(arr[i]); dmax.put(new Point(i,i), intarr[i]); dmin.put(new Point(i,i), intarr[i]); } } for(int i=2;i&lt;len;i+=2) { //하나의 연산을 포함하는 길이에서 입력의 모든 연산을 포함하는 길이가 될때까지, 길이의 증가는 +2씩(연산자 하나, 숫자하나) for(int j=0;j+i&lt;len;j+=2) { // 0자리 부터 시작해서 해당 순서의 길이까지 반복, 최대 길이를 넘지 않아야 함 max_temp = 0; min_temp = 0; max = Integer.MIN_VALUE; min = Integer.MAX_VALUE; for(int k=j;k&lt;i+j;k++) { // +,- 연산이 오는 경우 범위에서의 min과 max를 구한다. if(intarr[k]==1001) { max_temp = dmax.get(new Point(j,k-1)) + dmax.get(new Point(k+1,i+j)); min_temp = dmin.get(new Point(j,k-1)) + dmin.get(new Point(k+1,i+j)); if(max_temp>max) max = max_temp; if(min_temp&lt;min) min = min_temp; } else if(intarr[k]==1002) { max_temp = dmax.get(new Point(j,k-1)) - dmin.get(new Point(k+1,i+j)); min_temp = dmin.get(new Point(j,k-1)) - dmax.get(new Point(k+1,i+j)); if(max_temp>max) max = max_temp; if(min_temp&lt;min) min = min_temp; } } dmax.put(new Point(j,j+i), max); dmin.put(new Point(j,j+i), min); } } return dmax.get((new Point(0,len-1))); } }</p></div><footer class=entry-footer><span title='2017-12-31 16:20:42 +0800 +0800'>12월 31, 2017</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 프로그래머스 - 사칙연산" href=https://jaejin0me.github.io/post/posts53/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>프로그래머스 - 게임 맵 최단거리</h2></header><div class=entry-content><p>BFS로 구현했는데, 효율성 테스트에서 자꾸 시간초과가 나서 고민했던 문제
알고보니 중복방문을 방지하기 위한 코드가 없었음.. 방문 확인의 중요성!!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import java.util.LinkedList; import java.util.Queue; import java.awt.Point; class Solution { public static int solution(int[][] maps) { int X = maps[0].length; int Y = maps.length; boolean[][] visited = new boolean[Y][X]; Queue&lt;Point> q = new LinkedList&lt;Point>(); int x = 0; int y = 0; int size = 0; int cnt = 0; Point p = new Point(); q.add(new Point(Y-1,X-1)); while(q.isEmpty()==false) { size = q.size(); cnt++; for(int i=0;i&lt;size;i++) { p = q.peek(); x = p.y; y = p.x; q.remove(); if(visited[y][x]==true) continue; maps[y][x] = 0; visited[y][x] = true; if(x==0 && y==0) { return cnt; } if(x-1>-1 && maps[y][x-1]==1) { //왼쪽 한칸 q.add(new Point(y,x-1)); } if(x+1&lt;X && maps[y][x+1]==1) { //오른쪽 한칸 q.add(new Point(y,x+1)); } if(y-1>-1 && maps[y-1][x]==1) { //위쪽 한칸 q.add(new Point(y-1,x)); } if(y+1&lt;Y && maps[y+1][x]==1) { //아래쪽 한칸 q.add(new Point(y+1,x)); } } } return -1; } }</p></div><footer class=entry-footer><span title='2017-12-27 16:42:42 +0800 +0800'>12월 27, 2017</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 프로그래머스 - 게임 맵 최단거리" href=https://jaejin0me.github.io/post/posts52/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>프로그래머스 - 폰켓몬</h2></header><div class=entry-content><p>문제를 잘 파악하면 어렵지 않은 문제
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.HashSet; import java.util.Iterator; public class Solution { public int solution(int[] nums) { HashSet&lt;Integer> abc = new HashSet&lt;Integer>(); for(int i=0;i&lt;nums.length;i++) { abc.add(nums[i]); } if(abc.size()>nums.length/2) return nums.length/2; else return abc.size(); } }</p></div><footer class=entry-footer><span title='2017-12-27 16:42:42 +0800 +0800'>12월 27, 2017</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 프로그래머스 - 폰켓몬" href=https://jaejin0me.github.io/post/posts51/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>좌표압축</h2></header><div class=entry-content><p>알고리즘을 풀다 보면 좌표압축이라는 테크닉이 필요합니다.저는 좌표압축을 “순위가 중요한 알고리즘에서, 입력값의 갯수보다 입력값의 범위가 클 때 사용하는 방법”, 이라고 생각하고 있습니다.
1차원의 좌표로 예를 들어보겠습니다.n개의 x값 을 입력 받아, 입력 중 두개의 x1,x2를 선택하여 사이에 존재하는 점의 개수를 구하는 작업이 있다고 가정합시다.
x의 범위는 int형의 범위인 -2^31 ~ 2^31-1 이고 중복은 없습니다. n은 5000 이하입니다.입력은 n : 7, -2^31, -10000, 0 , -2000, 3, 6, 30000 , x1 = -10000, x2 = 30000
대략적으로 보면 그림과 같이 나타나게 됩니다.
...</p></div><footer class=entry-footer><span title='2017-12-24 01:07:56 +0800 +0800'>12월 24, 2017</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 좌표압축" href=https://jaejin0me.github.io/post/posts50/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>int 배열 오름차순 정렬을 이용해 내림차순 쉽게 구하기</h2></header><div class=entry-content><p>타입에러 때문에 제공하는 정렬함수를 쓸 수 없을때 그리고 형변환 하기 귀찮을 때
comparator, comparable의 재정의 없이 간단하게 정렬할 수 있는 방법입니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 //예; sort라는 오름차순정렬 함수가 정의된 경우 int[] B = ~~~~~~ //오름차순 정렬 sort(B); //내림차순 정렬 for(int i=0;i&lt;B.length;i++) B[i] = -B[i] sort(B); for(int i=0;i&lt;B.length;i++) B[i] = -B[i]</p></div><footer class=entry-footer><span title='2017-12-23 01:37:56 +0800 +0800'>12월 23, 2017</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to int 배열 오름차순 정렬을 이용해 내림차순 쉽게 구하기" href=https://jaejin0me.github.io/post/posts18/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 1003번, 피보나치 함수</h2></header><div class=entry-content><p>(n)을 했을때 fib(0),와 fib(1)이 몇번 콜되는지 구하는 문제입니다.
전략 : 전역 변수 2개를 할당해, fib(0)을 부를때 증가시키고, fib(1)을 부를때 증가시키는 것으로 해서 풀었습니다.
...</p></div><footer class=entry-footer><span title='2017-12-23 01:37:56 +0800 +0800'>12월 23, 2017</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 1003번, 피보나치 함수" href=https://jaejin0me.github.io/post/posts36/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://jaejin0me.github.io/categories/algorithm/>«&nbsp;이전 페이지&nbsp;
</a><a class=next href=https://jaejin0me.github.io/categories/algorithm/page/3/>다음 페이지&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>