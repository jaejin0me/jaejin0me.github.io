<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>algorithm on Jaejin's blog</title><link>https://jaejin0me.github.io/categories/algorithm/</link><description>Recent content in algorithm on Jaejin's blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><copyright>Jaejin Jang</copyright><lastBuildDate>Mon, 26 Nov 2018 00:33:42 +0900</lastBuildDate><atom:link href="https://jaejin0me.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>백준알고리즘 1110번 - 더하기 사이클</title><link>https://jaejin0me.github.io/post/posts66/</link><pubDate>Mon, 26 Nov 2018 00:33:42 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts66/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include &amp;lt;iostream&amp;gt; #pragma warning(disable:4996) using namespace std; int main(void) { int num, tmp, cnt = 0; cin.tie(NULL); ios_base::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;#34;input.txt&amp;#34;, &amp;#34;r&amp;#34;, stdin); freopen(&amp;#34;output.txt&amp;#34;, &amp;#34;w&amp;#34;, stdout); #endif cin &amp;gt;&amp;gt; num; tmp = num; do { tmp =</description></item><item><title>백준알고리즘 4344번 - 평균은 넘겠지</title><link>https://jaejin0me.github.io/post/posts65/</link><pubDate>Mon, 26 Nov 2018 00:30:42 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts65/</guid><description>제목 재밌네 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iomanip&amp;gt; #pragma warning(disable:4996) using namespace std; int</description></item><item><title>백준알고리즘 1546번 - 평균</title><link>https://jaejin0me.github.io/post/posts64/</link><pubDate>Mon, 26 Nov 2018 00:23:42 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts64/</guid><description>요즘 다시 시작한 알고리즘 공부.. 쉬운거 부터 풀어 봅시다 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &amp;lt;iostream&amp;gt;</description></item><item><title>백준알고리즘 5651번 - 완전 중요한 간선</title><link>https://jaejin0me.github.io/post/posts63/</link><pubDate>Sun, 11 Feb 2018 12:20:42 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts63/</guid><description>중요한 간선을 찾는 코드에서 prev2[next2.to] 가 되어있어야 하는데 prev2[curr2]로 되어 있는 것을 발견하지 못해 푸는데 오래 걸린 문제이다. 중요한 간선의 여부는 최대</description></item><item><title>백준알고리즘 11495번 - 격자 0 만들기</title><link>https://jaejin0me.github.io/post/posts62/</link><pubDate>Sun, 04 Feb 2018 12:20:42 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts62/</guid><description>시간초과가 계속해서 나는 것은 최적화 하면서 근근이 풀긴했는데, 속도가 많이 느리다. 자바로 풀 사람들 중에서 꼴등임 ㅎ 다른 정답자들의 풀이를 보니, 나는 에드몬드</description></item><item><title>백준알고리즘 2316번 - 도시 왕복하기</title><link>https://jaejin0me.github.io/post/posts61/</link><pubDate>Tue, 30 Jan 2018 12:20:42 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts61/</guid><description>어제 못 풀고 오늘에서야 푼 문제 정점을 1번만 지나는 조건을 만족하기 위해 정점을 분할하고 분할된 정점사이에 용량의 1의 간선을 추가해야 한다. 주의해야 할 것은 입력</description></item><item><title>백준알고리즘 2188번 - 축사배정</title><link>https://jaejin0me.github.io/post/posts60/</link><pubDate>Sun, 28 Jan 2018 12:20:42 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts60/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70</description></item><item><title>백준알고리즘 1929번 - 소수 구하기</title><link>https://jaejin0me.github.io/post/posts57/</link><pubDate>Fri, 26 Jan 2018 12:20:42 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts57/</guid><description>주어진 두 정수 범위내의 소수를 구하는 문제입니다. 에라토스테네스의 체 라는 것을 사용해 구합니다. 개념적으로 주의해야 할 것은 소수 판별하는 것과 다릅니다. 에라</description></item><item><title>백준알고리즘 1978번 - 소수 찾기</title><link>https://jaejin0me.github.io/post/posts56/</link><pubDate>Fri, 26 Jan 2018 12:20:42 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts56/</guid><description>주어지는 수들 중에서 소수의 개수를 출력하는 문제입니다. 소수를 판별하는 가장 기초적인 방법인 2~n-1 까지 나눠지는지 확인해서 판별하면 됩니다. 또한 $$\sqrt{n}$$ 까지 나눠지는</description></item><item><title>백준알고리즘 2609번 - 최대공약수와 최소공배수</title><link>https://jaejin0me.github.io/post/posts58/</link><pubDate>Fri, 26 Jan 2018 12:20:42 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts58/</guid><description>두 자연수의 최대 공약수와, 최소 공배수를 출력하는 문제입니다. 유클리드 호제법을 이용해 최대공약수를 구하고 최대공야수를 이용해 최소 공배수를 구하면 됩니다.</description></item><item><title>백준알고리즘 2747번 - 피보나치 수</title><link>https://jaejin0me.github.io/post/posts54/</link><pubDate>Fri, 26 Jan 2018 12:20:42 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts54/</guid><description>피보나치 수를 구하는 가장 기초적인 알고리즘입니다. $$ F_n = F_{n-1} + F_{n-2} (n&amp;gt;=2) $$ 점화식을 그대로 구현하여 재귀적으로 풀어내면 됩니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</description></item><item><title>백준알고리즘 2748번 - 피보나치 수 2</title><link>https://jaejin0me.github.io/post/posts55/</link><pubDate>Fri, 26 Jan 2018 12:20:42 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts55/</guid><description>피보나치 수 두번째 입니다. DP로 푸는 문제입니다. 점화식으로 풀때는 Top-down 방식이지만 DP로 풀때는 Bottom-up 방식입니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20</description></item><item><title>자바에서 입력 빠르게 받기</title><link>https://jaejin0me.github.io/post/posts59/</link><pubDate>Fri, 26 Jan 2018 12:20:42 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts59/</guid><description>Scanner는 성능이 떨어지기 때문에 입력이 많은 경우 문제가 생깁니다. BufferedReader와 StringTokenizer를 이용해 입력받</description></item><item><title>백준알고리즘 6086번, 최대 유량</title><link>https://jaejin0me.github.io/post/posts10/</link><pubDate>Thu, 04 Jan 2018 18:00:42 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts10/</guid><description>드디어 네트워크플로우 처음에 목표한 알고리즘이 MCMF까지였기 때문에, 곧 결과에 쫓기듯 공부할 필요는 없을꺼같다. 배울 알고리즘이 참 많지만 사실 그런알고리</description></item><item><title>프로그래머스 - 사칙연산</title><link>https://jaejin0me.github.io/post/posts53/</link><pubDate>Sun, 31 Dec 2017 16:20:42 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts53/</guid><description>완전 초급용은 아닌 dp 이제 자신감이 좀 붙는고만 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50</description></item><item><title>프로그래머스 - 게임 맵 최단거리</title><link>https://jaejin0me.github.io/post/posts52/</link><pubDate>Wed, 27 Dec 2017 16:42:42 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts52/</guid><description>BFS로 구현했는데, 효율성 테스트에서 자꾸 시간초과가 나서 고민했던 문제 알고보니 중복방문을 방지하기 위한 코드가 없었음.. 방문 확인의 중요성!! 1 2 3 4</description></item><item><title>프로그래머스 - 폰켓몬</title><link>https://jaejin0me.github.io/post/posts51/</link><pubDate>Wed, 27 Dec 2017 16:42:42 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts51/</guid><description>문제를 잘 파악하면 어렵지 않은 문제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.HashSet; import java.util.Iterator; public class Solution { public int solution(int[] nums) { HashSet&amp;lt;Integer&amp;gt; abc = new HashSet&amp;lt;Integer&amp;gt;(); for(int i=0;i&amp;lt;nums.length;i++) { abc.add(nums[i]); } if(abc.size()&amp;gt;nums.length/2) return nums.length/2; else return abc.size(); } }</description></item><item><title>좌표압축</title><link>https://jaejin0me.github.io/post/posts50/</link><pubDate>Sun, 24 Dec 2017 01:07:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts50/</guid><description>알고리즘을 풀다 보면 좌표압축이라는 테크닉이 필요합니다.저는 좌표압축을 &amp;ldquo;순위가 중요한 알고리즘에서, 입력값의 갯수보다 입력값의 범위가 클 때</description></item><item><title>int 배열 오름차순 정렬을 이용해 내림차순 쉽게 구하기</title><link>https://jaejin0me.github.io/post/posts18/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts18/</guid><description>타입에러 때문에 제공하는 정렬함수를 쓸 수 없을때 그리고 형변환 하기 귀찮을 때 comparator, comparable의 재정의 없이 간단하게 정렬할 수 있는 방법입니다. 1 2 3 4</description></item><item><title>백준알고리즘 1003번, 피보나치 함수</title><link>https://jaejin0me.github.io/post/posts36/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts36/</guid><description>(n)을 했을때 fib(0),와 fib(1)이 몇번 콜되는지 구하는 문제입니다. 전략 : 전역 변수 2개를 할당해, fib(0)을 부를때 증가시키고, fib</description></item><item><title>백준알고리즘 10828번, 스택</title><link>https://jaejin0me.github.io/post/posts32/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts32/</guid><description>스택의 기본적인 연산 5가지인 push,pop,top,empty,size를 구현하는 문제이다. 별다른 풀이 전략이 필요하지 않다, 그냥 구현만 해내면 그</description></item><item><title>백준알고리즘 10845번, 큐</title><link>https://jaejin0me.github.io/post/posts34/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts34/</guid><description>큐를 구현하는 문제이다. push,pop,empty,size,front,back 함수를 구현해야 한다. 배열을 이용해 구현하였다. 고려해야 할 것은 앞과 끝을 가르키는 위치를 갖고 있어야 된다는 정도이다. 정해진 배열</description></item><item><title>백준알고리즘 1149번, RGB거리</title><link>https://jaejin0me.github.io/post/posts37/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts37/</guid><description>RGB 색상별로 가중치가 주어질 때, 가장 값이 낮게 집을 칠하는 문제입니다. 전략 : 특별한 전략은 필요 없네요. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</description></item><item><title>백준알고리즘 1167번, 트리의 지름</title><link>https://jaejin0me.github.io/post/posts45/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts45/</guid><description>트리의 지름은 두 vertex간의 길이가 가장 긴 값입니다. 이 문제에서는 간선에 가중치가 있기 때문에 멀어도 길이가 짧은 수 있고 그 반대가 될 수도 있습니다. 트리의</description></item><item><title>백준알고리즘 11725번, 트리의 부모 찾기</title><link>https://jaejin0me.github.io/post/posts43/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts43/</guid><description>연결된 두 vertex의 정보가 주어질 때 각 노드의 부모를 찾아서 2번부터 출력해주는 문제입니다. 처음에 접근할때는 행렬로 풀려고 했는데, 다익스트라 알고리즘</description></item><item><title>백준알고리즘 1753번, 최단경로</title><link>https://jaejin0me.github.io/post/posts42/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts42/</guid><description>다익스트라 알고리즘을 공부하기 위해서 풀어본 문제입니다.. 어렵네요 어려웠어요 휴.. 구현할때 주의하실 점은 인접리스트랑 우선순위큐 꼭 쓰세요! 노드의 갯수</description></item><item><title>백준알고리즘 1874번, 스택 수열</title><link>https://jaejin0me.github.io/post/posts33/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts33/</guid><description>이번 문제에서는 스택을 클래스로 만들어 사용했다. 1~n까지의 수로 이루어진 수열을 스택을 이용해 재현해내는 문제이다. push를 할때는 1부터 순서대로 진행</description></item><item><title>백준알고리즘 1932번, 숫자삼각형</title><link>https://jaejin0me.github.io/post/posts38/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts38/</guid><description>피라미드 형태의 삼각형이 주어질때 아래로 내려가면서 최대의 값을 찾는 문제입니다 전략 : 별다른 전략 필요가 없네요 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21</description></item><item><title>백준알고리즘 1991번, 트리 사용하기</title><link>https://jaejin0me.github.io/post/posts40/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts40/</guid><description>그래프와 트리쪽 알고리즘이 약해서 요즘 이 파트를 공부하고있습니다. 2진 트리의 원소를 입력받아 순회 종류별로 출력해주는 문제입니다. 재귀적으로 깔끔하게 푸는</description></item><item><title>백준알고리즘 2750번, 수 정렬하기</title><link>https://jaejin0me.github.io/post/posts35/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts35/</guid><description>1~N 까지의 수를 임의로 입력 받아 정렬하는 문제 입니다. 버블, 삽입, 선택 정렬 3가지를 이용해 풀어봤습니다. 버블 정렬만 알고 있었는데 이번 기회로 삽입, 선택 정렬</description></item><item><title>백준알고리즘 7576번, 토마토</title><link>https://jaejin0me.github.io/post/posts41/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts41/</guid><description>토마토의 상태가 행렬로 주어질 때, 모든 토마토가 익는데 걸리는 시간을 구하는 문제입니다. 큐를 이용해서 BFS로 풀었습니다. 공부많이 됐네용. 입력값이 행렬로</description></item><item><title>카카오 코드 페스티벌 예선 4번, 보행자 천국</title><link>https://jaejin0me.github.io/post/posts44/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts44/</guid><description>안녕하세요. 오랜만에 카카오 코드 페스티벌 풀이를 쓰네요.문제가 어렵다 보니 쉽게 손이 안 갑니다. ㅎㅎ 4번 문제는 https://www.welcomekakao.com/learn/challenges/630 에서 확인하실 수가 있습니다. 동적계획법으</description></item><item><title>카카오 코드 페스티벌 예선 5번, 캠핑</title><link>https://jaejin0me.github.io/post/posts46/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts46/</guid><description>안녕하세요. 오늘은 카카오 코드 페스티벌 예선에 나온 5번 캠핑 문제에 대해 풀이를 해보겠습니다. 문제는 https://www.welcomekakao.com/learn/challenges/667 에서 확인하실 수 있습니다. 시간 복잡도 간단히 모든 경우</description></item><item><title>카카오 코드 페스티벌 예선 5번, 캠핑 풀이 - 2</title><link>https://jaejin0me.github.io/post/posts47/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts47/</guid><description>이전에 포스팅한 정석 풀이 말고 다른 풀이를 보여드리겠습니다. 다른 정답들을 보다가 출제의도와는 다르지만 최적화를 통해 시간내에 풀었고(하지만 시간 차이는 꽤 납</description></item><item><title>카카오 코드 페스티벌 예선1번, 카카오 프렌즈 컬러링북</title><link>https://jaejin0me.github.io/post/posts39/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts39/</guid><description>처음으로 참가한 알고리즘 대회인데, 이 대회 덕분에 알고리즘 공부를 시작하게 되었죠. 본선 진출 1문제 차이로 탈락했었습니다. 이 문제는 1번 문제인데요, 행렬로</description></item><item><title>프로그래머스 - 2 x n 타일링</title><link>https://jaejin0me.github.io/post/posts48/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts48/</guid><description>주의해야 할것은 오버플로우! 나머지 연산이 포인트 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class TryHelloWorld { static long[] dp = new long[10000]; public int tiling(int n) { dp[0] = 1; dp[1] = 2; for(int i=2;i&amp;lt;n;i++) { dp[i] = (dp[i-2]*2)+(dp[i-1]-dp[i-2]); if(dp[i]&amp;gt;99999)</description></item><item><title>프로그래머스 - 2016년</title><link>https://jaejin0me.github.io/post/posts49/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts49/</guid><description>Date 오브젝트 쓰기! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class TryHelloWorld { public String getDayName(int a, int b) { String answer = &amp;#34;&amp;#34;; SimpleDateFormat sdf = new SimpleDateFormat(&amp;#34;yyyy-MM-dd&amp;#34;); SimpleDateFormat sdf2 = new SimpleDateFormat(&amp;#34;E&amp;#34;); String dateInString</description></item><item><title>프로그래머스 - N개의 최소공배수</title><link>https://jaejin0me.github.io/post/posts17/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts17/</guid><description>2개의 값에 대하여 gcd를 이용해 lcm을 구하는 것을 N개에 대해 반복함 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class NLCM { public long gcd(long a,long b) { if(a==0) return</description></item><item><title>프로그래머스 - 가운데 글자 가져오기</title><link>https://jaejin0me.github.io/post/posts21/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts21/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class StringExercise{ String getMiddle(String word){ int len = word.length(); if(len%2==0) {//짝수 return word.substring(len/2-1, len/2+1); } else {//홀수 return word.substring(len/2, len/2+1); } } // 아래는 테스트로 출력해 보기 위한 코드입니다. public static</description></item><item><title>프로그래머스 - 가장 큰 정사각형 찾기</title><link>https://jaejin0me.github.io/post/posts5/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts5/</guid><description>이 문제는 이제 익숙해진 유형 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class TryHelloWorld { public int findLargestSquare(char [][]board) { int max=0; int min=0; for(int i=0;i&amp;lt;board.length;i++) {</description></item><item><title>프로그래머스 - 공항 건설하기</title><link>https://jaejin0me.github.io/post/posts6/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts6/</guid><description>원래 dp로 풀었는데 알고보니, 단순 비교문제였음.. 그냥 사람수가 가장 많은 도시는 고르면 되는 문제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26</description></item><item><title>프로그래머스 - 나누어 떨어지는 숫자 배열</title><link>https://jaejin0me.github.io/post/posts26/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts26/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import java.util.Arrays; public class Divisible { public int[] divisible(int[] array, int divisor) { int[] temp = new int[array.length]; int idx = 0; for(int i=0;i&amp;lt;array.length;i++) { if(array[i]%divisor==0) { temp[idx++] = array[i]; } } int[] ret = new int[idx]; for(int i=0;i&amp;lt;idx;i++) { ret[i] = temp[i]; } return</description></item><item><title>프로그래머스 - 다음 큰 숫자</title><link>https://jaejin0me.github.io/post/posts7/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts7/</guid><description>내 풀이는 좀 허접&amp;hellip; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 { public int nextBigNumber(int n) { int answer = 0; char temp; String a = Integer.toBinaryString(n); char[] str = a.toCharArray(); int idx</description></item><item><title>프로그래머스 - 땅따먹기 게임</title><link>https://jaejin0me.github.io/post/posts8/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts8/</guid><description>dp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import java.util.Arrays; public class Hopscotch { int hopscotch(int[][] board, int size) { for(int i=1;i&amp;lt;size;i++) { board[i][0] += board[i-1][1] &amp;gt; board[i-1][2] ? (board[i-1][1] &amp;gt; board[i-1][3] ? board[i-1][1] : board[i-1][3]) : board[i-1][2] &amp;gt; board[i-1][3] ? board[i-1][2] : board[i-1][3]; board[i][1] += board[i-1][0] &amp;gt; board[i-1][2] ? (board[i-1][0] &amp;gt;</description></item><item><title>프로그래머스 - 멀리 뛰기</title><link>https://jaejin0me.github.io/post/posts9/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts9/</guid><description>dp dp[i] = dp[i-2] + dp[i-1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class JumpCase { static int[] dp = new int[10000]; public int jumpCase(int num) { int answer = 0; dp[0] = 1; dp[1] = 2; for(int i=2;i&amp;lt;num;i++) { dp[i] = dp[i-2]+dp[i-1]; } return dp[num-1]; } public static void main(String[] args) { JumpCase</description></item><item><title>프로그래머스 - 문자열 내림차순으로 배치하기</title><link>https://jaejin0me.github.io/post/posts11/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts11/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import java.util.Arrays; public class ReverseStr { public String reverseStr(String str){ String ans = &amp;#34;&amp;#34;; char[] temp = str.toCharArray(); Arrays.sort(temp); for(int i=0;i&amp;lt;temp.length;i++) { ans+=temp[temp.length-1-i]; } return ans; } // 아래는 테스트로 출력해 보기 위한 코드입니다. public</description></item><item><title>프로그래머스 - 삼각형 출력하기</title><link>https://jaejin0me.github.io/post/posts22/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts22/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class PrintTriangle { public String printTriangle(int num){ String ret = &amp;#34;&amp;#34;; for(int i=0;i&amp;lt;num;i++) { for(int j=0;j&amp;lt;=i;j++) { ret+=&amp;#34;*&amp;#34;; } ret+=&amp;#34;\n&amp;#34;; } return ret; } // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args)</description></item><item><title>프로그래머스 - 서울에서김서방찾기</title><link>https://jaejin0me.github.io/post/posts23/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts23/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class FindKim { public String findKim(String[] seoul){ //x에 김서방의 위치를 저장하세요. int x = 0; for(int i=0;i&amp;lt;seoul.length;i++) { if(seoul[i].equals(&amp;#34;Kim&amp;#34;)) { x=i; break; } } return &amp;#34;김서방은</description></item><item><title>프로그래머스 - 소수 찾기</title><link>https://jaejin0me.github.io/post/posts12/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts12/</guid><description>label이 break, continue와 사용가능해서 좋은 자바:) 좀 더 좋은 소수찾는 방법으로 풀어봐야지 한번 더 시도해봐야지 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</description></item><item><title>프로그래머스 - 숫자의 표현</title><link>https://jaejin0me.github.io/post/posts13/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts13/</guid><description>내 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class Expressions { public int expressions(int num) { int sum=0; int first = 0; int cnt=0; for(int i=1;i&amp;lt;=num/2;i++) { sum = 0; first = i; while(true) { sum+=first++; if(sum==num) { cnt++; break; } else if(sum&amp;gt;num) {</description></item><item><title>프로그래머스 - 스트링을 숫자로 바꾸기</title><link>https://jaejin0me.github.io/post/posts24/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts24/</guid><description>1 2 3 4 5 6 7 8 9 10 11 public class StrToInt { public int getStrToInt(String str) { return Integer.parseInt(str); } //아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String args[]) { StrToInt strToInt = new StrToInt(); System.out.println(strToInt.getStrToInt(&amp;#34;-1234&amp;#34;)); } } 직접 변환하는 것이 문제의</description></item><item><title>프로그래머스 - 시저 암호</title><link>https://jaejin0me.github.io/post/posts14/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts14/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Caesar { String caesar(String s, int n) { n%=26; String result = &amp;#34;&amp;#34;; char[] temp = s.toCharArray(); for(int i=0;i&amp;lt;temp.length;i++) { if(temp[i]&amp;gt;=&amp;#39;a&amp;#39; &amp;amp;&amp;amp;temp[i]&amp;lt;=&amp;#39;z&amp;#39;) temp[i] = (char) ((temp[i]+n)&amp;gt;&amp;#39;z&amp;#39; ? (temp[i]+n-1)%&amp;#39;z&amp;#39;+&amp;#39;a&amp;#39; : (temp[i]+n)); else if(temp[i]&amp;gt;=&amp;#39;A&amp;#39; &amp;amp;&amp;amp;temp[i]&amp;lt;=&amp;#39;Z&amp;#39;) temp[i] = (char) ((temp[i]+n)&amp;gt;&amp;#39;Z&amp;#39; ? (temp[i]+n-1)%&amp;#39;Z&amp;#39;+&amp;#39;A&amp;#39; : (temp[i]+n)); result+=temp[i]; } return result; } public</description></item><item><title>프로그래머스 - 야근 지수</title><link>https://jaejin0me.github.io/post/posts15/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts15/</guid><description>좀 지저분하긴해도 시간초과 까지 개선한 코드.. N^2으로 풀어도 5초가 넘어서(정답 처리는 됨) 좀더 최적화 해봄 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20</description></item><item><title>프로그래머스 - 약수의 합</title><link>https://jaejin0me.github.io/post/posts25/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts25/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class SumDivisor { public int sumDivisor(int num) { int answer = 0; for(int i=1;i&amp;lt;=num/2;i++) { if(num%i==0) { answer+=i; } } answer+=num; return answer; } // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args)</description></item><item><title>프로그래머스 - 정수 내림차순으로 배치하기</title><link>https://jaejin0me.github.io/post/posts16/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts16/</guid><description>toCharArray를 쓰니 간편하군욤 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.util.Arrays; public class ReverseInt { public int reverseInt(int n){ int answer = 0; String a = Integer.toString(n); char[] tmp = a.toCharArray(); Arrays.sort(tmp); for(int i=0;i&amp;lt;a.length();i++) { answer*=10; answer+=tmp[a.length()-1-i]-&amp;#39;0&amp;#39;; }</description></item><item><title>프로그래머스 - 줄서는 방법</title><link>https://jaejin0me.github.io/post/posts4/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts4/</guid><description>문제가 점점 어려워지는군욤 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import java.util.ArrayList; import java.util.Arrays; public class LineCombination { public int[] setAlign(int n, long k) { int[] answer = new int[n]; ArrayList&amp;lt;Integer&amp;gt; list =</description></item><item><title>프로그래머스 - 최고의 집합</title><link>https://jaejin0me.github.io/post/posts3/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts3/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import java.util.Arrays; //테스트로 출력해 보기 위한 코드입니다. public class BestSet { public int[] bestSet(int n, int s){ int[] answer = null; if(n&amp;gt;s) { answer = new</description></item><item><title>프로그래머스 - 최대값과 최소값</title><link>https://jaejin0me.github.io/post/posts28/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts28/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.Vector; public class GetMinMaxString { public String getMinMaxString(String str) { Integer min=Integer.MAX_VALUE,max=Integer.MIN_VALUE; String[] sepstr = str.split(&amp;#34; &amp;#34;); Vector&amp;lt;Integer&amp;gt; vec = new Vector&amp;lt;Integer&amp;gt;(); for(int i=0;i&amp;lt;sepstr.length;i++) { vec.addElement(Integer.parseInt(sepstr[i])); } for(int i=0;i&amp;lt;vec.size();i++) { if(vec.get(i)&amp;lt;min) { min = vec.get(i); } if(vec.get(i) &amp;gt; max) {</description></item><item><title>프로그래머스 - 최대공약수와 최소공배수</title><link>https://jaejin0me.github.io/post/posts31/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts31/</guid><description>유클리트 호제법으로 gcd를 구하고, gcd를 이용해 lcm을 구했다. 포인트는 gcd를 이용해 lcm을 구하는 것이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</description></item><item><title>프로그래머스 - 최솟값 만들기</title><link>https://jaejin0me.github.io/post/posts19/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts19/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import java.util.Arrays; public class TryHelloWorld { public int getMinSum(int []A, int []B) { int answer = 0; Arrays.sort(A); Arrays.sort(B); for(int i=0;i&amp;lt;B.length;i++) { answer += A[i]*B[B.length-1-i]; } return answer; } public static void main(String[] args) { TryHelloWorld test = new TryHelloWorld(); int []A = {1,2}; int</description></item><item><title>프로그래머스 - 콜라츠 추측</title><link>https://jaejin0me.github.io/post/posts2/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts2/</guid><description>연산도중에 int형의 범위를 넘어갈 수 있기 때문에 long으로 바꿔주는 것이 포인트! 시간 많이 날림 ㅜ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25</description></item><item><title>프로그래머스 - 평균구하기</title><link>https://jaejin0me.github.io/post/posts30/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts30/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class GetMean { public int getMean(int[] array) { int sum=0; for(int i=0;i&amp;lt;array.length;i++) { sum+=array[i]; } return sum/array.length; } public static void main(String[] args) { int x[] = {5, 4, 3}; GetMean getMean = new GetMean(); // 아래는 테스트로 출력해 보기 위한 코드</description></item><item><title>프로그래머스 - 피보나치 수</title><link>https://jaejin0me.github.io/post/posts27/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts27/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Fibonacci { public long fibonacci(int num) { if(num==0) { return 0; } else if(num==1){ return 1; } else{ return fibonacci(num-1)+fibonacci(num-2); } } // 아래는 테스트로 출력해 보기 위한 코드입니다. public static void main(String[] args)</description></item><item><title>프로그래머스 - 하샤드 수</title><link>https://jaejin0me.github.io/post/posts20/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts20/</guid><description>나의 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import java.util.Arrays; public class TryHelloWorld { public int getMinSum(int []A, int []B) { int answer = 0; Arrays.sort(A); Arrays.sort(B); for(int i=0;i&amp;lt;B.length;i++) { answer += A[i]*B[B.length-1-i]; } return answer; } public static void main(String[] args) { TryHelloWorld test = new TryHelloWorld(); int</description></item><item><title>프로그래머스 - 행렬의 곱셈</title><link>https://jaejin0me.github.io/post/posts1/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts1/</guid><description>머리속에서는 쉽지만 막상 구현하면 헷갈려서 잘 틀리는 행렬곱&amp;hellip; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class ProductMatrix { public int[][] productMatrix(int[][] A, int[][] B) { if(A[0].length!=B.length) return null;</description></item><item><title>프로그래머스 - 행렬의 덧셈</title><link>https://jaejin0me.github.io/post/posts29/</link><pubDate>Sat, 23 Dec 2017 01:37:56 +0800</pubDate><guid>https://jaejin0me.github.io/post/posts29/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class SumMatrix { int[][] sumMatrix(int[][] A, int[][] B) { int[][] answer = new int[A.length][A[0].length]; for(int i=0;i&amp;lt;A.length;i++) { for(int j=0;j&amp;lt;A[0].length;j++) { answer[i][j] = A[i][j]+B[i][j]; } } return answer; } // 아래는 테스트로 출력해 보기 위한</description></item></channel></rss>