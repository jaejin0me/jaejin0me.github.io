<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sql 튜닝 on Jaejin's blog</title><link>https://jaejin0me.github.io/tags/sql-%ED%8A%9C%EB%8B%9D/</link><description>Recent content in sql 튜닝 on Jaejin's blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Jaejin Jang</copyright><lastBuildDate>Wed, 29 May 2019 01:39:17 +0900</lastBuildDate><atom:link href="https://jaejin0me.github.io/tags/sql-%ED%8A%9C%EB%8B%9D/index.xml" rel="self" type="application/rss+xml"/><item><title>책뿌숴짐 - SQL 레벨업 9</title><link>https://jaejin0me.github.io/post/posts182/</link><pubDate>Wed, 29 May 2019 01:39:17 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts182/</guid><description>9장. 갱신과 데이터 모델 - 망치와 못 26강. 갱신을 효율적으로 갱신을 효율적으로 수행하는 SQL을 케이스 스터디 1. NULL 채우기 1 2 3 4 5 6 7 8 9 UPDATE OmitTbl SET val = (SELECT</description></item><item><title>책뿌수기 - SQL 레벨업 8</title><link>https://jaejin0me.github.io/post/posts181/</link><pubDate>Tue, 28 May 2019 23:49:45 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts181/</guid><description>8장. SQL의 순서 - 깨어나는 절차 지향 sql은 관계 모델의 이론에 기초하고 있기 때문에 순번을 다루기 위한 기능이 없다. 하지만 레코드에 순번을 붙여 처리하는 경</description></item><item><title>책뿌수기 - SQL 레벨업 7</title><link>https://jaejin0me.github.io/post/posts109/</link><pubDate>Thu, 07 Feb 2019 22:20:56 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts109/</guid><description>최근 sql 튜닝에 대해서 책도 보고 유투브에서 동영상도 몇편 봤었는데 그 중에서 저에게 가장 큰 통찰?을 줬던 영상이 있어서 링크 올립니다 [SQL Unplugged 2013] 쉽고 재미있는 인덱스 이야</description></item><item><title>책뿌수기 - SQL 레벨업 6</title><link>https://jaejin0me.github.io/post/posts107/</link><pubDate>Thu, 31 Jan 2019 22:20:56 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts107/</guid><description>6. 결합(결합을 지배하는 자가 SQL을 지배한다) ch 18. 기능적인 관점으로 구분하는 결합의 종류 크로스 결합 내부 결합 외부 결합 자기 결합 등가 결합/비등가 결합 자연</description></item><item><title>책뿌수기 - SQL 레벨업 7</title><link>https://jaejin0me.github.io/post/posts108/</link><pubDate>Thu, 31 Jan 2019 22:20:56 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts108/</guid><description>7. 서브쿼리(곤란한 부분은 분할해야만 할까?) ch 21. 서브쿼리가 일으키는 폐해 1) 서브쿼리의 문제점 성능적 문제는 서브쿼리가 실체적인 데이터를 저장하고 있지 않다</description></item><item><title>책뿌수기 - SQL 레벨업 5</title><link>https://jaejin0me.github.io/post/posts106/</link><pubDate>Wed, 30 Jan 2019 22:20:56 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts106/</guid><description>인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다 5. 반복된(절차 지향형의 속박) ch 14. 반복문 의존증 RDB는 관계 전체를 조작의 대상으로 삼기 때문에 설계상에서</description></item><item><title>책뿌수기 - SQL 레벨업 4</title><link>https://jaejin0me.github.io/post/posts105/</link><pubDate>Tue, 29 Jan 2019 22:20:56 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts105/</guid><description>4. 집약과 자르기 ch 12. 집약 COUNT, SUM, AVG, MAX, MIN(Aggregate function) 1) 여러 개의 리코드를 한 개의 레코드로 집합 필드 수가 다르면 UNION 적용이 불가능하다. 또한 UNION으로 여러개의 쿼리를 머지</description></item><item><title>책뿌수기 - SQL 레벨업 3</title><link>https://jaejin0me.github.io/post/posts104/</link><pubDate>Sun, 20 Jan 2019 22:20:56 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts104/</guid><description>3. SQL의 조건 분기 ch 8. UNION을 사용한 쓸데없이 긴 표현 UNION을 사용한 조건 분기는 좋지 않다. UNION은 내부적으로 여러개의 SELECT 구문을 실행하는 실</description></item><item><title>책뿌수기 - SQL 레벨업-2</title><link>https://jaejin0me.github.io/post/posts103/</link><pubDate>Sun, 20 Jan 2019 22:20:56 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts103/</guid><description>인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다 1. SQL 기초 ch 6. SELECT 구문 1) SELECT 구와 FROM 구 SELECT 1 처럼 상수를 선택하는 경우 FROM이 필요없다. )2) WHERE 구 WHERE 구의 조건이 많</description></item><item><title>책뿌수기 - SQL 레벨업-1</title><link>https://jaejin0me.github.io/post/posts102/</link><pubDate>Sun, 30 Dec 2018 22:20:56 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts102/</guid><description>인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다 1. DBMS 아키텍처 ch 1.DBMS 아키텍처 개요 1) 쿼리 평가 엔진 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지</description></item></channel></rss>