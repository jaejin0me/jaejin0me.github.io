<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Algorithm | Jaejin's blog</title>
<meta name=keywords content><meta name=description content="Jaejin Jang's blog"><meta name=author content><link rel=canonical href=https://jaejin0me.github.io/tags/algorithm/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jaejin0me.github.io/tags/algorithm/index.xml><link rel=alternate hreflang=ko href=https://jaejin0me.github.io/tags/algorithm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T")}</script><meta property="og:title" content="Algorithm"><meta property="og:description" content="Jaejin Jang's blog"><meta property="og:type" content="website"><meta property="og:url" content="https://jaejin0me.github.io/tags/algorithm/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Algorithm"><meta name=twitter:description content="Jaejin Jang's blog"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io/ accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Algorithm</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 1110번 - 더하기 사이클</h2></header><div class=entry-content><p>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include &lt;iostream> #pragma warning(disable:4996) using namespace std; int main(void) { int num, tmp, cnt = 0; cin.tie(NULL); ios_base::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen("input.txt", "r", stdin); freopen("output.txt", "w", stdout); #endif cin >> num; tmp = num; do { tmp = ((tmp % 10) * 10) + (tmp%10 + tmp/10)%10; cnt++; } while (tmp != num); cout &lt;&lt; cnt; #ifndef ONLINE_JUDGE fclose(stdin); fclose(stdout); #endif return 0; }</p></div><footer class=entry-footer><span title='2018-11-26 00:33:42 +0900 +0900'>11월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 1110번 - 더하기 사이클" href=https://jaejin0me.github.io/post/posts66/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 4344번 - 평균은 넘겠지</h2></header><div class=entry-content><p>제목 재밌네
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include &lt;iostream> #include &lt;vector> #include &lt;algorithm> #include &lt;iomanip> #pragma warning(disable:4996) using namespace std; int main(void) { int num, casenum, score, cnt; double sum, avg; vector&lt;int> arr; vector&lt;int>::iterator it; cin.tie(NULL); ios_base::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen("input.txt", "r", stdin); freopen("output.txt", "w", stdout); #endif cin >> num; for (int i = 0; i &lt; num; i++) { cin >> casenum; sum = 0; arr.clear(); avg = 0; cnt = 0; for (int j = 0; j &lt; casenum; j++) { cin >> score; arr.push_back(score); sum += score; } avg = sum / casenum; for (it = arr.begin(); it != arr.end(); it++) { if ((*it) > avg) cnt++; } cout &lt;&lt; fixed &lt;&lt; setprecision(3); cout &lt;&lt; (double)cnt/casenum*100 &lt;&lt; "%\n"; } #ifndef ONLINE_JUDGE fclose(stdin); fclose(stdout); #endif return 0; }</p></div><footer class=entry-footer><span title='2018-11-26 00:30:42 +0900 +0900'>11월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 4344번 - 평균은 넘겠지" href=https://jaejin0me.github.io/post/posts65/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 1546번 - 평균</h2></header><div class=entry-content><p>요즘 다시 시작한 알고리즘 공부.. 쉬운거 부터 풀어 봅시다
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &lt;iostream> #include &lt;vector> #include &lt;algorithm> #include &lt;iomanip> #pragma warning(disable:4996) using namespace std; int main(void) { int num, max, score; double sum = 0; vector&lt;int> arr; vector&lt;int>::iterator it; cin.tie(NULL); ios_base::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen("input.txt", "r", stdin); freopen("output.txt", "w", stdout); #endif cin >> num; for (int i = 0; i &lt; num; i++) { cin >> score; arr.push_back(score); } max = *max_element(arr.begin(), arr.end()); for (it = arr.begin(); it != arr.end(); it++) { sum += (*it) / (double)max * 100; } cout &lt;&lt; fixed &lt;&lt; setprecision(2); cout &lt;&lt; sum / num; #ifndef ONLINE_JUDGE fclose(stdin); fclose(stdout); #endif return 0; }</p></div><footer class=entry-footer><span title='2018-11-26 00:23:42 +0900 +0900'>11월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 1546번 - 평균" href=https://jaejin0me.github.io/post/posts64/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 5651번 - 완전 중요한 간선</h2></header><div class=entry-content><p>중요한 간선을 찾는 코드에서 prev2[next2.to] 가 되어있어야 하는데 prev2[curr2]로 되어 있는 것을 발견하지 못해 푸는데 오래 걸린 문제이다.
중요한 간선의 여부는 최대유량은 찾은 후에 입력 간선들 중에 u->v로 유량을 흘릴수 없는 경우 중요한 간선이라고 판단하였다.
...</p></div><footer class=entry-footer><span title='2018-02-11 12:20:42 +0900 +0900'>2월 11, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 5651번 - 완전 중요한 간선" href=https://jaejin0me.github.io/post/posts63/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 11495번 - 격자 0 만들기</h2></header><div class=entry-content><p>시간초과가 계속해서 나는 것은 최적화 하면서 근근이 풀긴했는데, 속도가 많이 느리다. 자바로 풀 사람들 중에서 꼴등임 ㅎ
다른 정답자들의 풀이를 보니, 나는 에드몬드 카프 알고리즘을 이용해 풀었지만 빠르게 푼 사람들은 “디닉 알고리즘"이라는 것을 이용해서 풀었다.
...</p></div><footer class=entry-footer><span title='2018-02-04 12:20:42 +0900 +0900'>2월 4, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 11495번 - 격자 0 만들기" href=https://jaejin0me.github.io/post/posts62/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 2316번 - 도시 왕복하기</h2></header><div class=entry-content><p>어제 못 풀고 오늘에서야 푼 문제
정점을 1번만 지나는 조건을 만족하기 위해 정점을 분할하고 분할된 정점사이에 용량의 1의 간선을 추가해야 한다.
주의해야 할 것은 입력되는 간선들을 분할될 정점을 고려해 잘 이어주는 것이다.
...</p></div><footer class=entry-footer><span title='2018-01-30 12:20:42 +0900 +0900'>1월 30, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 2316번 - 도시 왕복하기" href=https://jaejin0me.github.io/post/posts61/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 2188번 - 축사배정</h2></header><div class=entry-content><p>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 /** * */ import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.Queue; import java.util.Scanner; import java.util.StringTokenizer; /** * @author jaeji * */ class edge{ int to; int flow; int cap; edge rever; edge(){ this(0,0,0,null); } edge(int ar_to, int ar_flow, int ar_cap, edge ar_rever){ to = ar_to; flow = ar_flow; cap = ar_cap; rever = ar_rever; } int residu() { return cap-flow; } void addflow(int ar_flow) { flow+=ar_flow; rever.flow -=ar_flow; } } public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader( new InputStreamReader( System.in ) ); //BufferedReader br = new BufferedReader( new FileReader("input.txt" ) ); StringTokenizer st = new StringTokenizer(br.readLine()); int n = Integer.parseInt(st.nextToken()); int m = Integer.parseInt(st.nextToken()); int[] prev = new int[402]; ArrayList[] adj = new ArrayList[402]; Queue&lt;Integer> q = new LinkedList&lt;Integer>(); int total = 0; for(int i=0;i&lt;402;i++) { adj[i] = new ArrayList&lt;edge>(); } for(int i=0;i&lt;n;i++) { edge temp_edge = new edge(i,0,1,null); edge temp_rever_edge = new edge(400,0,0,temp_edge); temp_edge.rever = temp_rever_edge; adj[400].add(temp_edge); adj[i].add(temp_rever_edge); } for(int i=200;i&lt;200+m;i++) { edge temp = new edge(401,0,1,null); edge temp_rever_edge = new edge(i,0,0,temp); temp.rever = temp_rever_edge; adj[i].add(temp); adj[401].add(temp_rever_edge); } int no = 0; int temp = 0; for(int i=0;i&lt;n;i++) { st = new StringTokenizer(br.readLine()); no = Integer.parseInt(st.nextToken()); for(int j=0;j&lt;no;j++) { temp = Integer.parseInt(st.nextToken())+199; edge temp_edge = new edge(temp,0,1,null); edge temp_rever_edge = new edge(i,0,0,temp_edge); temp_edge.rever = temp_rever_edge; adj[i].add(temp_edge); adj[temp].add(temp_rever_edge); } } int curr = 0; edge next = null; int S = 400; int E = 401; while(true) { edge[] path = new edge[402]; Arrays.fill(prev, -1); q.clear(); q.add(S); curr = 0; next = null; while(!q.isEmpty()) { // 소스에서 흐를수 있는 유량찾기 curr = q.poll(); for(int i=0;i&lt;adj[curr].size();i++) { next = (edge) adj[curr].get(i); if(next.residu() > 0 && prev[next.to] == -1) { q.add(next.to); prev[next.to] = curr; path[next.to] = next; if(next.to == E) break; } } } if(prev[E] == -1) break; // 경로를 탐색 한 후 싱크로 가는 경로가 없는 경우 for(int i=E;i!=S;i=prev[i]) { path[i].addflow(1); } total += 1; } System.out.println(total); } }</p></div><footer class=entry-footer><span title='2018-01-28 12:20:42 +0900 +0900'>1월 28, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 2188번 - 축사배정" href=https://jaejin0me.github.io/post/posts60/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 1929번 - 소수 구하기</h2></header><div class=entry-content><p>주어진 두 정수 범위내의 소수를 구하는 문제입니다.
에라토스테네스의 체 라는 것을 사용해 구합니다.
개념적으로 주의해야 할 것은 소수 판별하는 것과 다릅니다. 에라토스테네스의 체 는 특점 범위의 소수를 구할때 쓰는 알고리즘입니다.
...</p></div><footer class=entry-footer><span title='2018-01-26 12:20:42 +0800 +0800'>1월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 1929번 - 소수 구하기" href=https://jaejin0me.github.io/post/posts57/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 1978번 - 소수 찾기</h2></header><div class=entry-content><p>주어지는 수들 중에서 소수의 개수를 출력하는 문제입니다.
소수를 판별하는 가장 기초적인 방법인 2~n-1 까지 나눠지는지 확인해서 판별하면 됩니다.
또한 $$\sqrt{n}$$ 까지 나눠지는 약수가 없으면 소수 라는 성질을 이용해 계산량을 줄일 수 있습니다.
...</p></div><footer class=entry-footer><span title='2018-01-26 12:20:42 +0800 +0800'>1월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 1978번 - 소수 찾기" href=https://jaejin0me.github.io/post/posts56/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>백준알고리즘 2609번 - 최대공약수와 최소공배수</h2></header><div class=entry-content><p>두 자연수의 최대 공약수와, 최소 공배수를 출력하는 문제입니다.
유클리드 호제법을 이용해 최대공약수를 구하고 최대공야수를 이용해 최소 공배수를 구하면 됩니다.
최소 공배수만 구하라고 하는 경우에도 최대공약수를 구하여 최소공배수를 구하는 것이 쉽습니다.
...</p></div><footer class=entry-footer><span title='2018-01-26 12:20:42 +0800 +0800'>1월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 백준알고리즘 2609번 - 최대공약수와 최소공배수" href=https://jaejin0me.github.io/post/posts58/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://jaejin0me.github.io/tags/algorithm/page/2/>다음 페이지&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>