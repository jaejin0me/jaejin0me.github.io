<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>디자인 패턴 on Jaejin's blog</title><link>https://jaejin0me.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/</link><description>Recent content in 디자인 패턴 on Jaejin's blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><copyright>Jaejin Jang</copyright><lastBuildDate>Sun, 18 May 2025 14:30:00 +0900</lastBuildDate><atom:link href="https://jaejin0me.github.io/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/index.xml" rel="self" type="application/rss+xml"/><item><title>디자인 패턴의 아름다움 - 1. 개요</title><link>https://jaejin0me.github.io/post/20250518/</link><pubDate>Sun, 18 May 2025 14:30:00 +0900</pubDate><guid>https://jaejin0me.github.io/post/20250518/</guid><description>&lt;h1 id="1-개요">1. 개요&lt;/h1>
&lt;h2 id="11-코드-설계를-배우는-이유">1.1 코드 설계를 배우는 이유&lt;/h2>
&lt;ul>
&lt;li>효율적인 코드 작성 = 데이터 구조 + 알고리즘&lt;/li>
&lt;li>&lt;strong>유지 보수가 용이한 고품질 코드&lt;/strong> = 코드 설계에 대한 지식&lt;/li>
&lt;/ul>
&lt;h3 id="111-고품질의-코드-작성">1.1.1 고품질의 코드 작성&lt;/h3>
&lt;h3 id="112-복잡한-코드-개발-다루기">1.1.2 복잡한 코드 개발 다루기&lt;/h3>
&lt;ul>
&lt;li>소프트웨어 개발 시 만나는 어려움의 유형 2가지&lt;/li>
&lt;li>
&lt;ol>
&lt;li>높은 수준의 기술을 필요로 하는 경우: 자율 주행, 비디오 인식, AI&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;ol start="2">
&lt;li>&lt;strong>높은 수준의 기술을 필요로 하지 않는 대규모 프로젝트: 이 책에서 다룰 내용&lt;/strong>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h3 id="113-프로그래머의-기본-능력">1.1.3 프로그래머의 기본 능력&lt;/h3>
&lt;h3 id="114-경력-개발에-필요한-기술">1.1.4 경력 개발에 필요한 기술&lt;/h3>
&lt;h2 id="12-코드-품질-평가-방법">1.2 코드 품질 평가 방법&lt;/h2>
&lt;h3 id="121-유지-보수성">1.2.1 유지 보수성&lt;/h3>
&lt;ul>
&lt;li>기존의 코드 설계를 손상하거나 새로운 버그를 발생시키지 않고도 빠르게 코드를 수정하거나 추가할 수 있는 상태&lt;/li>
&lt;li>코드가 간결하고 가독성이 높으며 확장성이 높다면 코드의 유지 보수도 쉬움&lt;/li>
&lt;li>코드가 명확하게 계층화되어 있으며, 높은 모듈성, 높은 응집도와 낮은 결합도를 가짐&lt;/li>
&lt;/ul>
&lt;h3 id="122-가독성">1.2.2 가독성&lt;/h3>
&lt;ul>
&lt;li>훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 작성한다.&lt;/li>
&lt;li>제가 중요하게 생각하는 것 중 하나&lt;/li>
&lt;/ul>
&lt;h3 id="123-확장성">1.2.3 확장성&lt;/h3>
&lt;ul>
&lt;li>약간 수정하는 것만으로도 혹은 전혀 수정하지 않고도 확장을 통해 새로운 기능을 추가하는 것&lt;/li>
&lt;li>요구 사항의 미래 변화에 대처할 수 있는 코드의 능력&lt;/li>
&lt;/ul>
&lt;h3 id="124-유연성">1.2.4 유연성&lt;/h3>
&lt;ul>
&lt;li>추상적인 평가 기준이기 때문에 정의하기 쉽지 않음&lt;/li>
&lt;li>
&lt;ol>
&lt;li>확장을 위한 인터페이스가 준비되어 있음&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;ol start="2">
&lt;li>기본적으로 재사용 가능한 많은 모듈과 클래스 등이 기존 코드에 추상화된 형태로 이미 제공&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;ol start="3">
&lt;li>클래스가 다양한 사용 시나리오에 대응하고, 다양한 요구를 충족 가능&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h3 id="125-간결성">1.2.5 간결성&lt;/h3>
&lt;ul>
&lt;li>널리 알려진 KISS(Keep It Simple, Stupid) 원칙&lt;/li>
&lt;li>많은 프로그래머는 단순한 코드에 복잡한 디자인 패턴을 도입하는 것을 좋아한다. 그러나 고수준의 프로그래머는 종종 간단한 방법으로 복잡한 문제를 해결한다.&lt;/li>
&lt;li>저의 코딩 스타일 중 하나&lt;/li>
&lt;/ul>
&lt;h3 id="126-재사용성">1.2.6 재사용성&lt;/h3>
&lt;ul>
&lt;li>반복적인 코드 작성을 최소화하고 기존 코드를 재사용하는 것&lt;/li>
&lt;li>단일 책임 원칙(single Responsibility principle)&lt;/li>
&lt;li>DRY(Don&amp;rsquo;t repeat yourself) 원칙&lt;/li>
&lt;/ul>
&lt;h3 id="127-테스트-용이성">1.2.7 테스트 용이성&lt;/h3>
&lt;ul>
&lt;li>이 책에서 처음 보는 기준인데, 중요할 것 같네요.&lt;/li>
&lt;/ul>
&lt;h2 id="13-고품질-코드를-작성하는-방법">1.3 고품질 코드를 작성하는 방법&lt;/h2>
&lt;h3 id="131-객체지향">1.3.1 객체지향&lt;/h3>
&lt;ul>
&lt;li>세 가지의 프로그래밍 패러다임(절차적, 함수형, 객체지향) 중에서 객체지향 프로그래밍이 가장 대중적임&lt;/li>
&lt;li>이 책에서는 객체지향에 대해 마스터하는 것을 목표로 함&lt;/li>
&lt;/ul>
&lt;h3 id="132-설계-원칙">1.3.2 설계 원칙&lt;/h3>
&lt;ul>
&lt;li>각각의 설계 원칙이 어떤 문제와 응용 시나리오를 해결하는데 사용되는 것인지 파악해야 한다&lt;/li>
&lt;li>모두 마스터해야만 설계 원칙을 프로젝트에 유연하고 적절하게 적용할 수 있다&lt;/li>
&lt;li>설계 원칙은 디자인 패턴보다 더 보편적이고 중요한 것이다.&lt;/li>
&lt;/ul>
&lt;h3 id="133-디자인-패턴">1.3.3 디자인 패턴&lt;/h3>
&lt;ul>
&lt;li>자주 접하게 되는 일부 설계 문제에 대해 요약된 솔루션 또는 설계 사상&lt;/li>
&lt;/ul>
&lt;h3 id="134-코딩-규칙">1.3.4 코딩 규칙&lt;/h3>
&lt;ul>
&lt;li>주로 가독성 문제 해결&lt;/li>
&lt;/ul>
&lt;h3 id="135-리팩터링-기법">1.3.5 리팩터링 기법&lt;/h3>
&lt;h2 id="14-과도한-설계를-피하는-방법">1.4 과도한 설계를 피하는 방법&lt;/h2>
&lt;h3 id="141-코드-설계의-원래-의도는-코드-품질을-향상시키는-것이다">1.4.1 코드 설계의 원래 의도는 코드 품질을 향상시키는 것이다&lt;/h3>
&lt;h3 id="142-코드-설계의-원칙은-앞에-문제가-있고-뒤에-방안이-있다는-것이다">1.4.2 코드 설계의 원칙은 앞에 문제가 있고, 뒤에 방안이 있다는 것이다&lt;/h3>
&lt;h3 id="143-코드-설계의-응용-시나리오는-복잡한-코드에-적용되어야-한다">1.4.3 코드 설계의 응용 시나리오는 복잡한 코드에 적용되어야 한다&lt;/h3>
&lt;ul>
&lt;li>디자인 패턴을 적용하는 목적은 디커플링, 즉 더 나은 코드 구조를 사용하여 단일 책임을 위해 큰 조각을 작은 클래스로 분할하여 코드가 높은 응집도와 낮은 결합도의 특성을 충족하도록 하는 것이다.&lt;/li>
&lt;/ul>
&lt;h3 id="144-지속적인-리팩토링은-과도한-설계를-효과적으로-방지할-수-있다">1.4.4 지속적인 리팩토링은 과도한 설계를 효과적으로 방지할 수 있다&lt;/h3>
&lt;ul>
&lt;li>실현 가능성이 낮은 미래의 요구 사항을 위해 처음부터 디자인 패턴을 적용하기보다, 진짜 문제가 발생했을 때 이를 해결하기 위한 디자인 패턴을 사용하는 것을 고려하는 것이다.&lt;/li>
&lt;/ul>
&lt;h3 id="145-특정-시나리오-외의-코드-설계에-대해-이야기하지-않는다">1.4.5 특정 시나리오 외의 코드 설계에 대해 이야기하지 않는다&lt;/h3></description></item><item><title>디자인 패턴 - 싱글턴 패턴</title><link>https://jaejin0me.github.io/post/posts111/</link><pubDate>Mon, 01 Jan 2018 11:31:42 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts111/</guid><description>&lt;h2 id="싱글턴-패턴">싱글턴 패턴&lt;/h2>
&lt;p>인스턴스가 하나 만들어지고 어디서든지 인스턴스에 접근하기 위한 패턴&lt;/p>
&lt;p>간단히 인스턴스에 접근하기 위한 get메소드, 기본적인 생성자, 인스턴스 멤버변수로 구성된다고 가정해보자.&lt;/p></description></item></channel></rss>