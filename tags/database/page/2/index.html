<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Database | Jaejin's blog</title>
<meta name=keywords content><meta name=description content="Jaejin Jang's blog"><meta name=author content><link rel=canonical href=https://jaejin0me.github.io/tags/database/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://jaejin0me.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaejin0me.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaejin0me.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jaejin0me.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jaejin0me.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jaejin0me.github.io/tags/database/index.xml><link rel=alternate hreflang=ko href=https://jaejin0me.github.io/tags/database/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F8504X956T"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F8504X956T")}</script><meta property="og:title" content="Database"><meta property="og:description" content="Jaejin Jang's blog"><meta property="og:type" content="website"><meta property="og:url" content="https://jaejin0me.github.io/tags/database/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Database"><meta name=twitter:description content="Jaejin Jang's blog"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaejin0me.github.io/ accesskey=h title="Jaejin's blog (Alt + H)">Jaejin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaejin0me.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jaejin0me.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaejin0me.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://jaejin0me.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jaejin0me.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jaejin0me.github.io/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Database</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>책뿌수기 - 기초가 든든한 데이터 베이스 1</h2></header><div class=entry-content><p>인용하는 그림은 다양한 곳에서 가져왔음을 밝힙니다
Ch 1. DB 시스템 Section 1. DB 1.1 데이터와 데이터 베이스 개념
DB = 필요한 데이터를 모아 놓은 것 1.2 데이터와 정보
데이터 : 관찰하거나 측정하여 기술하는 가공되지 않은 사실이나 값 정보 : 의미 있고 쓸모 있는 내용으로 가공한 데이터 1.3 DB의 정의와 특징
...</p></div><footer class=entry-footer><span title='2018-11-26 00:07:56 +0900 +0900'>11월 26, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 책뿌수기 - 기초가 든든한 데이터 베이스 1" href=https://jaejin0me.github.io/post/posts91/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>오라클 DB 문제 풀이(2)</h2></header><div class=entry-content><p>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 -- 부서번호가 60인 직원의 사원번호,이름,월급을 출력하라 SELECT EMPLOYEE_ID, FIRST_NAME, SALARY FROM HR_EMPLOYEES WHERE DEPARTMENT_ID=60 -- 사원번호가 127인 사람의 이름, 입사일, 부서번호를 출력하라 SELECT FIRST_NAME, HIRE_DATE, DEPARTMENT_ID FROM HR_EMPLOYEES WHERE EMPLOYEE_ID=127 -- 이름의 JOHN인 사람의 모든 정보를 출력하라 SELECT * FROM HR_EMPLOYEES WHERE FIRST_NAME='JOHN' -- 입사일이 97년 1월 5일인 사원의 이름, 부서번호, 월급을 출력하라 SELECT FIRST_NAME, DEPARTMENT_ID, SALARY FROM HR_EMPLOYEES WHERE HIRE_DATE='1997-01-05' -- 직원이 매니저가 아닌 사람의 모든 정보를 출력하라 SELECT EMP1.* FROM HR_EMPLOYEES EMP1 INNER JOIN HR_JOBS JOB1 ON EMP1.JOB_ID = JOB1.JOB_ID WHERE JOB1.JOB_TITLE LIKE '%MANAGER%' -- 입사일이 97년 1월 2일 이후인 사원의 정보를 출력하라 SELECT * FROM HR_EMPLOYEES WHERE HIRE_DATE>'1997-01-02' -- 급여가 6000 이상인 사람의 이름, 급여, 부서번호를 출력하라 SELECT FIRST_NAME,SALARY,DEPARTMENT_ID FROM HR_EMPLOYEES WHERE SALARY>6000 -- 부서번호가 80 이상인 사원의 모든 정보를 출력하라 SELECT * FROM HR_EMPLOYEES WHERE DEPARTMENT_ID>=80 -- 이름이 k로 시작하는 사람보다 높은 이름을 가진 사원의 정보를 출력하라 SELECT * FROM HR_EMPLOYEES WHERE FIRST_NAME>'K%' -- 입사일이 97/12/10 보다 먼저 입사한 사람들의 모든 정보를 출력하라 SELECT * FROM HR_EMPLOYEES WHERE HIRE_DATE>'1997-12-10' -- 직원번호가 127보다 작거나 같은 직원의 입사번호와 이름을 출력하라 SELECT EMPLOYEE_ID, FIRST_NAME FROM HR_EMPLOYEES WHERE EMPLOYEE_ID&lt;=127 -- 입사일이 97/01/01보다 늦고 00/12/07보다 빠른 사원의 이름,월급,부서번호를 출력하라 SELECT FIRST_NAME,SALARY,DEPARTMENT_ID FROM HR_EMPLOYEES WHERE HIRE_DATE BETWEEN '1997-01-01' AND '2000-12-07' -- 급여가 5000보다 크고 8000보다 작은 사람의 이름,직업,급여를 출력하라 SELECT FIRST_NAME, JOB_ID, SALARY FROM HR_EMPLOYEES WHERE SALARY BETWEEN 5000 AND 8000 -- 사원번호가 120~130 이외의 사원의 모든 정보를 출력하라 SELECT * FROM HR_EMPLOYEES WHERE NOT EMPLOYEE_ID BETWEEN 120 AND 130 -- 이름의 B와 J 사이인 직원의 정보를 출력하라 SELECT * FROM HR_EMPLOYEES WHERE FIRST_NAME BETWEEN 'B' AND 'J' -- 입사일 97년 이외에 입사한 사람의 정보를 출력하라 SELECT * FROM HR_EMPLOYEES WHERE YEAR(HIRE_DATE) != 1997 -- 직업이 MANAGER 와 SALEMAN인 사람인 모든 정보를 출력하라 SELECT * FROM HR_EMPLOYEES EMP1 INNER JOIN HR_JOBS JOB1 ON EMP1.JOB_ID = JOB1.JOB_ID WHERE JOB1.JOB_TITLE LIKE '%MANAGER%' OR JOB1.JOB_TITLE LIKE '%SALEMAN%' -- 부서번호 60,90을 제외한 사원의 이름, 부서번호, 사원번호를 출력하라 SELECT FIRST_NAME,DEPARTMENT_ID,EMPLOYEE_ID FROM HR_EMPLOYEES WHERE NOT DEPARTMENT_ID IN (60,90) -- S로 시작하는 사원의 사원번호, 이름, 입사일, 부서번호를 출력하라 SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, DEPARTMENT_ID FROM HR_EMPLOYEES WHERE FIRST_NAME LIKE 'S%' -- 입사일이 2000년도인 직원의 정보를 출력하라 SELECT * FROM HR_EMPLOYEES WHERE YEAR(HIRE_DATE) = 2000 -- 이름이 J로 시작하고 마지막 글자가 N인 사원의 정보를 출력하라 -- 조건1. 이름은 4자리 이다 SELECT * FROM HR_EMPLOYEES WHERE FIRST_NAME LIKE 'J__N' -- 첫번째 문자를 관계없고, 두번째 문자가 A인 직원의 정보를 출력하라 SELECT * FROM HR_EMPLOYEES WHERE FIRST_NAME LIKE '_A%' -- 커미션이 NULL인 사원의 정보를 출력하라 SELECT * FROM HR_EMPLOYEES WHERE COMMISSION_PCT IS NULL -- 커미션이 NULL이 아닌 사원의 정보를 출력하라 SELECT * FROM HR_EMPLOYEES WHERE COMMISSION_PCT IS NOT NULL -- 부서번호가 100이고 급여가 5000 이상인 직원의 이름,부서,월급을 출력하라 SELECT FIRST_NAME, DEPARTMENT_ID, SALARY FROM HR_EMPLOYEES WHERE DEPARTMENT_ID = 100 AND SALARY >= 5000 -- 첫글자가 K로 시작하거나 부서번호가 30인 사원의 사원번호, 이름, 부서번호를 출력하라 SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID FROM HR_EMPLOYEES WHERE FIRST_NAME LIKE 'K%' -- 급여가 5000이상이고 부서가 100인 사원중 직원이 MANAGER인 사원의 정보를 출력하라 SELECT * FROM HR_EMPLOYEES EMP1 INNER JOIN HR_JOBS JOB2 ON EMP1.JOB_ID = JOB2.JOB_ID WHERE SALARY >5000 AND DEPARTMENT_ID = 100 AND JOB2.JOB_TITLE LIKE '%MANAGER%' -- 부서번호가 100인 사원을 사원번호순으로 정렬 SELECT * FROM HR_EMPLOYEES WHERE DEPARTMENT_ID = 100 ORDER BY EMPLOYEE_ID ASC -- 급여 순서가 많은 순으로 정렬 SELECT * FROM HR_EMPLOYEES ORDER BY SALARY DESC -- 부서번호로 오름차순정렬후 급여 내림차순정렬 SELECT * FROM HR_EMPLOYEES ORDER BY DEPARTMENT_ID ASC , SALARY DESC -- 부서번호 내림차순, 이름 오름차순, 급여 내림차순 출력 SELECT * FROM HR_EMPLOYEES ORDER BY DEPARTMENT_ID DESC, FIRST_NAME ASC, SALARY DESC -- 사원의 이름, 급여, 커미션 금액, 총액을 구하여 총액 내림차순 출력 -- 커미션이 NULL인 사람은 제외 SELECT FIRST_NAME, SALARY, COMMISSION_PCT*SALARY, SALARY+COMMISSION_PCT*SALARY FROM HR_EMPLOYEES WHERE COMMISSION_PCT IS NOT NULL -- 50번 부서의 모든 직원들에게 13%트의 보너스를 지부라기로 했다. 이름, 급여, 보너스, 금액, 부서번호를 출력하라 SELECT FIRST_NAME, SALARY, SALARY*0.13, SALARY*1.13, DEPARTMENT_ID FROM HR_EMPLOYEES WHERE DEPARTMENT_ID = 50 -- 60번 부서의 연봉을 계산하여 이름, 부서번호, 급여, 연봉을 출력하라 -- 연말에 150%의 보너르를 지급한다 SELECT FIRST_NAME, DEPARTMENT_ID, SALARY, 13.5*SALARY FROM HR_EMPLOYEES WHERE DEPARTMENT_ID = 60</p></div><footer class=entry-footer><span title='2018-02-11 01:37:56 +0900 +0900'>2월 11, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 오라클 DB 문제 풀이(2)" href=https://jaejin0me.github.io/post/posts90/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>오라클 DB 문제 풀이</h2></header><div class=entry-content><p>오라클 DB의 문제이만 Mysql 계열의 MariaDB로 풀었습니다. 제가 구한 샘플데이터에 맞게 문제의 수치도 조금 바꿨습니다.
풀면서 느낀 SQL의 가장 큰 차이는 MAX(count(*))가 안된다는 것..
...</p></div><footer class=entry-footer><span title='2018-02-07 01:37:56 +0900 +0900'>2월 7, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 오라클 DB 문제 풀이" href=https://jaejin0me.github.io/post/posts89/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Join</h2></header><div class=entry-content><p>1. Join Join을 통해서 2개 이상의 테이블을 연결할 수 있다. Join은 기본적으로 기본키나 외부키의 값의 연관에 의해 성립되지만, 논리적인 값들의 연관만으로도 성립할 수 있다. Join의 조건은 where절에 기술한다. Join의 종류는 다음과 같다. Join 방법 의미 equi join 두 개의 테이블 간의 칼럼값들이 정확하게 일치하는 경우에 사용 non- equi join 두 개의 테이블 간의 칼럼값들이 정확하게 일치하지 않는 경우에 사용 outer join Join의 조건을 만족하지 않는 데이터들도 보고자 하는 경우 self join 두 개의 테이블이 아니라 같은 테이블 행들을 Join하는 경우 2. Cross Join(Cartesian Product) 테이블들 간의 Join 조건을 생략하거나 조건을 잘못 설정했을 경우, 첫 번째 테이블의 모든 행들에 대해서 두번째 테이블의 모든 행들이 Join되어 조회되는 데이터의 형태를 말함. 카티션 곱이 발생하면 조회되는 데이터의 수가 기하급수적으로 증가하기 때문에 DB나 네트워크에 부담이 된다. 2.1 예 1 SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, E.FIRST_NAME, E.LAST_NAME FROM HR_DEPARTMENTS D, HR_EMPLOYEES E 3. Equi join(Inner Join,등가 조인) : ‘=’ 연사자 이용 두 테이블의 일치하는 칼럽을 연결해서 Join하는 것을 등가조인이라고 함. 두 테이블간의 칼럼 값들이 일치하는 경우에 사용하며, 테이블별로 alias를 사용해 구분해주는 것이 좋다. Join을 하는 테이블이 N개인 경우, 최소 N-1개의 Join조건이 where절에 와야 한다. 3.1 예제 1 2 //사원테이블로 부서 테이블에서 부서아이디가 일치하는 경우, 부서아이디, 부서이름, 직원 이름 조회하기 SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, E.FIRST_NAME, E.LAST_NAME FROM HR_DEPARTMENTS D, HR_EMPLOYEES E WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID 4. Non-Equi Join(비등가조인) 두 개의 테이블간의 칼럼값들이 정확하게 일치하는 않는 경우에 사용(범위를 이용해 등급을 나눌때 용이). = 이 아닌 다른 연산자 들을 사용한다. 5. Outer Join(Left/Right Join) 조건을 만족하지 않는 데이터들도 보고싶을 때 사용한다 equi join을 사용하면 칼럼값이 일치하는 데이터만 볼 수 있지만, outer join을 사용하면 다른 데이터 들도 볼 수 있음 (+) 연산자를 쓰거나, 보고자하는 테이블이 왼쪽이면 Left, 오른쪽이며 Right를 명시에 사용한다. 5.1 예제 1 2 //직원 테이블과 부서테이블에서 부서아이디가 일치하는 경우 부서아이디 별로 묶어서 개수를 보여주고 부서아이디로 오름차순 정렬, 일치하는 부서가 없는 경우도 보여주기 SELECT D.DEPARTMENT_ID, COUNT(*) FROM HR_EMPLOYEES E RIGHT JOIN HR_DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID GROUP BY E.DEPARTMENT_ID ORDER BY DEPARTMENT_ID ASC 6. Self Join 하나의 테이블에서 두 개의 테이블을 Join하는 것처럼 사용하는 Join alias명을 지정해서 구별해 준다 6.1 예제 1 2 //각 사원의 매니저가 실제로 직업이 매니저인 경우 사원아이디, 이름, 매니저아이디, 매니저의 사원아이디, 매니저 이름, 매니저 직업아이디를 출력하라 SELECT E1.EMPLOYEE_ID, E1.FIRST_NAME, E1.MANAGER_ID, E2.EMPLOYEE_ID, E2.FIRST_NAME, E2.JOB_ID FROM HR_EMPLOYEES E1, HR_EMPLOYEES E2 WHERE E1.MANAGER_ID = E2.EMPLOYEE_ID AND E2.JOB_ID LIKE '%MAN'</p></div><footer class=entry-footer><span title='2018-02-05 01:37:56 +0900 +0900'>2월 5, 2018</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to Join" href=https://jaejin0me.github.io/post/posts88/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>HeidiSQL 정리</h2></header><div class=entry-content><p>참고사이트
1.SELECT - 선택해서 보기 위함 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //중복제거 SELECT DISTINCT //조건 추가 WHERE 컬럼조건 //특정 패턴의 컬럼 LIKE //이산적 값 만족 IN //별칭(출력되는 컬럼명으로는 알아 보기 힘들 때 사용) SELECT 컬럼 AS 별칭 //출력행 개수 조절, 리눅스 head와 비슷 LIMIT 숫자 //두개 이상의 SELECT문 연결, 기본적으로 DISTINCT 출력임 SELECT 컬럼 FROM 테이블 UNION SELECT 컬럼 FROM 테이블 -- 조건을 추가할 경우 처음오는 SELECT의 컬럼명을 사용해야 한다 SELECT 컬럼1 FROM 테이블 UNION SELECT 컬럼2 FROM 테이블 WHERE 컬럼1 //중복있는 UNION 셀렉문 UNION ALL 셀렉문 //컬럼 정렬 셀렉문 WHERE 컬럼 ORDER BY ASC|DESC 2.INSERT - 행을 추가하기 위함 1 2 3 INSERT INTO 테이블 VALUES(값, 값, 값) //특정 컬럼에만 값 넣기 INSERT INTO (컬럼2) 테이블 VALUES(값) 3.DELECT - 행삭제, 조건절 중요 1 2 DELECT FROM 테이블 WHERE 식 DELECT FROM 테이블 // 모든 행이 다 지워져버림 4.UPDATE - 테이블 내 레코드 값 변경, 조건절 중요 1 2 UPDATE 테이블 SET 컬럼1=값, 컬럼2=값, 컬럼3=값 WHERE 식 UPDATE 테이블 SET 컬럼1=값, 컬럼2=값, 컬럼3=값 // 모든 레코그값이 다 변경 됨 5.CREATE - DB나 테이블 생성 1 2 3 4 5 6 7 CREATE DATABASE DB명 CREATE TABLE 테이블명 ( 컬럼1 자료형. 컬럼2 자료형, 컬럼3 자료형 ) 6.DROP - DB나 테이블 삭제, drop the bit, 비트주세요 1 2 DROP DATABASE DB명 DROP TABLE 테이블명 7.TRUNCATE - 테이블 유지하면서 레코드만 삭제 1 TRUNCATE TABLE 테이블명 8.ALTER - 컬럼 추가, 삭제, 수정 9.JOIN - 두개 이상의 테이블로부터 질의하기 위해 1 2 3 4 5 6 INNER JOIN - 두 테이블에서 값이 일치하는 행들 반환 SELECT 컬럼 FROM 테이블1 INNER JOIN 테이블2 ON 테이블1.컬럼 = 테이블2.컬럼 LEFT JOIN - 일치여부에 상관없이 왼쪽 테이블의 값들은 반환됨 SELECT 컬럼 FROM 테이블1 LEFT JOIN 테이블2 ON 테이블1.컬럼 = 테이블2.컬럼 RIGHT JOIN - 일치여부에 상관없이 오른쪽 테이블의 값들은 반환됨 SELECT 컬럼 FROM 테이블1 RIGHT JOIN 테이블2 ON 테이블1.컬럼 = 테이블2.컬럼 10.CONSTRAINTS - 테이블에 삽입될 자료형 제한 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 - NOT NULL CREATE TABLE 테이블명 ( 컬럼1 자료형 NOT NULL, 컬럼2 자료형, 컬럼3 자료형 ) - UNIQUE CREATE TABLE 테이블명 ( 컬럼1 자료형 UNIQUE, 컬럼2 자료형, 컬럼3 자료형 #UNIQUE(컬럼1) ) - PRIMARY KEY CREATE TABLE 테이블명 ( 컬럼1 자료형 PRIMARY KEY, 컬럼2 자료형, 컬럼3 자료형 #PRIMARY KEY(컬럼1) ) - FOREIGN KEY CREATE TABLE 테이블명 ( 컬럼1 자료형 FOREIGN KEY, 컬럼2 자료형, 컬럼3 자료형 #FOREIGN KEY(컬럼1) ) - CHECK CREATE TABLE 테이블명 ( 컬럼1 자료형 CEHCK(식), 컬럼2 자료형, 컬럼3 자료형 #CEHCK(식) ) - DEFAULT CREATE TABLE 테이블명 ( 컬럼1 자료형 DEFAULT 값, 컬럼2 자료형, 컬럼3 자료형 #UNIQUE(컬럼1) ) 11.주석 1 2 3 # 한줄 주석 -- 한줄 주석 /* 범위 주석 */ 12.AUTO_INCREMENT - 테이블 생성시 ID 자동증가용으로 쓰임 1 2 3 4 5 6 7 create table student2( id int not null auto_increment, name varchar(255), grade int, house varchar(255), primary key(id) ); 13.NULL 0과 NULL은 다름 1 2 3 #조회 WHERE 컬럼 IS NULL WHERE 컬럼 IS NOT NULL 14.VIEW - 가상 테이블 만들기 원하는 값들을 골라 가상 테이블을 만들 수 있다. 일반 테이블처럼 사용가능 1 2 3 #생성 CREATE VIEW 뷰명 AS SELECT 컬럼 FROM 테이블 WHERE 조건 #삭제 DROP VIEW 뷰명 15.INDEX - 데이터를 빠르게 찾기 위함 16.GROUP BY - 그룹별로 나뉘어 통계를 보기 위해 1 SELECT JOB_ID,AVG(SALARY),MIN(SALARY),MAX(SALARY),COUNT(SALARY) FROM HR_EMPLOYEES GROUP BY JOB_ID 17.HAVING - 그룹에 조건을 걸기위해(SELECT의 WHERE와 같다) 1 SELECT JOB_ID,AVG(SALARY),MIN(SALARY),MAX(SALARY),COUNT(SALARY) FROM HR_EMPLOYEES GROUP BY JOB_ID HAVING JOB_ID='AC_ACCOUNT'</p></div><footer class=entry-footer><span title='2017-12-23 01:37:56 +0800 +0800'>12월 23, 2017</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to HeidiSQL 정리" href=https://jaejin0me.github.io/post/posts85/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>SELECT</h2></header><div class=entry-content><p>1.부서번호가 30인 직원의 모든 정보 출력 1 SELECT * FROM HR_EMPLOYEES WHERE DEPARTMENT_ID=30 2.성이 KING인 직원의 모든 정보 출력 1 SELECT * FROM HR_EMPLOYEES WHERE LAST_NAME='KING' 3.입사일이 00년 2월 7일 이후 입사한 직원들 정보를 출력하라. 1 SELECT * FROM HR_EMPLOYEES WHERE HIRE_DATE>='2000-02-07' 4.이름이 J로 시작하는 직원들 정보 출력 1 SELECT * FROM HR_EMPLOYEES WHERE LAST_NAME LIKE 'J%' 5.이름이 J보다 큰(알파벳상 뒤에 위치) 직원들 정보 출력 1 SELECT * FROM HR_EMPLOYEES WHERE LAST_NAME>'J' 6.이름이 B와 Q사이로 시작하는 직원들의 정보를 출력하라. 1 2 -- SELECT * FROM HR_EMPLOYEES WHERE LAST_NAME>'B' AND LAST_NAME&lt;'Q' SELECT * FROM HR_EMPLOYEES WHERE LAST_NAME BETWEEN 'B' AND 'Q' 7.이름의 2번째 문자가 B인 직원 출력 1 SELECT * FROM HR_EMPLOYEES WHERE LAST_NAME LIKE '_B%' 8.커미션이 널이 아닌 직원의 이름,성,커티션 출력 1 SELECT LAST_NAME, FIRST_NAME, COMMISSION_PCT FROM HR_EMPLOYEES WHERE COMMISSION_PCT IS NOT NULL 9.부서번호가 90번이고 월급이 5000이상인 직원들의 이름, 부서번호, 월급 출력 1 SELECT LAST_NAME, FIRST_NAME, DEPARTMENT_ID,SALARY FROM HR_EMPLOYEES WHERE SALARY>=5000 AND DEPARTMENT_ID=90 10.부서번호가 80번이고 월급이 6000이상인 직원들의 이름, 부서번호, 월급을 이름 내림차순으로 1 SELECT LAST_NAME, FIRST_NAME, DEPARTMENT_ID,SALARY FROM HR_EMPLOYEES WHERE SALARY>=6000 AND DEPARTMENT_ID=80 ORDER BY LAST_NAME DESC 11. 입사 년도가 99년 1월이 아닌 직원 출력 1 SELECT * FROM HR_EMPLOYEES WHERE HIRE_DATE NOT LIKE '1999-01%' 12.이름이 J로 시작하고 N로 끝나는 직원 출력 1 SELECT * FROM HR_EMPLOYEES WHERE FIRST_NAME LIKE 'J%N' 13.이름이 5글자 이면서 J로 시작하고 N로 끝나는 직원 출력 1 SELECT * FROM HR_EMPLOYEES WHERE FIRST_NAME LIKE 'J___N' 14. emp에서 이름, 급여, 커미션 금액, 총액(급여+커미션금액)을 구하여 총액이 많은 순서대로 출력하라. 1 select first_name, salary, salary*commission_pct, (salary + salary*commission_pct) total from hr_employees where commission_pct is not null 15. 80번 부서의 모든사람들에게 급여의 13%를 보너스로 지불하기로 했다. 이름, 급여, 보너스 금액, 부서번호를 출력하라 1 select first_name, salary, salary*0.13, department_id from hr_employees where department_id=80 16. 80번 부서의 연봉을 계산하여 이름, 부서번호, 급여, 연봉을 출력하라. 단 연말에 급여의 150%를 보너스를 지급한다. 1 select first_name, department_id, salary, salary*12+salary*1.5 total from hr_employees where department_id=80 17. 부서번호가 80인 부서의 시간당 임금을 계산하여 이름, 급여, 시간당 임금(소수점이하 1자리에서 반올림)을 출력하라. 1달의 근무일수는 12일이고, 1일당 근무시간은 5시간이다. 1 select first_name, salary, round(salary/(12*5),1) sph from hr_employees where department_id=80 18.급여가 1500부터 3000 사이의 사람은 급여의 15%를 회비로 지불하기로 했다. 이름, 급여, 회비(2째자리반올림) 출력하라. 1 select first_name, salary, round(salary*0.15) h from hr_employees where salary between 1500 and 3000 19.급여가 2000 이상인 모든 사람은 급여가 15%를 경조비로 내기로 했다. 이름, 급여 ,경조비를 출력하라 1 select first_name, salary, round(salary*0.15) g from hr_employees where salary>=2000 20.입사일부터 지금까지의 날짜수를 구하라. 부서번호, 이름, 입사일, 현재일, 근무일수, 근무년수, 근무월수(30일 기준), 근무주수를 구하라.</p></div><footer class=entry-footer><span title='2017-12-23 01:37:56 +0800 +0800'>12월 23, 2017</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to SELECT" href=https://jaejin0me.github.io/post/posts86/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 정리</h2></header><div class=entry-content><p>가장 배경지식이 부족한 데이터베이스.. 그래도 비중이 적고 문제가 쉽다고 하니 다행이다. 새로 알게 된 것이나 모르는 내용 위주로 정리를 한다.
인용부호 ' ' 에서만 대소문자를 구분한다. 문자열의 패턴을 검색할때는 like를 쓴다. string like pattern 과 같다. 패턴에서 % 는 임의의 문자열을 뜻하고(문자열이 없을 수 있음), _ 는 임의의 한 문자를 뜻한다.
...</p></div><footer class=entry-footer><span title='2017-12-23 01:37:56 +0800 +0800'>12월 23, 2017</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 데이터베이스 정리" href=https://jaejin0me.github.io/post/posts83/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>마리아 DB 사용법 모아놓은 블로그</h2></header><div class=entry-content><p>http://blog.naver.com/PostView.nhn?blogId=hmkuak&amp;logNo=220583392375
마리아 DB 사용법을 모아놓은 블로그를 블로그한 블로그의 사이트..</p></div><footer class=entry-footer><span title='2017-12-23 01:37:56 +0800 +0800'>12월 23, 2017</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 마리아 DB 사용법 모아놓은 블로그" href=https://jaejin0me.github.io/post/posts84/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>조인과 서브쿼리</h2></header><div class=entry-content><p>EMPLOYESS와 DEPT 을 JOIN하여 부서 번호, 부서명, 이름, 급여를 출력하라. SELECT HR_EMPLOYEES.DEPARTMENT_ID, DEPARTMENT_NAME, LAST_NAME, SALARY FROM HR_EMPLOYEES INNER JOIN HR_DEPARTMENTS ON HR_EMPLOYEES.DEPARTMENT_ID = HR_DEPARTMENTS.DEPARTMENT_ID
이름이 ‘HALL’인 사원의 부서명을 출력하라. SELECT DEPARTMENT_NAME FROM HR_EMPLOYEES E, HR_DEPARTMENTS D WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND E.LAST_NAME=‘HALL’
...</p></div><footer class=entry-footer><span title='2017-12-23 01:37:56 +0800 +0800'>12월 23, 2017</span>&nbsp;·&nbsp;Jaejin Jang</footer><a class=entry-link aria-label="post link to 조인과 서브쿼리" href=https://jaejin0me.github.io/post/posts87/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://jaejin0me.github.io/tags/database/>«&nbsp;이전 페이지&nbsp;</a></nav></footer></main><footer class=footer><span>Jaejin Jang</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>