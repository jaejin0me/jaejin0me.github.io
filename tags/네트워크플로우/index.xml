<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>네트워크플로우 on Jaejin's blog</title><link>https://jaejin0me.github.io/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C%EC%9A%B0/</link><description>Recent content in 네트워크플로우 on Jaejin's blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><copyright>Jaejin Jang</copyright><lastBuildDate>Sun, 11 Feb 2018 12:20:42 +0900</lastBuildDate><atom:link href="https://jaejin0me.github.io/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C%EC%9A%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>백준알고리즘 5651번 - 완전 중요한 간선</title><link>https://jaejin0me.github.io/post/posts63/</link><pubDate>Sun, 11 Feb 2018 12:20:42 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts63/</guid><description>&lt;p>중요한 간선을 찾는 코드에서 prev2[next2.to] 가 되어있어야 하는데 prev2[curr2]로 되어 있는 것을 발견하지 못해 푸는데 오래 걸린 문제이다.&lt;/p>
&lt;p>중요한 간선의 여부는 최대유량은 찾은 후에 입력 간선들 중에 u-&amp;gt;v로 유량을 흘릴수 없는 경우 중요한 간선이라고 판단하였다.&lt;/p></description></item><item><title>백준알고리즘 11495번 - 격자 0 만들기</title><link>https://jaejin0me.github.io/post/posts62/</link><pubDate>Sun, 04 Feb 2018 12:20:42 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts62/</guid><description>&lt;p>시간초과가 계속해서 나는 것은 최적화 하면서 근근이 풀긴했는데, 속도가 많이 느리다. 자바로 풀 사람들 중에서 꼴등임 ㅎ&lt;/p>
&lt;p>다른 정답자들의 풀이를 보니, 나는 에드몬드 카프 알고리즘을 이용해 풀었지만 빠르게 푼 사람들은 &amp;ldquo;디닉 알고리즘&amp;quot;이라는 것을 이용해서 풀었다.&lt;/p></description></item><item><title>백준알고리즘 2316번 - 도시 왕복하기</title><link>https://jaejin0me.github.io/post/posts61/</link><pubDate>Tue, 30 Jan 2018 12:20:42 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts61/</guid><description>&lt;p>어제 못 풀고 오늘에서야 푼 문제&lt;/p>
&lt;p>정점을 1번만 지나는 조건을 만족하기 위해 정점을 분할하고 분할된 정점사이에 용량의 1의 간선을 추가해야 한다.&lt;/p>
&lt;p>주의해야 할 것은 입력되는 간선들을 분할될 정점을 고려해 잘 이어주는 것이다.&lt;/p></description></item><item><title>백준알고리즘 2188번 - 축사배정</title><link>https://jaejin0me.github.io/post/posts60/</link><pubDate>Sun, 28 Jan 2018 12:20:42 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts60/</guid><description>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt"> 10
&lt;/span>&lt;span class="lnt"> 11
&lt;/span>&lt;span class="lnt"> 12
&lt;/span>&lt;span class="lnt"> 13
&lt;/span>&lt;span class="lnt"> 14
&lt;/span>&lt;span class="lnt"> 15
&lt;/span>&lt;span class="lnt"> 16
&lt;/span>&lt;span class="lnt"> 17
&lt;/span>&lt;span class="lnt"> 18
&lt;/span>&lt;span class="lnt"> 19
&lt;/span>&lt;span class="lnt"> 20
&lt;/span>&lt;span class="lnt"> 21
&lt;/span>&lt;span class="lnt"> 22
&lt;/span>&lt;span class="lnt"> 23
&lt;/span>&lt;span class="lnt"> 24
&lt;/span>&lt;span class="lnt"> 25
&lt;/span>&lt;span class="lnt"> 26
&lt;/span>&lt;span class="lnt"> 27
&lt;/span>&lt;span class="lnt"> 28
&lt;/span>&lt;span class="lnt"> 29
&lt;/span>&lt;span class="lnt"> 30
&lt;/span>&lt;span class="lnt"> 31
&lt;/span>&lt;span class="lnt"> 32
&lt;/span>&lt;span class="lnt"> 33
&lt;/span>&lt;span class="lnt"> 34
&lt;/span>&lt;span class="lnt"> 35
&lt;/span>&lt;span class="lnt"> 36
&lt;/span>&lt;span class="lnt"> 37
&lt;/span>&lt;span class="lnt"> 38
&lt;/span>&lt;span class="lnt"> 39
&lt;/span>&lt;span class="lnt"> 40
&lt;/span>&lt;span class="lnt"> 41
&lt;/span>&lt;span class="lnt"> 42
&lt;/span>&lt;span class="lnt"> 43
&lt;/span>&lt;span class="lnt"> 44
&lt;/span>&lt;span class="lnt"> 45
&lt;/span>&lt;span class="lnt"> 46
&lt;/span>&lt;span class="lnt"> 47
&lt;/span>&lt;span class="lnt"> 48
&lt;/span>&lt;span class="lnt"> 49
&lt;/span>&lt;span class="lnt"> 50
&lt;/span>&lt;span class="lnt"> 51
&lt;/span>&lt;span class="lnt"> 52
&lt;/span>&lt;span class="lnt"> 53
&lt;/span>&lt;span class="lnt"> 54
&lt;/span>&lt;span class="lnt"> 55
&lt;/span>&lt;span class="lnt"> 56
&lt;/span>&lt;span class="lnt"> 57
&lt;/span>&lt;span class="lnt"> 58
&lt;/span>&lt;span class="lnt"> 59
&lt;/span>&lt;span class="lnt"> 60
&lt;/span>&lt;span class="lnt"> 61
&lt;/span>&lt;span class="lnt"> 62
&lt;/span>&lt;span class="lnt"> 63
&lt;/span>&lt;span class="lnt"> 64
&lt;/span>&lt;span class="lnt"> 65
&lt;/span>&lt;span class="lnt"> 66
&lt;/span>&lt;span class="lnt"> 67
&lt;/span>&lt;span class="lnt"> 68
&lt;/span>&lt;span class="lnt"> 69
&lt;/span>&lt;span class="lnt"> 70
&lt;/span>&lt;span class="lnt"> 71
&lt;/span>&lt;span class="lnt"> 72
&lt;/span>&lt;span class="lnt"> 73
&lt;/span>&lt;span class="lnt"> 74
&lt;/span>&lt;span class="lnt"> 75
&lt;/span>&lt;span class="lnt"> 76
&lt;/span>&lt;span class="lnt"> 77
&lt;/span>&lt;span class="lnt"> 78
&lt;/span>&lt;span class="lnt"> 79
&lt;/span>&lt;span class="lnt"> 80
&lt;/span>&lt;span class="lnt"> 81
&lt;/span>&lt;span class="lnt"> 82
&lt;/span>&lt;span class="lnt"> 83
&lt;/span>&lt;span class="lnt"> 84
&lt;/span>&lt;span class="lnt"> 85
&lt;/span>&lt;span class="lnt"> 86
&lt;/span>&lt;span class="lnt"> 87
&lt;/span>&lt;span class="lnt"> 88
&lt;/span>&lt;span class="lnt"> 89
&lt;/span>&lt;span class="lnt"> 90
&lt;/span>&lt;span class="lnt"> 91
&lt;/span>&lt;span class="lnt"> 92
&lt;/span>&lt;span class="lnt"> 93
&lt;/span>&lt;span class="lnt"> 94
&lt;/span>&lt;span class="lnt"> 95
&lt;/span>&lt;span class="lnt"> 96
&lt;/span>&lt;span class="lnt"> 97
&lt;/span>&lt;span class="lnt"> 98
&lt;/span>&lt;span class="lnt"> 99
&lt;/span>&lt;span class="lnt">100
&lt;/span>&lt;span class="lnt">101
&lt;/span>&lt;span class="lnt">102
&lt;/span>&lt;span class="lnt">103
&lt;/span>&lt;span class="lnt">104
&lt;/span>&lt;span class="lnt">105
&lt;/span>&lt;span class="lnt">106
&lt;/span>&lt;span class="lnt">107
&lt;/span>&lt;span class="lnt">108
&lt;/span>&lt;span class="lnt">109
&lt;/span>&lt;span class="lnt">110
&lt;/span>&lt;span class="lnt">111
&lt;/span>&lt;span class="lnt">112
&lt;/span>&lt;span class="lnt">113
&lt;/span>&lt;span class="lnt">114
&lt;/span>&lt;span class="lnt">115
&lt;/span>&lt;span class="lnt">116
&lt;/span>&lt;span class="lnt">117
&lt;/span>&lt;span class="lnt">118
&lt;/span>&lt;span class="lnt">119
&lt;/span>&lt;span class="lnt">120
&lt;/span>&lt;span class="lnt">121
&lt;/span>&lt;span class="lnt">122
&lt;/span>&lt;span class="lnt">123
&lt;/span>&lt;span class="lnt">124
&lt;/span>&lt;span class="lnt">125
&lt;/span>&lt;span class="lnt">126
&lt;/span>&lt;span class="lnt">127
&lt;/span>&lt;span class="lnt">128
&lt;/span>&lt;span class="lnt">129
&lt;/span>&lt;span class="lnt">130
&lt;/span>&lt;span class="lnt">131
&lt;/span>&lt;span class="lnt">132
&lt;/span>&lt;span class="lnt">133
&lt;/span>&lt;span class="lnt">134
&lt;/span>&lt;span class="lnt">135
&lt;/span>&lt;span class="lnt">136
&lt;/span>&lt;span class="lnt">137
&lt;/span>&lt;span class="lnt">138
&lt;/span>&lt;span class="lnt">139
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">/**
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> *
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> */
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">import java.io.BufferedReader;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">import java.io.FileReader;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">import java.io.IOException;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">import java.io.InputStreamReader;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">import java.util.ArrayList;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">import java.util.Arrays;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">import java.util.LinkedList;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">import java.util.Queue;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">import java.util.Scanner;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">import java.util.StringTokenizer;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/**
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> * @author jaeji
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> *
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> */
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">class edge{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int to;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int flow;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int cap;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> edge rever;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> edge(){
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> this(0,0,0,null);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> edge(int ar_to, int ar_flow, int ar_cap, edge ar_rever){
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> to = ar_to;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> flow = ar_flow;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> cap = ar_cap;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> rever = ar_rever;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int residu() {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return cap-flow;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> void addflow(int ar_flow) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> flow+=ar_flow;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> rever.flow -=ar_flow;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">public class Main {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> public static void main(String[] args) throws IOException {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> BufferedReader br = new BufferedReader( new InputStreamReader( System.in ) );
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> //BufferedReader br = new BufferedReader( new FileReader(&amp;#34;input.txt&amp;#34; ) );
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> StringTokenizer st = new StringTokenizer(br.readLine());
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int n = Integer.parseInt(st.nextToken());
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int m = Integer.parseInt(st.nextToken());
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int[] prev = new int[402];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ArrayList[] adj = new ArrayList[402];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Queue&amp;lt;Integer&amp;gt; q = new LinkedList&amp;lt;Integer&amp;gt;();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int total = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for(int i=0;i&amp;lt;402;i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> adj[i] = new ArrayList&amp;lt;edge&amp;gt;();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for(int i=0;i&amp;lt;n;i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> edge temp_edge = new edge(i,0,1,null);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> edge temp_rever_edge = new edge(400,0,0,temp_edge);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> temp_edge.rever = temp_rever_edge;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> adj[400].add(temp_edge);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> adj[i].add(temp_rever_edge);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for(int i=200;i&amp;lt;200+m;i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> edge temp = new edge(401,0,1,null);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> edge temp_rever_edge = new edge(i,0,0,temp);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> temp.rever = temp_rever_edge;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> adj[i].add(temp);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> adj[401].add(temp_rever_edge);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int no = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int temp = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for(int i=0;i&amp;lt;n;i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> st = new StringTokenizer(br.readLine());
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> no = Integer.parseInt(st.nextToken());
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for(int j=0;j&amp;lt;no;j++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> temp = Integer.parseInt(st.nextToken())+199;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> edge temp_edge = new edge(temp,0,1,null);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> edge temp_rever_edge = new edge(i,0,0,temp_edge);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> temp_edge.rever = temp_rever_edge;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> adj[i].add(temp_edge);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> adj[temp].add(temp_rever_edge);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int curr = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> edge next = null;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int S = 400;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int E = 401;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while(true) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> edge[] path = new edge[402];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Arrays.fill(prev, -1);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> q.clear();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> q.add(S);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> curr = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> next = null;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while(!q.isEmpty()) { // 소스에서 흐를수 있는 유량찾기
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> curr = q.poll();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for(int i=0;i&amp;lt;adj[curr].size();i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> next = (edge) adj[curr].get(i);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if(next.residu() &amp;gt; 0 &amp;amp;&amp;amp; prev[next.to] == -1) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> q.add(next.to);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> prev[next.to] = curr;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> path[next.to] = next;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if(next.to == E) break;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if(prev[E] == -1) break; // 경로를 탐색 한 후 싱크로 가는 경로가 없는 경우
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for(int i=E;i!=S;i=prev[i]) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> path[i].addflow(1);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> total += 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> System.out.println(total);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>백준알고리즘 6086번, 최대 유량</title><link>https://jaejin0me.github.io/post/posts10/</link><pubDate>Thu, 04 Jan 2018 18:00:42 +0900</pubDate><guid>https://jaejin0me.github.io/post/posts10/</guid><description>&lt;p>드디어 네트워크플로우&lt;/p>
&lt;p>처음에 목표한 알고리즘이 MCMF까지였기 때문에, 곧 결과에 쫓기듯 공부할 필요는 없을꺼같다.&lt;/p>
&lt;p>배울 알고리즘이 참 많지만 사실 그런알고리즘은 내가 앞으로 쓸일이 있을까 하는 의문이 들어서 필요성을 느끼지 못하겠다. 그리고 필요하다면 그 때 배워서 사용하면 될꺼같기도 하다.
시험문제로 나온다면.. 그저 슬플수 밖에&lt;/p></description></item></channel></rss>